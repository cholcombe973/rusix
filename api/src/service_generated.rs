// automatically generated by the FlatBuffers compiler, do not modify


#![allow(dead_code)]
#![allow(unused_imports)]
extern crate flatbuffers;

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum ResultType {
  Ok = 0,
  Err = 1,

}

const ENUM_MIN_RESULT_TYPE: i8 = 0;
const ENUM_MAX_RESULT_TYPE: i8 = 1;

impl<'a> flatbuffers::Follow<'a> for ResultType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for ResultType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const ResultType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const ResultType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for ResultType {
    type Output = ResultType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<ResultType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_RESULT_TYPE:[ResultType; 2] = [
  ResultType::Ok,
  ResultType::Err
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_RESULT_TYPE:[&'static str; 2] = [
    "Ok",
    "Err"
];

pub fn enum_name_result_type(e: ResultType) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_RESULT_TYPE[index]
}

pub enum OpResultOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct OpResult<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OpResult<'a> {
    type Inner = OpResult<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> OpResult<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OpResult {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OpResultArgs<'args>) -> flatbuffers::WIPOffset<OpResult<'bldr>> {
      let mut builder = OpResultBuilder::new(_fbb);
      if let Some(x) = args.errorMsg { builder.add_errorMsg(x); }
      builder.add_errno(args.errno);
      builder.add_result(args.result);
      builder.finish()
    }

    pub const VT_RESULT: flatbuffers::VOffsetT = 4;
    pub const VT_ERRNO: flatbuffers::VOffsetT = 6;
    pub const VT_ERRORMSG: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn result(&'a self) -> ResultType {
    self._tab.get::<ResultType>(OpResult::VT_RESULT, Some(ResultType::Ok)).unwrap()
  }
  #[inline]
  pub fn errno(&'a self) -> i32 {
    self._tab.get::<i32>(OpResult::VT_ERRNO, Some(0)).unwrap()
  }
  #[inline]
  pub fn errorMsg(&'a self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OpResult::VT_ERRORMSG, None)
  }
}

pub struct OpResultArgs<'a> {
    pub result: ResultType,
    pub errno: i32,
    pub errorMsg: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for OpResultArgs<'a> {
    #[inline]
    fn default() -> Self {
        OpResultArgs {
            result: ResultType::Ok,
            errno: 0,
            errorMsg: None,
        }
    }
}
pub struct OpResultBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OpResultBuilder<'a, 'b> {
  #[inline]
  pub fn add_result(&mut self, result: ResultType) {
    self.fbb_.push_slot::<ResultType>(OpResult::VT_RESULT, result, ResultType::Ok);
  }
  #[inline]
  pub fn add_errno(&mut self, errno: i32) {
    self.fbb_.push_slot::<i32>(OpResult::VT_ERRNO, errno, 0);
  }
  #[inline]
  pub fn add_errorMsg(&mut self, errorMsg: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OpResult::VT_ERRORMSG, errorMsg);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OpResultBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OpResultBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OpResult<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IattOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Iatt<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Iatt<'a> {
    type Inner = Iatt<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Iatt<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Iatt {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IattArgs<'args>) -> flatbuffers::WIPOffset<Iatt<'bldr>> {
      let mut builder = IattBuilder::new(_fbb);
      builder.add_iaBlocks(args.iaBlocks);
      builder.add_iaSize(args.iaSize);
      builder.add_iaRdev(args.iaRdev);
      builder.add_iaDev(args.iaDev);
      builder.add_iaIno(args.iaIno);
      builder.add_iaCtimeNsec(args.iaCtimeNsec);
      builder.add_iaCtime(args.iaCtime);
      builder.add_iaMtimeNsec(args.iaMtimeNsec);
      builder.add_iaMtime(args.iaMtime);
      builder.add_iaAtimeNsec(args.iaAtimeNsec);
      builder.add_iaAtime(args.iaAtime);
      builder.add_iaBlksize(args.iaBlksize);
      builder.add_iaGid(args.iaGid);
      builder.add_iaUid(args.iaUid);
      builder.add_iaNlink(args.iaNlink);
      builder.add_mode(args.mode);
      if let Some(x) = args.iaGfid { builder.add_iaGfid(x); }
      builder.finish()
    }

    pub const VT_IAGFID: flatbuffers::VOffsetT = 4;
    pub const VT_IAINO: flatbuffers::VOffsetT = 6;
    pub const VT_IADEV: flatbuffers::VOffsetT = 8;
    pub const VT_MODE: flatbuffers::VOffsetT = 10;
    pub const VT_IANLINK: flatbuffers::VOffsetT = 12;
    pub const VT_IAUID: flatbuffers::VOffsetT = 14;
    pub const VT_IAGID: flatbuffers::VOffsetT = 16;
    pub const VT_IARDEV: flatbuffers::VOffsetT = 18;
    pub const VT_IASIZE: flatbuffers::VOffsetT = 20;
    pub const VT_IABLKSIZE: flatbuffers::VOffsetT = 22;
    pub const VT_IABLOCKS: flatbuffers::VOffsetT = 24;
    pub const VT_IAATIME: flatbuffers::VOffsetT = 26;
    pub const VT_IAATIMENSEC: flatbuffers::VOffsetT = 28;
    pub const VT_IAMTIME: flatbuffers::VOffsetT = 30;
    pub const VT_IAMTIMENSEC: flatbuffers::VOffsetT = 32;
    pub const VT_IACTIME: flatbuffers::VOffsetT = 34;
    pub const VT_IACTIMENSEC: flatbuffers::VOffsetT = 36;

  #[inline]
  pub fn iaGfid(&'a self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Iatt::VT_IAGFID, None)
  }
  #[inline]
  pub fn iaIno(&'a self) -> u64 {
    self._tab.get::<u64>(Iatt::VT_IAINO, Some(0)).unwrap()
  }
  #[inline]
  pub fn iaDev(&'a self) -> u64 {
    self._tab.get::<u64>(Iatt::VT_IADEV, Some(0)).unwrap()
  }
  #[inline]
  pub fn mode(&'a self) -> u32 {
    self._tab.get::<u32>(Iatt::VT_MODE, Some(0)).unwrap()
  }
  #[inline]
  pub fn iaNlink(&'a self) -> u32 {
    self._tab.get::<u32>(Iatt::VT_IANLINK, Some(0)).unwrap()
  }
  #[inline]
  pub fn iaUid(&'a self) -> u32 {
    self._tab.get::<u32>(Iatt::VT_IAUID, Some(0)).unwrap()
  }
  #[inline]
  pub fn iaGid(&'a self) -> u32 {
    self._tab.get::<u32>(Iatt::VT_IAGID, Some(0)).unwrap()
  }
  #[inline]
  pub fn iaRdev(&'a self) -> u64 {
    self._tab.get::<u64>(Iatt::VT_IARDEV, Some(0)).unwrap()
  }
  #[inline]
  pub fn iaSize(&'a self) -> u64 {
    self._tab.get::<u64>(Iatt::VT_IASIZE, Some(0)).unwrap()
  }
  #[inline]
  pub fn iaBlksize(&'a self) -> u32 {
    self._tab.get::<u32>(Iatt::VT_IABLKSIZE, Some(0)).unwrap()
  }
  #[inline]
  pub fn iaBlocks(&'a self) -> u64 {
    self._tab.get::<u64>(Iatt::VT_IABLOCKS, Some(0)).unwrap()
  }
  #[inline]
  pub fn iaAtime(&'a self) -> u32 {
    self._tab.get::<u32>(Iatt::VT_IAATIME, Some(0)).unwrap()
  }
  #[inline]
  pub fn iaAtimeNsec(&'a self) -> u32 {
    self._tab.get::<u32>(Iatt::VT_IAATIMENSEC, Some(0)).unwrap()
  }
  #[inline]
  pub fn iaMtime(&'a self) -> u32 {
    self._tab.get::<u32>(Iatt::VT_IAMTIME, Some(0)).unwrap()
  }
  #[inline]
  pub fn iaMtimeNsec(&'a self) -> u32 {
    self._tab.get::<u32>(Iatt::VT_IAMTIMENSEC, Some(0)).unwrap()
  }
  #[inline]
  pub fn iaCtime(&'a self) -> u32 {
    self._tab.get::<u32>(Iatt::VT_IACTIME, Some(0)).unwrap()
  }
  #[inline]
  pub fn iaCtimeNsec(&'a self) -> u32 {
    self._tab.get::<u32>(Iatt::VT_IACTIMENSEC, Some(0)).unwrap()
  }
}

pub struct IattArgs<'a> {
    pub iaGfid: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub iaIno: u64,
    pub iaDev: u64,
    pub mode: u32,
    pub iaNlink: u32,
    pub iaUid: u32,
    pub iaGid: u32,
    pub iaRdev: u64,
    pub iaSize: u64,
    pub iaBlksize: u32,
    pub iaBlocks: u64,
    pub iaAtime: u32,
    pub iaAtimeNsec: u32,
    pub iaMtime: u32,
    pub iaMtimeNsec: u32,
    pub iaCtime: u32,
    pub iaCtimeNsec: u32,
}
impl<'a> Default for IattArgs<'a> {
    #[inline]
    fn default() -> Self {
        IattArgs {
            iaGfid: None,
            iaIno: 0,
            iaDev: 0,
            mode: 0,
            iaNlink: 0,
            iaUid: 0,
            iaGid: 0,
            iaRdev: 0,
            iaSize: 0,
            iaBlksize: 0,
            iaBlocks: 0,
            iaAtime: 0,
            iaAtimeNsec: 0,
            iaMtime: 0,
            iaMtimeNsec: 0,
            iaCtime: 0,
            iaCtimeNsec: 0,
        }
    }
}
pub struct IattBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IattBuilder<'a, 'b> {
  #[inline]
  pub fn add_iaGfid(&mut self, iaGfid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Iatt::VT_IAGFID, iaGfid);
  }
  #[inline]
  pub fn add_iaIno(&mut self, iaIno: u64) {
    self.fbb_.push_slot::<u64>(Iatt::VT_IAINO, iaIno, 0);
  }
  #[inline]
  pub fn add_iaDev(&mut self, iaDev: u64) {
    self.fbb_.push_slot::<u64>(Iatt::VT_IADEV, iaDev, 0);
  }
  #[inline]
  pub fn add_mode(&mut self, mode: u32) {
    self.fbb_.push_slot::<u32>(Iatt::VT_MODE, mode, 0);
  }
  #[inline]
  pub fn add_iaNlink(&mut self, iaNlink: u32) {
    self.fbb_.push_slot::<u32>(Iatt::VT_IANLINK, iaNlink, 0);
  }
  #[inline]
  pub fn add_iaUid(&mut self, iaUid: u32) {
    self.fbb_.push_slot::<u32>(Iatt::VT_IAUID, iaUid, 0);
  }
  #[inline]
  pub fn add_iaGid(&mut self, iaGid: u32) {
    self.fbb_.push_slot::<u32>(Iatt::VT_IAGID, iaGid, 0);
  }
  #[inline]
  pub fn add_iaRdev(&mut self, iaRdev: u64) {
    self.fbb_.push_slot::<u64>(Iatt::VT_IARDEV, iaRdev, 0);
  }
  #[inline]
  pub fn add_iaSize(&mut self, iaSize: u64) {
    self.fbb_.push_slot::<u64>(Iatt::VT_IASIZE, iaSize, 0);
  }
  #[inline]
  pub fn add_iaBlksize(&mut self, iaBlksize: u32) {
    self.fbb_.push_slot::<u32>(Iatt::VT_IABLKSIZE, iaBlksize, 0);
  }
  #[inline]
  pub fn add_iaBlocks(&mut self, iaBlocks: u64) {
    self.fbb_.push_slot::<u64>(Iatt::VT_IABLOCKS, iaBlocks, 0);
  }
  #[inline]
  pub fn add_iaAtime(&mut self, iaAtime: u32) {
    self.fbb_.push_slot::<u32>(Iatt::VT_IAATIME, iaAtime, 0);
  }
  #[inline]
  pub fn add_iaAtimeNsec(&mut self, iaAtimeNsec: u32) {
    self.fbb_.push_slot::<u32>(Iatt::VT_IAATIMENSEC, iaAtimeNsec, 0);
  }
  #[inline]
  pub fn add_iaMtime(&mut self, iaMtime: u32) {
    self.fbb_.push_slot::<u32>(Iatt::VT_IAMTIME, iaMtime, 0);
  }
  #[inline]
  pub fn add_iaMtimeNsec(&mut self, iaMtimeNsec: u32) {
    self.fbb_.push_slot::<u32>(Iatt::VT_IAMTIMENSEC, iaMtimeNsec, 0);
  }
  #[inline]
  pub fn add_iaCtime(&mut self, iaCtime: u32) {
    self.fbb_.push_slot::<u32>(Iatt::VT_IACTIME, iaCtime, 0);
  }
  #[inline]
  pub fn add_iaCtimeNsec(&mut self, iaCtimeNsec: u32) {
    self.fbb_.push_slot::<u32>(Iatt::VT_IACTIMENSEC, iaCtimeNsec, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IattBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IattBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Iatt<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum StatRequestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StatRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StatRequest<'a> {
    type Inner = StatRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StatRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StatRequest {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StatRequestArgs<'args>) -> flatbuffers::WIPOffset<StatRequest<'bldr>> {
      let mut builder = StatRequestBuilder::new(_fbb);
      if let Some(x) = args.gfid { builder.add_gfid(x); }
      builder.finish()
    }

    pub const VT_GFID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn gfid(&'a self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StatRequest::VT_GFID, None)
  }
}

pub struct StatRequestArgs<'a> {
    pub gfid: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for StatRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        StatRequestArgs {
            gfid: None,
        }
    }
}
pub struct StatRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StatRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_gfid(&mut self, gfid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StatRequest::VT_GFID, gfid);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StatRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StatRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StatRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum StatResponseOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StatResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StatResponse<'a> {
    type Inner = StatResponse<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StatResponse<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StatResponse {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StatResponseArgs<'args>) -> flatbuffers::WIPOffset<StatResponse<'bldr>> {
      let mut builder = StatResponseBuilder::new(_fbb);
      if let Some(x) = args.extraData { builder.add_extraData(x); }
      if let Some(x) = args.stat { builder.add_stat(x); }
      if let Some(x) = args.result { builder.add_result(x); }
      builder.finish()
    }

    pub const VT_RESULT: flatbuffers::VOffsetT = 4;
    pub const VT_STAT: flatbuffers::VOffsetT = 6;
    pub const VT_EXTRADATA: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn result(&'a self) -> Option<OpResult<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<OpResult<'a>>>(StatResponse::VT_RESULT, None)
  }
  #[inline]
  pub fn stat(&'a self) -> Option<Iatt<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Iatt<'a>>>(StatResponse::VT_STAT, None)
  }
  #[inline]
  pub fn extraData(&'a self) -> Option<&'a [i8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(StatResponse::VT_EXTRADATA, None).map(|v| v.safe_slice())
  }
}

pub struct StatResponseArgs<'a> {
    pub result: Option<flatbuffers::WIPOffset<OpResult<'a >>>,
    pub stat: Option<flatbuffers::WIPOffset<Iatt<'a >>>,
    pub extraData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  i8>>>,
}
impl<'a> Default for StatResponseArgs<'a> {
    #[inline]
    fn default() -> Self {
        StatResponseArgs {
            result: None,
            stat: None,
            extraData: None,
        }
    }
}
pub struct StatResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StatResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_result(&mut self, result: flatbuffers::WIPOffset<OpResult<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<OpResult>>(StatResponse::VT_RESULT, result);
  }
  #[inline]
  pub fn add_stat(&mut self, stat: flatbuffers::WIPOffset<Iatt<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Iatt>>(StatResponse::VT_STAT, stat);
  }
  #[inline]
  pub fn add_extraData(&mut self, extraData: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StatResponse::VT_EXTRADATA, extraData);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StatResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StatResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StatResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum OperationOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Operation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Operation<'a> {
    type Inner = Operation<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Operation<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Operation {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OperationArgs<'args>) -> flatbuffers::WIPOffset<Operation<'bldr>> {
      let mut builder = OperationBuilder::new(_fbb);
      if let Some(x) = args.stat { builder.add_stat(x); }
      builder.finish()
    }

    pub const VT_STAT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn stat(&'a self) -> Option<StatRequest<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<StatRequest<'a>>>(Operation::VT_STAT, None)
  }
}

pub struct OperationArgs<'a> {
    pub stat: Option<flatbuffers::WIPOffset<StatRequest<'a >>>,
}
impl<'a> Default for OperationArgs<'a> {
    #[inline]
    fn default() -> Self {
        OperationArgs {
            stat: None,
        }
    }
}
pub struct OperationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OperationBuilder<'a, 'b> {
  #[inline]
  pub fn add_stat(&mut self, stat: flatbuffers::WIPOffset<StatRequest<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StatRequest>>(Operation::VT_STAT, stat);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OperationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OperationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Operation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_operation<'a>(buf: &'a [u8]) -> Operation<'a> {
  flatbuffers::get_root::<Operation<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_operation<'a>(buf: &'a [u8]) -> Operation<'a> {
  flatbuffers::get_size_prefixed_root::<Operation<'a>>(buf)
}

#[inline]
pub fn finish_operation_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Operation<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_operation_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Operation<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
