// This file is generated. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Lease {
    // message fields
    cmd: ::std::option::Option<LeaseCmds>,
    lease_type: ::std::option::Option<LeaseTypes>,
    lease_id: ::protobuf::SingularField<::std::string::String>,
    lease_flags: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Lease {}

impl Lease {
    pub fn new() -> Lease {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Lease {
        static mut instance: ::protobuf::lazy::Lazy<Lease> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Lease,
        };
        unsafe {
            instance.get(Lease::new)
        }
    }

    // required .rusix.LeaseCmds cmd = 1;

    pub fn clear_cmd(&mut self) {
        self.cmd = ::std::option::Option::None;
    }

    pub fn has_cmd(&self) -> bool {
        self.cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd(&mut self, v: LeaseCmds) {
        self.cmd = ::std::option::Option::Some(v);
    }

    pub fn get_cmd(&self) -> LeaseCmds {
        self.cmd.unwrap_or(LeaseCmds::GET_LEASE)
    }

    fn get_cmd_for_reflect(&self) -> &::std::option::Option<LeaseCmds> {
        &self.cmd
    }

    fn mut_cmd_for_reflect(&mut self) -> &mut ::std::option::Option<LeaseCmds> {
        &mut self.cmd
    }

    // required .rusix.LeaseTypes lease_type = 2;

    pub fn clear_lease_type(&mut self) {
        self.lease_type = ::std::option::Option::None;
    }

    pub fn has_lease_type(&self) -> bool {
        self.lease_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lease_type(&mut self, v: LeaseTypes) {
        self.lease_type = ::std::option::Option::Some(v);
    }

    pub fn get_lease_type(&self) -> LeaseTypes {
        self.lease_type.unwrap_or(LeaseTypes::NONE)
    }

    fn get_lease_type_for_reflect(&self) -> &::std::option::Option<LeaseTypes> {
        &self.lease_type
    }

    fn mut_lease_type_for_reflect(&mut self) -> &mut ::std::option::Option<LeaseTypes> {
        &mut self.lease_type
    }

    // required string lease_id = 3;

    pub fn clear_lease_id(&mut self) {
        self.lease_id.clear();
    }

    pub fn has_lease_id(&self) -> bool {
        self.lease_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lease_id(&mut self, v: ::std::string::String) {
        self.lease_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lease_id(&mut self) -> &mut ::std::string::String {
        if self.lease_id.is_none() {
            self.lease_id.set_default();
        }
        self.lease_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_lease_id(&mut self) -> ::std::string::String {
        self.lease_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_lease_id(&self) -> &str {
        match self.lease_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_lease_id_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.lease_id
    }

    fn mut_lease_id_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.lease_id
    }

    // required uint32 lease_flags = 4;

    pub fn clear_lease_flags(&mut self) {
        self.lease_flags = ::std::option::Option::None;
    }

    pub fn has_lease_flags(&self) -> bool {
        self.lease_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lease_flags(&mut self, v: u32) {
        self.lease_flags = ::std::option::Option::Some(v);
    }

    pub fn get_lease_flags(&self) -> u32 {
        self.lease_flags.unwrap_or(0)
    }

    fn get_lease_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.lease_flags
    }

    fn mut_lease_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.lease_flags
    }
}

impl ::protobuf::Message for Lease {
    fn is_initialized(&self) -> bool {
        if self.cmd.is_none() {
            return false;
        }
        if self.lease_type.is_none() {
            return false;
        }
        if self.lease_id.is_none() {
            return false;
        }
        if self.lease_flags.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.cmd = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.lease_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.lease_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lease_flags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cmd {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.lease_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.lease_id.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.lease_flags {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cmd {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.lease_type {
            os.write_enum(2, v.value())?;
        }
        if let Some(ref v) = self.lease_id.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.lease_flags {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Lease {
    fn new() -> Lease {
        Lease::new()
    }

    fn descriptor_static(_: ::std::option::Option<Lease>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LeaseCmds>>(
                    "cmd",
                    Lease::get_cmd_for_reflect,
                    Lease::mut_cmd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LeaseTypes>>(
                    "lease_type",
                    Lease::get_lease_type_for_reflect,
                    Lease::mut_lease_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "lease_id",
                    Lease::get_lease_id_for_reflect,
                    Lease::mut_lease_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lease_flags",
                    Lease::get_lease_flags_for_reflect,
                    Lease::mut_lease_flags_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Lease>(
                    "Lease",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Lease {
    fn clear(&mut self) {
        self.clear_cmd();
        self.clear_lease_type();
        self.clear_lease_id();
        self.clear_lease_flags();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Lease {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Lease {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct lkowner_t {
    // message fields
    data: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for lkowner_t {}

impl lkowner_t {
    pub fn new() -> lkowner_t {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static lkowner_t {
        static mut instance: ::protobuf::lazy::Lazy<lkowner_t> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const lkowner_t,
        };
        unsafe {
            instance.get(lkowner_t::new)
        }
    }

    // required string data = 2;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::string::String) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::string::String {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::string::String {
        self.data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_data(&self) -> &str {
        match self.data.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_data_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.data
    }
}

impl ::protobuf::Message for lkowner_t {
    fn is_initialized(&self) -> bool {
        if self.data.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for lkowner_t {
    fn new() -> lkowner_t {
        lkowner_t::new()
    }

    fn descriptor_static(_: ::std::option::Option<lkowner_t>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "data",
                    lkowner_t::get_data_for_reflect,
                    lkowner_t::mut_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<lkowner_t>(
                    "lkowner_t",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for lkowner_t {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for lkowner_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for lkowner_t {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyValue {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for KeyValue {}

impl KeyValue {
    pub fn new() -> KeyValue {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static KeyValue {
        static mut instance: ::protobuf::lazy::Lazy<KeyValue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KeyValue,
        };
        unsafe {
            instance.get(KeyValue::new)
        }
    }

    // required string key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_key_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.key
    }

    fn mut_key_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.key
    }

    // required bytes data = 2;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.data
    }
}

impl ::protobuf::Message for KeyValue {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.data.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for KeyValue {
    fn new() -> KeyValue {
        KeyValue::new()
    }

    fn descriptor_static(_: ::std::option::Option<KeyValue>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    KeyValue::get_key_for_reflect,
                    KeyValue::mut_key_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    KeyValue::get_data_for_reflect,
                    KeyValue::mut_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<KeyValue>(
                    "KeyValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for KeyValue {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyValue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Dict {
    // message fields
    data: ::protobuf::RepeatedField<KeyValue>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Dict {}

impl Dict {
    pub fn new() -> Dict {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Dict {
        static mut instance: ::protobuf::lazy::Lazy<Dict> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Dict,
        };
        unsafe {
            instance.get(Dict::new)
        }
    }

    // repeated .rusix.KeyValue data = 1;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<KeyValue>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<KeyValue> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<KeyValue> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }

    pub fn get_data(&self) -> &[KeyValue] {
        &self.data
    }

    fn get_data_for_reflect(&self) -> &::protobuf::RepeatedField<KeyValue> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<KeyValue> {
        &mut self.data
    }
}

impl ::protobuf::Message for Dict {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.data {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Dict {
    fn new() -> Dict {
        Dict::new()
    }

    fn descriptor_static(_: ::std::option::Option<Dict>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyValue>>(
                    "data",
                    Dict::get_data_for_reflect,
                    Dict::mut_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Dict>(
                    "Dict",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Dict {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Dict {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dict {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpResult {
    // message fields
    result: ::std::option::Option<ResultType>,
    errno: ::std::option::Option<i32>,
    error_msg: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for OpResult {}

impl OpResult {
    pub fn new() -> OpResult {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static OpResult {
        static mut instance: ::protobuf::lazy::Lazy<OpResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpResult,
        };
        unsafe {
            instance.get(OpResult::new)
        }
    }

    // required .rusix.ResultType result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ResultType) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result(&self) -> ResultType {
        self.result.unwrap_or(ResultType::OK)
    }

    fn get_result_for_reflect(&self) -> &::std::option::Option<ResultType> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::std::option::Option<ResultType> {
        &mut self.result
    }

    // optional int32 errno = 2;

    pub fn clear_errno(&mut self) {
        self.errno = ::std::option::Option::None;
    }

    pub fn has_errno(&self) -> bool {
        self.errno.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errno(&mut self, v: i32) {
        self.errno = ::std::option::Option::Some(v);
    }

    pub fn get_errno(&self) -> i32 {
        self.errno.unwrap_or(0)
    }

    fn get_errno_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.errno
    }

    fn mut_errno_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.errno
    }

    // optional string error_msg = 3;

    pub fn clear_error_msg(&mut self) {
        self.error_msg.clear();
    }

    pub fn has_error_msg(&self) -> bool {
        self.error_msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_msg(&mut self, v: ::std::string::String) {
        self.error_msg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_msg(&mut self) -> &mut ::std::string::String {
        if self.error_msg.is_none() {
            self.error_msg.set_default();
        }
        self.error_msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_msg(&mut self) -> ::std::string::String {
        self.error_msg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_error_msg(&self) -> &str {
        match self.error_msg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_error_msg_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.error_msg
    }

    fn mut_error_msg_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.error_msg
    }
}

impl ::protobuf::Message for OpResult {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_enum()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.errno = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error_msg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.errno {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.error_msg.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.errno {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.error_msg.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for OpResult {
    fn new() -> OpResult {
        OpResult::new()
    }

    fn descriptor_static(_: ::std::option::Option<OpResult>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResultType>>(
                    "result",
                    OpResult::get_result_for_reflect,
                    OpResult::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "errno",
                    OpResult::get_errno_for_reflect,
                    OpResult::mut_errno_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error_msg",
                    OpResult::get_error_msg_for_reflect,
                    OpResult::mut_error_msg_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpResult>(
                    "OpResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for OpResult {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_errno();
        self.clear_error_msg();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Operation {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Operation {}

impl Operation {
    pub fn new() -> Operation {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Operation {
        static mut instance: ::protobuf::lazy::Lazy<Operation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Operation,
        };
        unsafe {
            instance.get(Operation::new)
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional bytes data = 2;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.data
    }
}

impl ::protobuf::Message for Operation {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Operation {
    fn new() -> Operation {
        Operation::new()
    }

    fn descriptor_static(_: ::std::option::Option<Operation>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    Operation::get_name_for_reflect,
                    Operation::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    Operation::get_data_for_reflect,
                    Operation::mut_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Operation>(
                    "Operation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Operation {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Operation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Operation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statfs {
    // message fields
    bsize: ::std::option::Option<u64>,
    frsize: ::std::option::Option<u64>,
    blocks: ::std::option::Option<u64>,
    bfree: ::std::option::Option<u64>,
    bavail: ::std::option::Option<u64>,
    files: ::std::option::Option<u64>,
    ffree: ::std::option::Option<u64>,
    favail: ::std::option::Option<u64>,
    fsid: ::std::option::Option<u64>,
    flag: ::std::option::Option<u64>,
    namemax: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Statfs {}

impl Statfs {
    pub fn new() -> Statfs {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Statfs {
        static mut instance: ::protobuf::lazy::Lazy<Statfs> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Statfs,
        };
        unsafe {
            instance.get(Statfs::new)
        }
    }

    // required uint64 bsize = 1;

    pub fn clear_bsize(&mut self) {
        self.bsize = ::std::option::Option::None;
    }

    pub fn has_bsize(&self) -> bool {
        self.bsize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bsize(&mut self, v: u64) {
        self.bsize = ::std::option::Option::Some(v);
    }

    pub fn get_bsize(&self) -> u64 {
        self.bsize.unwrap_or(0)
    }

    fn get_bsize_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.bsize
    }

    fn mut_bsize_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.bsize
    }

    // required uint64 frsize = 2;

    pub fn clear_frsize(&mut self) {
        self.frsize = ::std::option::Option::None;
    }

    pub fn has_frsize(&self) -> bool {
        self.frsize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frsize(&mut self, v: u64) {
        self.frsize = ::std::option::Option::Some(v);
    }

    pub fn get_frsize(&self) -> u64 {
        self.frsize.unwrap_or(0)
    }

    fn get_frsize_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.frsize
    }

    fn mut_frsize_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.frsize
    }

    // required uint64 blocks = 3;

    pub fn clear_blocks(&mut self) {
        self.blocks = ::std::option::Option::None;
    }

    pub fn has_blocks(&self) -> bool {
        self.blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: u64) {
        self.blocks = ::std::option::Option::Some(v);
    }

    pub fn get_blocks(&self) -> u64 {
        self.blocks.unwrap_or(0)
    }

    fn get_blocks_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.blocks
    }

    fn mut_blocks_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.blocks
    }

    // required uint64 bfree = 4;

    pub fn clear_bfree(&mut self) {
        self.bfree = ::std::option::Option::None;
    }

    pub fn has_bfree(&self) -> bool {
        self.bfree.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bfree(&mut self, v: u64) {
        self.bfree = ::std::option::Option::Some(v);
    }

    pub fn get_bfree(&self) -> u64 {
        self.bfree.unwrap_or(0)
    }

    fn get_bfree_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.bfree
    }

    fn mut_bfree_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.bfree
    }

    // required uint64 bavail = 5;

    pub fn clear_bavail(&mut self) {
        self.bavail = ::std::option::Option::None;
    }

    pub fn has_bavail(&self) -> bool {
        self.bavail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bavail(&mut self, v: u64) {
        self.bavail = ::std::option::Option::Some(v);
    }

    pub fn get_bavail(&self) -> u64 {
        self.bavail.unwrap_or(0)
    }

    fn get_bavail_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.bavail
    }

    fn mut_bavail_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.bavail
    }

    // required uint64 files = 6;

    pub fn clear_files(&mut self) {
        self.files = ::std::option::Option::None;
    }

    pub fn has_files(&self) -> bool {
        self.files.is_some()
    }

    // Param is passed by value, moved
    pub fn set_files(&mut self, v: u64) {
        self.files = ::std::option::Option::Some(v);
    }

    pub fn get_files(&self) -> u64 {
        self.files.unwrap_or(0)
    }

    fn get_files_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.files
    }

    fn mut_files_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.files
    }

    // required uint64 ffree = 7;

    pub fn clear_ffree(&mut self) {
        self.ffree = ::std::option::Option::None;
    }

    pub fn has_ffree(&self) -> bool {
        self.ffree.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ffree(&mut self, v: u64) {
        self.ffree = ::std::option::Option::Some(v);
    }

    pub fn get_ffree(&self) -> u64 {
        self.ffree.unwrap_or(0)
    }

    fn get_ffree_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.ffree
    }

    fn mut_ffree_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.ffree
    }

    // required uint64 favail = 8;

    pub fn clear_favail(&mut self) {
        self.favail = ::std::option::Option::None;
    }

    pub fn has_favail(&self) -> bool {
        self.favail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favail(&mut self, v: u64) {
        self.favail = ::std::option::Option::Some(v);
    }

    pub fn get_favail(&self) -> u64 {
        self.favail.unwrap_or(0)
    }

    fn get_favail_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.favail
    }

    fn mut_favail_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.favail
    }

    // required uint64 fsid = 9;

    pub fn clear_fsid(&mut self) {
        self.fsid = ::std::option::Option::None;
    }

    pub fn has_fsid(&self) -> bool {
        self.fsid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsid(&mut self, v: u64) {
        self.fsid = ::std::option::Option::Some(v);
    }

    pub fn get_fsid(&self) -> u64 {
        self.fsid.unwrap_or(0)
    }

    fn get_fsid_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fsid
    }

    fn mut_fsid_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fsid
    }

    // required uint64 flag = 10;

    pub fn clear_flag(&mut self) {
        self.flag = ::std::option::Option::None;
    }

    pub fn has_flag(&self) -> bool {
        self.flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flag(&mut self, v: u64) {
        self.flag = ::std::option::Option::Some(v);
    }

    pub fn get_flag(&self) -> u64 {
        self.flag.unwrap_or(0)
    }

    fn get_flag_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.flag
    }

    fn mut_flag_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.flag
    }

    // required uint64 namemax = 11;

    pub fn clear_namemax(&mut self) {
        self.namemax = ::std::option::Option::None;
    }

    pub fn has_namemax(&self) -> bool {
        self.namemax.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namemax(&mut self, v: u64) {
        self.namemax = ::std::option::Option::Some(v);
    }

    pub fn get_namemax(&self) -> u64 {
        self.namemax.unwrap_or(0)
    }

    fn get_namemax_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.namemax
    }

    fn mut_namemax_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.namemax
    }
}

impl ::protobuf::Message for Statfs {
    fn is_initialized(&self) -> bool {
        if self.bsize.is_none() {
            return false;
        }
        if self.frsize.is_none() {
            return false;
        }
        if self.blocks.is_none() {
            return false;
        }
        if self.bfree.is_none() {
            return false;
        }
        if self.bavail.is_none() {
            return false;
        }
        if self.files.is_none() {
            return false;
        }
        if self.ffree.is_none() {
            return false;
        }
        if self.favail.is_none() {
            return false;
        }
        if self.fsid.is_none() {
            return false;
        }
        if self.flag.is_none() {
            return false;
        }
        if self.namemax.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bsize = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.frsize = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blocks = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bfree = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bavail = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.files = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ffree = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.favail = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fsid = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.flag = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.namemax = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bsize {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.frsize {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blocks {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bfree {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bavail {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.files {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ffree {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.favail {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fsid {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flag {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.namemax {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bsize {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.frsize {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.blocks {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.bfree {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.bavail {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.files {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.ffree {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.favail {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.fsid {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.flag {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.namemax {
            os.write_uint64(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Statfs {
    fn new() -> Statfs {
        Statfs::new()
    }

    fn descriptor_static(_: ::std::option::Option<Statfs>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "bsize",
                    Statfs::get_bsize_for_reflect,
                    Statfs::mut_bsize_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "frsize",
                    Statfs::get_frsize_for_reflect,
                    Statfs::mut_frsize_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blocks",
                    Statfs::get_blocks_for_reflect,
                    Statfs::mut_blocks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "bfree",
                    Statfs::get_bfree_for_reflect,
                    Statfs::mut_bfree_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "bavail",
                    Statfs::get_bavail_for_reflect,
                    Statfs::mut_bavail_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "files",
                    Statfs::get_files_for_reflect,
                    Statfs::mut_files_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ffree",
                    Statfs::get_ffree_for_reflect,
                    Statfs::mut_ffree_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "favail",
                    Statfs::get_favail_for_reflect,
                    Statfs::mut_favail_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fsid",
                    Statfs::get_fsid_for_reflect,
                    Statfs::mut_fsid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "flag",
                    Statfs::get_flag_for_reflect,
                    Statfs::mut_flag_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "namemax",
                    Statfs::get_namemax_for_reflect,
                    Statfs::mut_namemax_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Statfs>(
                    "Statfs",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Statfs {
    fn clear(&mut self) {
        self.clear_bsize();
        self.clear_frsize();
        self.clear_blocks();
        self.clear_bfree();
        self.clear_bavail();
        self.clear_files();
        self.clear_ffree();
        self.clear_favail();
        self.clear_fsid();
        self.clear_flag();
        self.clear_namemax();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statfs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statfs {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProtoFlock {
    // message fields
    field_type: ::std::option::Option<u32>,
    whence: ::std::option::Option<u32>,
    start: ::std::option::Option<u64>,
    len: ::std::option::Option<u64>,
    pid: ::std::option::Option<u32>,
    lk_owner: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ProtoFlock {}

impl ProtoFlock {
    pub fn new() -> ProtoFlock {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ProtoFlock {
        static mut instance: ::protobuf::lazy::Lazy<ProtoFlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProtoFlock,
        };
        unsafe {
            instance.get(ProtoFlock::new)
        }
    }

    // required uint32 type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.field_type
    }

    // required uint32 whence = 2;

    pub fn clear_whence(&mut self) {
        self.whence = ::std::option::Option::None;
    }

    pub fn has_whence(&self) -> bool {
        self.whence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_whence(&mut self, v: u32) {
        self.whence = ::std::option::Option::Some(v);
    }

    pub fn get_whence(&self) -> u32 {
        self.whence.unwrap_or(0)
    }

    fn get_whence_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.whence
    }

    fn mut_whence_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.whence
    }

    // required uint64 start = 3;

    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: u64) {
        self.start = ::std::option::Option::Some(v);
    }

    pub fn get_start(&self) -> u64 {
        self.start.unwrap_or(0)
    }

    fn get_start_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.start
    }

    fn mut_start_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.start
    }

    // required uint64 len = 4;

    pub fn clear_len(&mut self) {
        self.len = ::std::option::Option::None;
    }

    pub fn has_len(&self) -> bool {
        self.len.is_some()
    }

    // Param is passed by value, moved
    pub fn set_len(&mut self, v: u64) {
        self.len = ::std::option::Option::Some(v);
    }

    pub fn get_len(&self) -> u64 {
        self.len.unwrap_or(0)
    }

    fn get_len_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.len
    }

    fn mut_len_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.len
    }

    // required uint32 pid = 5;

    pub fn clear_pid(&mut self) {
        self.pid = ::std::option::Option::None;
    }

    pub fn has_pid(&self) -> bool {
        self.pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pid(&mut self, v: u32) {
        self.pid = ::std::option::Option::Some(v);
    }

    pub fn get_pid(&self) -> u32 {
        self.pid.unwrap_or(0)
    }

    fn get_pid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.pid
    }

    fn mut_pid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.pid
    }

    // required string lk_owner = 6;

    pub fn clear_lk_owner(&mut self) {
        self.lk_owner.clear();
    }

    pub fn has_lk_owner(&self) -> bool {
        self.lk_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lk_owner(&mut self, v: ::std::string::String) {
        self.lk_owner = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lk_owner(&mut self) -> &mut ::std::string::String {
        if self.lk_owner.is_none() {
            self.lk_owner.set_default();
        }
        self.lk_owner.as_mut().unwrap()
    }

    // Take field
    pub fn take_lk_owner(&mut self) -> ::std::string::String {
        self.lk_owner.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_lk_owner(&self) -> &str {
        match self.lk_owner.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_lk_owner_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.lk_owner
    }

    fn mut_lk_owner_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.lk_owner
    }
}

impl ::protobuf::Message for ProtoFlock {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        if self.whence.is_none() {
            return false;
        }
        if self.start.is_none() {
            return false;
        }
        if self.len.is_none() {
            return false;
        }
        if self.pid.is_none() {
            return false;
        }
        if self.lk_owner.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.whence = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.len = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pid = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.lk_owner)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.whence {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.len {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.lk_owner.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.whence {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.start {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.len {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.pid {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.lk_owner.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ProtoFlock {
    fn new() -> ProtoFlock {
        ProtoFlock::new()
    }

    fn descriptor_static(_: ::std::option::Option<ProtoFlock>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    ProtoFlock::get_field_type_for_reflect,
                    ProtoFlock::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "whence",
                    ProtoFlock::get_whence_for_reflect,
                    ProtoFlock::mut_whence_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "start",
                    ProtoFlock::get_start_for_reflect,
                    ProtoFlock::mut_start_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "len",
                    ProtoFlock::get_len_for_reflect,
                    ProtoFlock::mut_len_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pid",
                    ProtoFlock::get_pid_for_reflect,
                    ProtoFlock::mut_pid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "lk_owner",
                    ProtoFlock::get_lk_owner_for_reflect,
                    ProtoFlock::mut_lk_owner_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProtoFlock>(
                    "ProtoFlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ProtoFlock {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_whence();
        self.clear_start();
        self.clear_len();
        self.clear_pid();
        self.clear_lk_owner();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtoFlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoFlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProtoLease {
    // message fields
    cmd: ::std::option::Option<u32>,
    lease_type: ::std::option::Option<u32>,
    lease_id: ::protobuf::SingularField<::std::string::String>,
    lease_flags: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ProtoLease {}

impl ProtoLease {
    pub fn new() -> ProtoLease {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ProtoLease {
        static mut instance: ::protobuf::lazy::Lazy<ProtoLease> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProtoLease,
        };
        unsafe {
            instance.get(ProtoLease::new)
        }
    }

    // required uint32 cmd = 1;

    pub fn clear_cmd(&mut self) {
        self.cmd = ::std::option::Option::None;
    }

    pub fn has_cmd(&self) -> bool {
        self.cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd(&mut self, v: u32) {
        self.cmd = ::std::option::Option::Some(v);
    }

    pub fn get_cmd(&self) -> u32 {
        self.cmd.unwrap_or(0)
    }

    fn get_cmd_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cmd
    }

    fn mut_cmd_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cmd
    }

    // required uint32 lease_type = 2;

    pub fn clear_lease_type(&mut self) {
        self.lease_type = ::std::option::Option::None;
    }

    pub fn has_lease_type(&self) -> bool {
        self.lease_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lease_type(&mut self, v: u32) {
        self.lease_type = ::std::option::Option::Some(v);
    }

    pub fn get_lease_type(&self) -> u32 {
        self.lease_type.unwrap_or(0)
    }

    fn get_lease_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.lease_type
    }

    fn mut_lease_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.lease_type
    }

    // required string lease_id = 3;

    pub fn clear_lease_id(&mut self) {
        self.lease_id.clear();
    }

    pub fn has_lease_id(&self) -> bool {
        self.lease_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lease_id(&mut self, v: ::std::string::String) {
        self.lease_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lease_id(&mut self) -> &mut ::std::string::String {
        if self.lease_id.is_none() {
            self.lease_id.set_default();
        }
        self.lease_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_lease_id(&mut self) -> ::std::string::String {
        self.lease_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_lease_id(&self) -> &str {
        match self.lease_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_lease_id_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.lease_id
    }

    fn mut_lease_id_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.lease_id
    }

    // required uint32 lease_flags = 4;

    pub fn clear_lease_flags(&mut self) {
        self.lease_flags = ::std::option::Option::None;
    }

    pub fn has_lease_flags(&self) -> bool {
        self.lease_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lease_flags(&mut self, v: u32) {
        self.lease_flags = ::std::option::Option::Some(v);
    }

    pub fn get_lease_flags(&self) -> u32 {
        self.lease_flags.unwrap_or(0)
    }

    fn get_lease_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.lease_flags
    }

    fn mut_lease_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.lease_flags
    }
}

impl ::protobuf::Message for ProtoLease {
    fn is_initialized(&self) -> bool {
        if self.cmd.is_none() {
            return false;
        }
        if self.lease_type.is_none() {
            return false;
        }
        if self.lease_id.is_none() {
            return false;
        }
        if self.lease_flags.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cmd = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lease_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.lease_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lease_flags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cmd {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lease_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.lease_id.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.lease_flags {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cmd {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.lease_type {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.lease_id.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.lease_flags {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ProtoLease {
    fn new() -> ProtoLease {
        ProtoLease::new()
    }

    fn descriptor_static(_: ::std::option::Option<ProtoLease>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cmd",
                    ProtoLease::get_cmd_for_reflect,
                    ProtoLease::mut_cmd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lease_type",
                    ProtoLease::get_lease_type_for_reflect,
                    ProtoLease::mut_lease_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "lease_id",
                    ProtoLease::get_lease_id_for_reflect,
                    ProtoLease::mut_lease_id_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lease_flags",
                    ProtoLease::get_lease_flags_for_reflect,
                    ProtoLease::mut_lease_flags_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProtoLease>(
                    "ProtoLease",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ProtoLease {
    fn clear(&mut self) {
        self.clear_cmd();
        self.clear_lease_type();
        self.clear_lease_id();
        self.clear_lease_flags();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtoLease {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoLease {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Iatt {
    // message fields
    ia_gfid: ::protobuf::SingularField<::std::string::String>,
    ia_ino: ::std::option::Option<u64>,
    ia_dev: ::std::option::Option<u64>,
    mode: ::std::option::Option<u32>,
    ia_nlink: ::std::option::Option<u32>,
    ia_uid: ::std::option::Option<u32>,
    ia_gid: ::std::option::Option<u32>,
    ia_rdev: ::std::option::Option<u64>,
    ia_size: ::std::option::Option<u64>,
    ia_blksize: ::std::option::Option<u32>,
    ia_blocks: ::std::option::Option<u64>,
    ia_atime: ::std::option::Option<u32>,
    ia_atime_nsec: ::std::option::Option<u32>,
    ia_mtime: ::std::option::Option<u32>,
    ia_mtime_nsec: ::std::option::Option<u32>,
    ia_ctime: ::std::option::Option<u32>,
    ia_ctime_nsec: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Iatt {}

impl Iatt {
    pub fn new() -> Iatt {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Iatt {
        static mut instance: ::protobuf::lazy::Lazy<Iatt> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Iatt,
        };
        unsafe {
            instance.get(Iatt::new)
        }
    }

    // required string ia_gfid = 1;

    pub fn clear_ia_gfid(&mut self) {
        self.ia_gfid.clear();
    }

    pub fn has_ia_gfid(&self) -> bool {
        self.ia_gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ia_gfid(&mut self, v: ::std::string::String) {
        self.ia_gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ia_gfid(&mut self) -> &mut ::std::string::String {
        if self.ia_gfid.is_none() {
            self.ia_gfid.set_default();
        }
        self.ia_gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_ia_gfid(&mut self) -> ::std::string::String {
        self.ia_gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ia_gfid(&self) -> &str {
        match self.ia_gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_ia_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.ia_gfid
    }

    fn mut_ia_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.ia_gfid
    }

    // required uint64 ia_ino = 2;

    pub fn clear_ia_ino(&mut self) {
        self.ia_ino = ::std::option::Option::None;
    }

    pub fn has_ia_ino(&self) -> bool {
        self.ia_ino.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ia_ino(&mut self, v: u64) {
        self.ia_ino = ::std::option::Option::Some(v);
    }

    pub fn get_ia_ino(&self) -> u64 {
        self.ia_ino.unwrap_or(0)
    }

    fn get_ia_ino_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.ia_ino
    }

    fn mut_ia_ino_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.ia_ino
    }

    // required uint64 ia_dev = 3;

    pub fn clear_ia_dev(&mut self) {
        self.ia_dev = ::std::option::Option::None;
    }

    pub fn has_ia_dev(&self) -> bool {
        self.ia_dev.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ia_dev(&mut self, v: u64) {
        self.ia_dev = ::std::option::Option::Some(v);
    }

    pub fn get_ia_dev(&self) -> u64 {
        self.ia_dev.unwrap_or(0)
    }

    fn get_ia_dev_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.ia_dev
    }

    fn mut_ia_dev_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.ia_dev
    }

    // required uint32 mode = 4;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: u32) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode(&self) -> u32 {
        self.mode.unwrap_or(0)
    }

    fn get_mode_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mode
    }

    fn mut_mode_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mode
    }

    // required uint32 ia_nlink = 5;

    pub fn clear_ia_nlink(&mut self) {
        self.ia_nlink = ::std::option::Option::None;
    }

    pub fn has_ia_nlink(&self) -> bool {
        self.ia_nlink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ia_nlink(&mut self, v: u32) {
        self.ia_nlink = ::std::option::Option::Some(v);
    }

    pub fn get_ia_nlink(&self) -> u32 {
        self.ia_nlink.unwrap_or(0)
    }

    fn get_ia_nlink_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ia_nlink
    }

    fn mut_ia_nlink_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ia_nlink
    }

    // required uint32 ia_uid = 6;

    pub fn clear_ia_uid(&mut self) {
        self.ia_uid = ::std::option::Option::None;
    }

    pub fn has_ia_uid(&self) -> bool {
        self.ia_uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ia_uid(&mut self, v: u32) {
        self.ia_uid = ::std::option::Option::Some(v);
    }

    pub fn get_ia_uid(&self) -> u32 {
        self.ia_uid.unwrap_or(0)
    }

    fn get_ia_uid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ia_uid
    }

    fn mut_ia_uid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ia_uid
    }

    // required uint32 ia_gid = 7;

    pub fn clear_ia_gid(&mut self) {
        self.ia_gid = ::std::option::Option::None;
    }

    pub fn has_ia_gid(&self) -> bool {
        self.ia_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ia_gid(&mut self, v: u32) {
        self.ia_gid = ::std::option::Option::Some(v);
    }

    pub fn get_ia_gid(&self) -> u32 {
        self.ia_gid.unwrap_or(0)
    }

    fn get_ia_gid_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ia_gid
    }

    fn mut_ia_gid_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ia_gid
    }

    // required uint64 ia_rdev = 8;

    pub fn clear_ia_rdev(&mut self) {
        self.ia_rdev = ::std::option::Option::None;
    }

    pub fn has_ia_rdev(&self) -> bool {
        self.ia_rdev.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ia_rdev(&mut self, v: u64) {
        self.ia_rdev = ::std::option::Option::Some(v);
    }

    pub fn get_ia_rdev(&self) -> u64 {
        self.ia_rdev.unwrap_or(0)
    }

    fn get_ia_rdev_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.ia_rdev
    }

    fn mut_ia_rdev_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.ia_rdev
    }

    // required uint64 ia_size = 9;

    pub fn clear_ia_size(&mut self) {
        self.ia_size = ::std::option::Option::None;
    }

    pub fn has_ia_size(&self) -> bool {
        self.ia_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ia_size(&mut self, v: u64) {
        self.ia_size = ::std::option::Option::Some(v);
    }

    pub fn get_ia_size(&self) -> u64 {
        self.ia_size.unwrap_or(0)
    }

    fn get_ia_size_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.ia_size
    }

    fn mut_ia_size_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.ia_size
    }

    // required uint32 ia_blksize = 10;

    pub fn clear_ia_blksize(&mut self) {
        self.ia_blksize = ::std::option::Option::None;
    }

    pub fn has_ia_blksize(&self) -> bool {
        self.ia_blksize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ia_blksize(&mut self, v: u32) {
        self.ia_blksize = ::std::option::Option::Some(v);
    }

    pub fn get_ia_blksize(&self) -> u32 {
        self.ia_blksize.unwrap_or(0)
    }

    fn get_ia_blksize_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ia_blksize
    }

    fn mut_ia_blksize_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ia_blksize
    }

    // required uint64 ia_blocks = 11;

    pub fn clear_ia_blocks(&mut self) {
        self.ia_blocks = ::std::option::Option::None;
    }

    pub fn has_ia_blocks(&self) -> bool {
        self.ia_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ia_blocks(&mut self, v: u64) {
        self.ia_blocks = ::std::option::Option::Some(v);
    }

    pub fn get_ia_blocks(&self) -> u64 {
        self.ia_blocks.unwrap_or(0)
    }

    fn get_ia_blocks_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.ia_blocks
    }

    fn mut_ia_blocks_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.ia_blocks
    }

    // required uint32 ia_atime = 12;

    pub fn clear_ia_atime(&mut self) {
        self.ia_atime = ::std::option::Option::None;
    }

    pub fn has_ia_atime(&self) -> bool {
        self.ia_atime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ia_atime(&mut self, v: u32) {
        self.ia_atime = ::std::option::Option::Some(v);
    }

    pub fn get_ia_atime(&self) -> u32 {
        self.ia_atime.unwrap_or(0)
    }

    fn get_ia_atime_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ia_atime
    }

    fn mut_ia_atime_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ia_atime
    }

    // required uint32 ia_atime_nsec = 13;

    pub fn clear_ia_atime_nsec(&mut self) {
        self.ia_atime_nsec = ::std::option::Option::None;
    }

    pub fn has_ia_atime_nsec(&self) -> bool {
        self.ia_atime_nsec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ia_atime_nsec(&mut self, v: u32) {
        self.ia_atime_nsec = ::std::option::Option::Some(v);
    }

    pub fn get_ia_atime_nsec(&self) -> u32 {
        self.ia_atime_nsec.unwrap_or(0)
    }

    fn get_ia_atime_nsec_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ia_atime_nsec
    }

    fn mut_ia_atime_nsec_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ia_atime_nsec
    }

    // required uint32 ia_mtime = 14;

    pub fn clear_ia_mtime(&mut self) {
        self.ia_mtime = ::std::option::Option::None;
    }

    pub fn has_ia_mtime(&self) -> bool {
        self.ia_mtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ia_mtime(&mut self, v: u32) {
        self.ia_mtime = ::std::option::Option::Some(v);
    }

    pub fn get_ia_mtime(&self) -> u32 {
        self.ia_mtime.unwrap_or(0)
    }

    fn get_ia_mtime_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ia_mtime
    }

    fn mut_ia_mtime_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ia_mtime
    }

    // required uint32 ia_mtime_nsec = 15;

    pub fn clear_ia_mtime_nsec(&mut self) {
        self.ia_mtime_nsec = ::std::option::Option::None;
    }

    pub fn has_ia_mtime_nsec(&self) -> bool {
        self.ia_mtime_nsec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ia_mtime_nsec(&mut self, v: u32) {
        self.ia_mtime_nsec = ::std::option::Option::Some(v);
    }

    pub fn get_ia_mtime_nsec(&self) -> u32 {
        self.ia_mtime_nsec.unwrap_or(0)
    }

    fn get_ia_mtime_nsec_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ia_mtime_nsec
    }

    fn mut_ia_mtime_nsec_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ia_mtime_nsec
    }

    // required uint32 ia_ctime = 16;

    pub fn clear_ia_ctime(&mut self) {
        self.ia_ctime = ::std::option::Option::None;
    }

    pub fn has_ia_ctime(&self) -> bool {
        self.ia_ctime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ia_ctime(&mut self, v: u32) {
        self.ia_ctime = ::std::option::Option::Some(v);
    }

    pub fn get_ia_ctime(&self) -> u32 {
        self.ia_ctime.unwrap_or(0)
    }

    fn get_ia_ctime_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ia_ctime
    }

    fn mut_ia_ctime_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ia_ctime
    }

    // required uint32 ia_ctime_nsec = 17;

    pub fn clear_ia_ctime_nsec(&mut self) {
        self.ia_ctime_nsec = ::std::option::Option::None;
    }

    pub fn has_ia_ctime_nsec(&self) -> bool {
        self.ia_ctime_nsec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ia_ctime_nsec(&mut self, v: u32) {
        self.ia_ctime_nsec = ::std::option::Option::Some(v);
    }

    pub fn get_ia_ctime_nsec(&self) -> u32 {
        self.ia_ctime_nsec.unwrap_or(0)
    }

    fn get_ia_ctime_nsec_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.ia_ctime_nsec
    }

    fn mut_ia_ctime_nsec_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.ia_ctime_nsec
    }
}

impl ::protobuf::Message for Iatt {
    fn is_initialized(&self) -> bool {
        if self.ia_gfid.is_none() {
            return false;
        }
        if self.ia_ino.is_none() {
            return false;
        }
        if self.ia_dev.is_none() {
            return false;
        }
        if self.mode.is_none() {
            return false;
        }
        if self.ia_nlink.is_none() {
            return false;
        }
        if self.ia_uid.is_none() {
            return false;
        }
        if self.ia_gid.is_none() {
            return false;
        }
        if self.ia_rdev.is_none() {
            return false;
        }
        if self.ia_size.is_none() {
            return false;
        }
        if self.ia_blksize.is_none() {
            return false;
        }
        if self.ia_blocks.is_none() {
            return false;
        }
        if self.ia_atime.is_none() {
            return false;
        }
        if self.ia_atime_nsec.is_none() {
            return false;
        }
        if self.ia_mtime.is_none() {
            return false;
        }
        if self.ia_mtime_nsec.is_none() {
            return false;
        }
        if self.ia_ctime.is_none() {
            return false;
        }
        if self.ia_ctime_nsec.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ia_gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ia_ino = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ia_dev = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ia_nlink = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ia_uid = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ia_gid = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ia_rdev = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ia_size = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ia_blksize = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ia_blocks = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ia_atime = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ia_atime_nsec = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ia_mtime = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ia_mtime_nsec = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ia_ctime = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ia_ctime_nsec = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ia_gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.ia_ino {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ia_dev {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ia_nlink {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ia_uid {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ia_gid {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ia_rdev {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ia_size {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ia_blksize {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ia_blocks {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ia_atime {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ia_atime_nsec {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ia_mtime {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ia_mtime_nsec {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ia_ctime {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ia_ctime_nsec {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ia_gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.ia_ino {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.ia_dev {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.mode {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.ia_nlink {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.ia_uid {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ia_gid {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.ia_rdev {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.ia_size {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.ia_blksize {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.ia_blocks {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.ia_atime {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.ia_atime_nsec {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.ia_mtime {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.ia_mtime_nsec {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.ia_ctime {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.ia_ctime_nsec {
            os.write_uint32(17, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Iatt {
    fn new() -> Iatt {
        Iatt::new()
    }

    fn descriptor_static(_: ::std::option::Option<Iatt>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ia_gfid",
                    Iatt::get_ia_gfid_for_reflect,
                    Iatt::mut_ia_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ia_ino",
                    Iatt::get_ia_ino_for_reflect,
                    Iatt::mut_ia_ino_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ia_dev",
                    Iatt::get_ia_dev_for_reflect,
                    Iatt::mut_ia_dev_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mode",
                    Iatt::get_mode_for_reflect,
                    Iatt::mut_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ia_nlink",
                    Iatt::get_ia_nlink_for_reflect,
                    Iatt::mut_ia_nlink_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ia_uid",
                    Iatt::get_ia_uid_for_reflect,
                    Iatt::mut_ia_uid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ia_gid",
                    Iatt::get_ia_gid_for_reflect,
                    Iatt::mut_ia_gid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ia_rdev",
                    Iatt::get_ia_rdev_for_reflect,
                    Iatt::mut_ia_rdev_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ia_size",
                    Iatt::get_ia_size_for_reflect,
                    Iatt::mut_ia_size_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ia_blksize",
                    Iatt::get_ia_blksize_for_reflect,
                    Iatt::mut_ia_blksize_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ia_blocks",
                    Iatt::get_ia_blocks_for_reflect,
                    Iatt::mut_ia_blocks_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ia_atime",
                    Iatt::get_ia_atime_for_reflect,
                    Iatt::mut_ia_atime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ia_atime_nsec",
                    Iatt::get_ia_atime_nsec_for_reflect,
                    Iatt::mut_ia_atime_nsec_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ia_mtime",
                    Iatt::get_ia_mtime_for_reflect,
                    Iatt::mut_ia_mtime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ia_mtime_nsec",
                    Iatt::get_ia_mtime_nsec_for_reflect,
                    Iatt::mut_ia_mtime_nsec_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ia_ctime",
                    Iatt::get_ia_ctime_for_reflect,
                    Iatt::mut_ia_ctime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ia_ctime_nsec",
                    Iatt::get_ia_ctime_nsec_for_reflect,
                    Iatt::mut_ia_ctime_nsec_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Iatt>(
                    "Iatt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Iatt {
    fn clear(&mut self) {
        self.clear_ia_gfid();
        self.clear_ia_ino();
        self.clear_ia_dev();
        self.clear_mode();
        self.clear_ia_nlink();
        self.clear_ia_uid();
        self.clear_ia_gid();
        self.clear_ia_rdev();
        self.clear_ia_size();
        self.clear_ia_blksize();
        self.clear_ia_blocks();
        self.clear_ia_atime();
        self.clear_ia_atime_nsec();
        self.clear_ia_mtime();
        self.clear_ia_mtime_nsec();
        self.clear_ia_ctime();
        self.clear_ia_ctime_nsec();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Iatt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Iatt {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct cbk_cache_invalidationRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    event_type: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    expire_time_attr: ::std::option::Option<u32>,
    stat: ::protobuf::SingularPtrField<Iatt>,
    parent_stat: ::protobuf::SingularPtrField<Iatt>,
    oldparent_stat: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for cbk_cache_invalidationRequest {}

impl cbk_cache_invalidationRequest {
    pub fn new() -> cbk_cache_invalidationRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static cbk_cache_invalidationRequest {
        static mut instance: ::protobuf::lazy::Lazy<cbk_cache_invalidationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const cbk_cache_invalidationRequest,
        };
        unsafe {
            instance.get(cbk_cache_invalidationRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint32 event_type = 2;

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    pub fn get_event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }

    fn get_event_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.event_type
    }

    fn mut_event_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.event_type
    }

    // required uint32 flags = 3;

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    fn get_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.flags
    }

    fn mut_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.flags
    }

    // required uint32 expire_time_attr = 4;

    pub fn clear_expire_time_attr(&mut self) {
        self.expire_time_attr = ::std::option::Option::None;
    }

    pub fn has_expire_time_attr(&self) -> bool {
        self.expire_time_attr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expire_time_attr(&mut self, v: u32) {
        self.expire_time_attr = ::std::option::Option::Some(v);
    }

    pub fn get_expire_time_attr(&self) -> u32 {
        self.expire_time_attr.unwrap_or(0)
    }

    fn get_expire_time_attr_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.expire_time_attr
    }

    fn mut_expire_time_attr_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.expire_time_attr
    }

    // required .rusix.Iatt stat = 5;

    pub fn clear_stat(&mut self) {
        self.stat.clear();
    }

    pub fn has_stat(&self) -> bool {
        self.stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: Iatt) {
        self.stat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat(&mut self) -> &mut Iatt {
        if self.stat.is_none() {
            self.stat.set_default();
        }
        self.stat.as_mut().unwrap()
    }

    // Take field
    pub fn take_stat(&mut self) -> Iatt {
        self.stat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_stat(&self) -> &Iatt {
        self.stat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_stat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.stat
    }

    fn mut_stat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.stat
    }

    // required .rusix.Iatt parent_stat = 6;

    pub fn clear_parent_stat(&mut self) {
        self.parent_stat.clear();
    }

    pub fn has_parent_stat(&self) -> bool {
        self.parent_stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_stat(&mut self, v: Iatt) {
        self.parent_stat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_stat(&mut self) -> &mut Iatt {
        if self.parent_stat.is_none() {
            self.parent_stat.set_default();
        }
        self.parent_stat.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent_stat(&mut self) -> Iatt {
        self.parent_stat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_parent_stat(&self) -> &Iatt {
        self.parent_stat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_parent_stat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.parent_stat
    }

    fn mut_parent_stat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.parent_stat
    }

    // required .rusix.Iatt oldparent_stat = 7;

    pub fn clear_oldparent_stat(&mut self) {
        self.oldparent_stat.clear();
    }

    pub fn has_oldparent_stat(&self) -> bool {
        self.oldparent_stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oldparent_stat(&mut self, v: Iatt) {
        self.oldparent_stat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oldparent_stat(&mut self) -> &mut Iatt {
        if self.oldparent_stat.is_none() {
            self.oldparent_stat.set_default();
        }
        self.oldparent_stat.as_mut().unwrap()
    }

    // Take field
    pub fn take_oldparent_stat(&mut self) -> Iatt {
        self.oldparent_stat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_oldparent_stat(&self) -> &Iatt {
        self.oldparent_stat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_oldparent_stat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.oldparent_stat
    }

    fn mut_oldparent_stat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.oldparent_stat
    }

    // optional bytes extra_data = 8;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for cbk_cache_invalidationRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.event_type.is_none() {
            return false;
        }
        if self.flags.is_none() {
            return false;
        }
        if self.expire_time_attr.is_none() {
            return false;
        }
        if self.stat.is_none() {
            return false;
        }
        if self.parent_stat.is_none() {
            return false;
        }
        if self.oldparent_stat.is_none() {
            return false;
        }
        for v in &self.stat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parent_stat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.oldparent_stat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expire_time_attr = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stat)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.parent_stat)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.oldparent_stat)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expire_time_attr {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.parent_stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.oldparent_stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.expire_time_attr {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.stat.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.parent_stat.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.oldparent_stat.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for cbk_cache_invalidationRequest {
    fn new() -> cbk_cache_invalidationRequest {
        cbk_cache_invalidationRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<cbk_cache_invalidationRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    cbk_cache_invalidationRequest::get_gfid_for_reflect,
                    cbk_cache_invalidationRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "event_type",
                    cbk_cache_invalidationRequest::get_event_type_for_reflect,
                    cbk_cache_invalidationRequest::mut_event_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    cbk_cache_invalidationRequest::get_flags_for_reflect,
                    cbk_cache_invalidationRequest::mut_flags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "expire_time_attr",
                    cbk_cache_invalidationRequest::get_expire_time_attr_for_reflect,
                    cbk_cache_invalidationRequest::mut_expire_time_attr_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "stat",
                    cbk_cache_invalidationRequest::get_stat_for_reflect,
                    cbk_cache_invalidationRequest::mut_stat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "parent_stat",
                    cbk_cache_invalidationRequest::get_parent_stat_for_reflect,
                    cbk_cache_invalidationRequest::mut_parent_stat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "oldparent_stat",
                    cbk_cache_invalidationRequest::get_oldparent_stat_for_reflect,
                    cbk_cache_invalidationRequest::mut_oldparent_stat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    cbk_cache_invalidationRequest::get_extra_data_for_reflect,
                    cbk_cache_invalidationRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<cbk_cache_invalidationRequest>(
                    "cbk_cache_invalidationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for cbk_cache_invalidationRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_event_type();
        self.clear_flags();
        self.clear_expire_time_attr();
        self.clear_stat();
        self.clear_parent_stat();
        self.clear_oldparent_stat();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for cbk_cache_invalidationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for cbk_cache_invalidationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for StatRequest {}

impl StatRequest {
    pub fn new() -> StatRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static StatRequest {
        static mut instance: ::protobuf::lazy::Lazy<StatRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StatRequest,
        };
        unsafe {
            instance.get(StatRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // optional bytes extra_data = 2;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for StatRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for StatRequest {
    fn new() -> StatRequest {
        StatRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<StatRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    StatRequest::get_gfid_for_reflect,
                    StatRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    StatRequest::get_extra_data_for_reflect,
                    StatRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StatRequest>(
                    "StatRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for StatRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct statResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    stat: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for statResponse {}

impl statResponse {
    pub fn new() -> statResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static statResponse {
        static mut instance: ::protobuf::lazy::Lazy<statResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const statResponse,
        };
        unsafe {
            instance.get(statResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt stat = 2;

    pub fn clear_stat(&mut self) {
        self.stat.clear();
    }

    pub fn has_stat(&self) -> bool {
        self.stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: Iatt) {
        self.stat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat(&mut self) -> &mut Iatt {
        if self.stat.is_none() {
            self.stat.set_default();
        }
        self.stat.as_mut().unwrap()
    }

    // Take field
    pub fn take_stat(&mut self) -> Iatt {
        self.stat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_stat(&self) -> &Iatt {
        self.stat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_stat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.stat
    }

    fn mut_stat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.stat
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for statResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stat)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stat.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for statResponse {
    fn new() -> statResponse {
        statResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<statResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    statResponse::get_result_for_reflect,
                    statResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "stat",
                    statResponse::get_stat_for_reflect,
                    statResponse::mut_stat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    statResponse::get_extra_data_for_reflect,
                    statResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<statResponse>(
                    "statResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for statResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_stat();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for statResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for statResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct readlinkRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    size: ::std::option::Option<u32>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for readlinkRequest {}

impl readlinkRequest {
    pub fn new() -> readlinkRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static readlinkRequest {
        static mut instance: ::protobuf::lazy::Lazy<readlinkRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const readlinkRequest,
        };
        unsafe {
            instance.get(readlinkRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint32 size = 2;

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    pub fn get_size(&self) -> u32 {
        self.size.unwrap_or(0)
    }

    fn get_size_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.size
    }

    fn mut_size_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.size
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for readlinkRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for readlinkRequest {
    fn new() -> readlinkRequest {
        readlinkRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<readlinkRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    readlinkRequest::get_gfid_for_reflect,
                    readlinkRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "size",
                    readlinkRequest::get_size_for_reflect,
                    readlinkRequest::mut_size_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    readlinkRequest::get_extra_data_for_reflect,
                    readlinkRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<readlinkRequest>(
                    "readlinkRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for readlinkRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_size();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for readlinkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for readlinkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadlinkResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    buf: ::protobuf::SingularPtrField<Iatt>,
    path: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ReadlinkResponse {}

impl ReadlinkResponse {
    pub fn new() -> ReadlinkResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ReadlinkResponse {
        static mut instance: ::protobuf::lazy::Lazy<ReadlinkResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadlinkResponse,
        };
        unsafe {
            instance.get(ReadlinkResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt buf = 2;

    pub fn clear_buf(&mut self) {
        self.buf.clear();
    }

    pub fn has_buf(&self) -> bool {
        self.buf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buf(&mut self, v: Iatt) {
        self.buf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buf(&mut self) -> &mut Iatt {
        if self.buf.is_none() {
            self.buf.set_default();
        }
        self.buf.as_mut().unwrap()
    }

    // Take field
    pub fn take_buf(&mut self) -> Iatt {
        self.buf.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_buf(&self) -> &Iatt {
        self.buf.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_buf_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.buf
    }

    fn mut_buf_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.buf
    }

    // optional string path = 3;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for ReadlinkResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buf {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.buf)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.buf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.buf.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ReadlinkResponse {
    fn new() -> ReadlinkResponse {
        ReadlinkResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<ReadlinkResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    ReadlinkResponse::get_result_for_reflect,
                    ReadlinkResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "buf",
                    ReadlinkResponse::get_buf_for_reflect,
                    ReadlinkResponse::mut_buf_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    ReadlinkResponse::get_path_for_reflect,
                    ReadlinkResponse::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    ReadlinkResponse::get_extra_data_for_reflect,
                    ReadlinkResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReadlinkResponse>(
                    "ReadlinkResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ReadlinkResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_buf();
        self.clear_path();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadlinkResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadlinkResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MknodRequest {
    // message fields
    pargfid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    dev: ::std::option::Option<u64>,
    mode: ::std::option::Option<u32>,
    umask: ::std::option::Option<u32>,
    bname: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MknodRequest {}

impl MknodRequest {
    pub fn new() -> MknodRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MknodRequest {
        static mut instance: ::protobuf::lazy::Lazy<MknodRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MknodRequest,
        };
        unsafe {
            instance.get(MknodRequest::new)
        }
    }

    // required bytes pargfid = 1;

    pub fn clear_pargfid(&mut self) {
        self.pargfid.clear();
    }

    pub fn has_pargfid(&self) -> bool {
        self.pargfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pargfid(&mut self, v: ::std::vec::Vec<u8>) {
        self.pargfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pargfid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pargfid.is_none() {
            self.pargfid.set_default();
        }
        self.pargfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_pargfid(&mut self) -> ::std::vec::Vec<u8> {
        self.pargfid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_pargfid(&self) -> &[u8] {
        match self.pargfid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_pargfid_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.pargfid
    }

    fn mut_pargfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.pargfid
    }

    // required uint64 dev = 2;

    pub fn clear_dev(&mut self) {
        self.dev = ::std::option::Option::None;
    }

    pub fn has_dev(&self) -> bool {
        self.dev.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dev(&mut self, v: u64) {
        self.dev = ::std::option::Option::Some(v);
    }

    pub fn get_dev(&self) -> u64 {
        self.dev.unwrap_or(0)
    }

    fn get_dev_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.dev
    }

    fn mut_dev_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.dev
    }

    // required uint32 mode = 3;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: u32) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode(&self) -> u32 {
        self.mode.unwrap_or(0)
    }

    fn get_mode_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mode
    }

    fn mut_mode_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mode
    }

    // required uint32 umask = 4;

    pub fn clear_umask(&mut self) {
        self.umask = ::std::option::Option::None;
    }

    pub fn has_umask(&self) -> bool {
        self.umask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_umask(&mut self, v: u32) {
        self.umask = ::std::option::Option::Some(v);
    }

    pub fn get_umask(&self) -> u32 {
        self.umask.unwrap_or(0)
    }

    fn get_umask_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.umask
    }

    fn mut_umask_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.umask
    }

    // required string bname = 5;

    pub fn clear_bname(&mut self) {
        self.bname.clear();
    }

    pub fn has_bname(&self) -> bool {
        self.bname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bname(&mut self, v: ::std::string::String) {
        self.bname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bname(&mut self) -> &mut ::std::string::String {
        if self.bname.is_none() {
            self.bname.set_default();
        }
        self.bname.as_mut().unwrap()
    }

    // Take field
    pub fn take_bname(&mut self) -> ::std::string::String {
        self.bname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_bname(&self) -> &str {
        match self.bname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_bname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.bname
    }

    fn mut_bname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.bname
    }

    // optional bytes extra_data = 6;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for MknodRequest {
    fn is_initialized(&self) -> bool {
        if self.pargfid.is_none() {
            return false;
        }
        if self.dev.is_none() {
            return false;
        }
        if self.mode.is_none() {
            return false;
        }
        if self.umask.is_none() {
            return false;
        }
        if self.bname.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pargfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dev = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.umask = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bname)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pargfid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.dev {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.umask {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.bname.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pargfid.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.dev {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.mode {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.umask {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.bname.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MknodRequest {
    fn new() -> MknodRequest {
        MknodRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<MknodRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pargfid",
                    MknodRequest::get_pargfid_for_reflect,
                    MknodRequest::mut_pargfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "dev",
                    MknodRequest::get_dev_for_reflect,
                    MknodRequest::mut_dev_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mode",
                    MknodRequest::get_mode_for_reflect,
                    MknodRequest::mut_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "umask",
                    MknodRequest::get_umask_for_reflect,
                    MknodRequest::mut_umask_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bname",
                    MknodRequest::get_bname_for_reflect,
                    MknodRequest::mut_bname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    MknodRequest::get_extra_data_for_reflect,
                    MknodRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MknodRequest>(
                    "MknodRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MknodRequest {
    fn clear(&mut self) {
        self.clear_pargfid();
        self.clear_dev();
        self.clear_mode();
        self.clear_umask();
        self.clear_bname();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MknodRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MknodRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MknodResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    stat: ::protobuf::SingularPtrField<Iatt>,
    preparent: ::protobuf::SingularPtrField<Iatt>,
    postparent: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MknodResponse {}

impl MknodResponse {
    pub fn new() -> MknodResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MknodResponse {
        static mut instance: ::protobuf::lazy::Lazy<MknodResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MknodResponse,
        };
        unsafe {
            instance.get(MknodResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt stat = 2;

    pub fn clear_stat(&mut self) {
        self.stat.clear();
    }

    pub fn has_stat(&self) -> bool {
        self.stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: Iatt) {
        self.stat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat(&mut self) -> &mut Iatt {
        if self.stat.is_none() {
            self.stat.set_default();
        }
        self.stat.as_mut().unwrap()
    }

    // Take field
    pub fn take_stat(&mut self) -> Iatt {
        self.stat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_stat(&self) -> &Iatt {
        self.stat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_stat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.stat
    }

    fn mut_stat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.stat
    }

    // optional .rusix.Iatt preparent = 3;

    pub fn clear_preparent(&mut self) {
        self.preparent.clear();
    }

    pub fn has_preparent(&self) -> bool {
        self.preparent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preparent(&mut self, v: Iatt) {
        self.preparent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preparent(&mut self) -> &mut Iatt {
        if self.preparent.is_none() {
            self.preparent.set_default();
        }
        self.preparent.as_mut().unwrap()
    }

    // Take field
    pub fn take_preparent(&mut self) -> Iatt {
        self.preparent.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_preparent(&self) -> &Iatt {
        self.preparent.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_preparent_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.preparent
    }

    fn mut_preparent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.preparent
    }

    // optional .rusix.Iatt postparent = 4;

    pub fn clear_postparent(&mut self) {
        self.postparent.clear();
    }

    pub fn has_postparent(&self) -> bool {
        self.postparent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postparent(&mut self, v: Iatt) {
        self.postparent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postparent(&mut self) -> &mut Iatt {
        if self.postparent.is_none() {
            self.postparent.set_default();
        }
        self.postparent.as_mut().unwrap()
    }

    // Take field
    pub fn take_postparent(&mut self) -> Iatt {
        self.postparent.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_postparent(&self) -> &Iatt {
        self.postparent.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_postparent_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.postparent
    }

    fn mut_postparent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.postparent
    }

    // optional bytes extra_data = 5;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for MknodResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preparent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.postparent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stat)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preparent)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.postparent)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.preparent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.postparent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stat.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.preparent.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.postparent.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MknodResponse {
    fn new() -> MknodResponse {
        MknodResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<MknodResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    MknodResponse::get_result_for_reflect,
                    MknodResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "stat",
                    MknodResponse::get_stat_for_reflect,
                    MknodResponse::mut_stat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "preparent",
                    MknodResponse::get_preparent_for_reflect,
                    MknodResponse::mut_preparent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "postparent",
                    MknodResponse::get_postparent_for_reflect,
                    MknodResponse::mut_postparent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    MknodResponse::get_extra_data_for_reflect,
                    MknodResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MknodResponse>(
                    "MknodResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MknodResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_stat();
        self.clear_preparent();
        self.clear_postparent();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MknodResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MknodResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MkdirRequest {
    // message fields
    pargfid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    mode: ::std::option::Option<u32>,
    umask: ::std::option::Option<u32>,
    bname: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MkdirRequest {}

impl MkdirRequest {
    pub fn new() -> MkdirRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MkdirRequest {
        static mut instance: ::protobuf::lazy::Lazy<MkdirRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MkdirRequest,
        };
        unsafe {
            instance.get(MkdirRequest::new)
        }
    }

    // required bytes pargfid = 1;

    pub fn clear_pargfid(&mut self) {
        self.pargfid.clear();
    }

    pub fn has_pargfid(&self) -> bool {
        self.pargfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pargfid(&mut self, v: ::std::vec::Vec<u8>) {
        self.pargfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pargfid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pargfid.is_none() {
            self.pargfid.set_default();
        }
        self.pargfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_pargfid(&mut self) -> ::std::vec::Vec<u8> {
        self.pargfid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_pargfid(&self) -> &[u8] {
        match self.pargfid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_pargfid_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.pargfid
    }

    fn mut_pargfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.pargfid
    }

    // required uint32 mode = 2;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: u32) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode(&self) -> u32 {
        self.mode.unwrap_or(0)
    }

    fn get_mode_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mode
    }

    fn mut_mode_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mode
    }

    // required uint32 umask = 3;

    pub fn clear_umask(&mut self) {
        self.umask = ::std::option::Option::None;
    }

    pub fn has_umask(&self) -> bool {
        self.umask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_umask(&mut self, v: u32) {
        self.umask = ::std::option::Option::Some(v);
    }

    pub fn get_umask(&self) -> u32 {
        self.umask.unwrap_or(0)
    }

    fn get_umask_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.umask
    }

    fn mut_umask_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.umask
    }

    // required string bname = 4;

    pub fn clear_bname(&mut self) {
        self.bname.clear();
    }

    pub fn has_bname(&self) -> bool {
        self.bname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bname(&mut self, v: ::std::string::String) {
        self.bname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bname(&mut self) -> &mut ::std::string::String {
        if self.bname.is_none() {
            self.bname.set_default();
        }
        self.bname.as_mut().unwrap()
    }

    // Take field
    pub fn take_bname(&mut self) -> ::std::string::String {
        self.bname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_bname(&self) -> &str {
        match self.bname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_bname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.bname
    }

    fn mut_bname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.bname
    }

    // optional bytes extra_data = 5;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for MkdirRequest {
    fn is_initialized(&self) -> bool {
        if self.pargfid.is_none() {
            return false;
        }
        if self.mode.is_none() {
            return false;
        }
        if self.umask.is_none() {
            return false;
        }
        if self.bname.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pargfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.umask = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bname)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pargfid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.umask {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.bname.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pargfid.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.mode {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.umask {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.bname.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MkdirRequest {
    fn new() -> MkdirRequest {
        MkdirRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<MkdirRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pargfid",
                    MkdirRequest::get_pargfid_for_reflect,
                    MkdirRequest::mut_pargfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mode",
                    MkdirRequest::get_mode_for_reflect,
                    MkdirRequest::mut_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "umask",
                    MkdirRequest::get_umask_for_reflect,
                    MkdirRequest::mut_umask_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bname",
                    MkdirRequest::get_bname_for_reflect,
                    MkdirRequest::mut_bname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    MkdirRequest::get_extra_data_for_reflect,
                    MkdirRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MkdirRequest>(
                    "MkdirRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MkdirRequest {
    fn clear(&mut self) {
        self.clear_pargfid();
        self.clear_mode();
        self.clear_umask();
        self.clear_bname();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MkdirRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MkdirRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MkdirResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    stat: ::protobuf::SingularPtrField<Iatt>,
    preparent: ::protobuf::SingularPtrField<Iatt>,
    postparent: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MkdirResponse {}

impl MkdirResponse {
    pub fn new() -> MkdirResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MkdirResponse {
        static mut instance: ::protobuf::lazy::Lazy<MkdirResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MkdirResponse,
        };
        unsafe {
            instance.get(MkdirResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt stat = 2;

    pub fn clear_stat(&mut self) {
        self.stat.clear();
    }

    pub fn has_stat(&self) -> bool {
        self.stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: Iatt) {
        self.stat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat(&mut self) -> &mut Iatt {
        if self.stat.is_none() {
            self.stat.set_default();
        }
        self.stat.as_mut().unwrap()
    }

    // Take field
    pub fn take_stat(&mut self) -> Iatt {
        self.stat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_stat(&self) -> &Iatt {
        self.stat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_stat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.stat
    }

    fn mut_stat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.stat
    }

    // optional .rusix.Iatt preparent = 3;

    pub fn clear_preparent(&mut self) {
        self.preparent.clear();
    }

    pub fn has_preparent(&self) -> bool {
        self.preparent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preparent(&mut self, v: Iatt) {
        self.preparent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preparent(&mut self) -> &mut Iatt {
        if self.preparent.is_none() {
            self.preparent.set_default();
        }
        self.preparent.as_mut().unwrap()
    }

    // Take field
    pub fn take_preparent(&mut self) -> Iatt {
        self.preparent.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_preparent(&self) -> &Iatt {
        self.preparent.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_preparent_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.preparent
    }

    fn mut_preparent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.preparent
    }

    // optional .rusix.Iatt postparent = 4;

    pub fn clear_postparent(&mut self) {
        self.postparent.clear();
    }

    pub fn has_postparent(&self) -> bool {
        self.postparent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postparent(&mut self, v: Iatt) {
        self.postparent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postparent(&mut self) -> &mut Iatt {
        if self.postparent.is_none() {
            self.postparent.set_default();
        }
        self.postparent.as_mut().unwrap()
    }

    // Take field
    pub fn take_postparent(&mut self) -> Iatt {
        self.postparent.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_postparent(&self) -> &Iatt {
        self.postparent.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_postparent_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.postparent
    }

    fn mut_postparent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.postparent
    }

    // optional bytes extra_data = 5;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for MkdirResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preparent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.postparent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stat)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preparent)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.postparent)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.preparent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.postparent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stat.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.preparent.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.postparent.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MkdirResponse {
    fn new() -> MkdirResponse {
        MkdirResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<MkdirResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    MkdirResponse::get_result_for_reflect,
                    MkdirResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "stat",
                    MkdirResponse::get_stat_for_reflect,
                    MkdirResponse::mut_stat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "preparent",
                    MkdirResponse::get_preparent_for_reflect,
                    MkdirResponse::mut_preparent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "postparent",
                    MkdirResponse::get_postparent_for_reflect,
                    MkdirResponse::mut_postparent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    MkdirResponse::get_extra_data_for_reflect,
                    MkdirResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MkdirResponse>(
                    "MkdirResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MkdirResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_stat();
        self.clear_preparent();
        self.clear_postparent();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MkdirResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MkdirResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnlinkRequest {
    // message fields
    pargfid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    bname: ::protobuf::SingularField<::std::string::String>,
    xflags: ::std::option::Option<u32>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UnlinkRequest {}

impl UnlinkRequest {
    pub fn new() -> UnlinkRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UnlinkRequest {
        static mut instance: ::protobuf::lazy::Lazy<UnlinkRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnlinkRequest,
        };
        unsafe {
            instance.get(UnlinkRequest::new)
        }
    }

    // required bytes pargfid = 1;

    pub fn clear_pargfid(&mut self) {
        self.pargfid.clear();
    }

    pub fn has_pargfid(&self) -> bool {
        self.pargfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pargfid(&mut self, v: ::std::vec::Vec<u8>) {
        self.pargfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pargfid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pargfid.is_none() {
            self.pargfid.set_default();
        }
        self.pargfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_pargfid(&mut self) -> ::std::vec::Vec<u8> {
        self.pargfid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_pargfid(&self) -> &[u8] {
        match self.pargfid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_pargfid_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.pargfid
    }

    fn mut_pargfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.pargfid
    }

    // required string bname = 2;

    pub fn clear_bname(&mut self) {
        self.bname.clear();
    }

    pub fn has_bname(&self) -> bool {
        self.bname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bname(&mut self, v: ::std::string::String) {
        self.bname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bname(&mut self) -> &mut ::std::string::String {
        if self.bname.is_none() {
            self.bname.set_default();
        }
        self.bname.as_mut().unwrap()
    }

    // Take field
    pub fn take_bname(&mut self) -> ::std::string::String {
        self.bname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_bname(&self) -> &str {
        match self.bname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_bname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.bname
    }

    fn mut_bname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.bname
    }

    // required uint32 xflags = 3;

    pub fn clear_xflags(&mut self) {
        self.xflags = ::std::option::Option::None;
    }

    pub fn has_xflags(&self) -> bool {
        self.xflags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xflags(&mut self, v: u32) {
        self.xflags = ::std::option::Option::Some(v);
    }

    pub fn get_xflags(&self) -> u32 {
        self.xflags.unwrap_or(0)
    }

    fn get_xflags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.xflags
    }

    fn mut_xflags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.xflags
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for UnlinkRequest {
    fn is_initialized(&self) -> bool {
        if self.pargfid.is_none() {
            return false;
        }
        if self.bname.is_none() {
            return false;
        }
        if self.xflags.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pargfid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bname)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.xflags = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pargfid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.bname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.xflags {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pargfid.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.bname.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.xflags {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UnlinkRequest {
    fn new() -> UnlinkRequest {
        UnlinkRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<UnlinkRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pargfid",
                    UnlinkRequest::get_pargfid_for_reflect,
                    UnlinkRequest::mut_pargfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bname",
                    UnlinkRequest::get_bname_for_reflect,
                    UnlinkRequest::mut_bname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "xflags",
                    UnlinkRequest::get_xflags_for_reflect,
                    UnlinkRequest::mut_xflags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    UnlinkRequest::get_extra_data_for_reflect,
                    UnlinkRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UnlinkRequest>(
                    "UnlinkRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UnlinkRequest {
    fn clear(&mut self) {
        self.clear_pargfid();
        self.clear_bname();
        self.clear_xflags();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnlinkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnlinkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnlinkResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    preparent: ::protobuf::SingularPtrField<Iatt>,
    postparent: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UnlinkResponse {}

impl UnlinkResponse {
    pub fn new() -> UnlinkResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UnlinkResponse {
        static mut instance: ::protobuf::lazy::Lazy<UnlinkResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnlinkResponse,
        };
        unsafe {
            instance.get(UnlinkResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt preparent = 2;

    pub fn clear_preparent(&mut self) {
        self.preparent.clear();
    }

    pub fn has_preparent(&self) -> bool {
        self.preparent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preparent(&mut self, v: Iatt) {
        self.preparent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preparent(&mut self) -> &mut Iatt {
        if self.preparent.is_none() {
            self.preparent.set_default();
        }
        self.preparent.as_mut().unwrap()
    }

    // Take field
    pub fn take_preparent(&mut self) -> Iatt {
        self.preparent.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_preparent(&self) -> &Iatt {
        self.preparent.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_preparent_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.preparent
    }

    fn mut_preparent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.preparent
    }

    // optional .rusix.Iatt postparent = 3;

    pub fn clear_postparent(&mut self) {
        self.postparent.clear();
    }

    pub fn has_postparent(&self) -> bool {
        self.postparent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postparent(&mut self, v: Iatt) {
        self.postparent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postparent(&mut self) -> &mut Iatt {
        if self.postparent.is_none() {
            self.postparent.set_default();
        }
        self.postparent.as_mut().unwrap()
    }

    // Take field
    pub fn take_postparent(&mut self) -> Iatt {
        self.postparent.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_postparent(&self) -> &Iatt {
        self.postparent.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_postparent_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.postparent
    }

    fn mut_postparent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.postparent
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for UnlinkResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preparent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.postparent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preparent)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.postparent)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.preparent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.postparent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.preparent.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.postparent.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UnlinkResponse {
    fn new() -> UnlinkResponse {
        UnlinkResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<UnlinkResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    UnlinkResponse::get_result_for_reflect,
                    UnlinkResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "preparent",
                    UnlinkResponse::get_preparent_for_reflect,
                    UnlinkResponse::mut_preparent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "postparent",
                    UnlinkResponse::get_postparent_for_reflect,
                    UnlinkResponse::mut_postparent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    UnlinkResponse::get_extra_data_for_reflect,
                    UnlinkResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UnlinkResponse>(
                    "UnlinkResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UnlinkResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_preparent();
        self.clear_postparent();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnlinkResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnlinkResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RmdirRequest {
    // message fields
    pargfid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    xflags: ::std::option::Option<i32>,
    bname: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RmdirRequest {}

impl RmdirRequest {
    pub fn new() -> RmdirRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RmdirRequest {
        static mut instance: ::protobuf::lazy::Lazy<RmdirRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RmdirRequest,
        };
        unsafe {
            instance.get(RmdirRequest::new)
        }
    }

    // required bytes pargfid = 1;

    pub fn clear_pargfid(&mut self) {
        self.pargfid.clear();
    }

    pub fn has_pargfid(&self) -> bool {
        self.pargfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pargfid(&mut self, v: ::std::vec::Vec<u8>) {
        self.pargfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pargfid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pargfid.is_none() {
            self.pargfid.set_default();
        }
        self.pargfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_pargfid(&mut self) -> ::std::vec::Vec<u8> {
        self.pargfid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_pargfid(&self) -> &[u8] {
        match self.pargfid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_pargfid_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.pargfid
    }

    fn mut_pargfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.pargfid
    }

    // required int32 xflags = 2;

    pub fn clear_xflags(&mut self) {
        self.xflags = ::std::option::Option::None;
    }

    pub fn has_xflags(&self) -> bool {
        self.xflags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xflags(&mut self, v: i32) {
        self.xflags = ::std::option::Option::Some(v);
    }

    pub fn get_xflags(&self) -> i32 {
        self.xflags.unwrap_or(0)
    }

    fn get_xflags_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.xflags
    }

    fn mut_xflags_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.xflags
    }

    // required string bname = 3;

    pub fn clear_bname(&mut self) {
        self.bname.clear();
    }

    pub fn has_bname(&self) -> bool {
        self.bname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bname(&mut self, v: ::std::string::String) {
        self.bname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bname(&mut self) -> &mut ::std::string::String {
        if self.bname.is_none() {
            self.bname.set_default();
        }
        self.bname.as_mut().unwrap()
    }

    // Take field
    pub fn take_bname(&mut self) -> ::std::string::String {
        self.bname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_bname(&self) -> &str {
        match self.bname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_bname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.bname
    }

    fn mut_bname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.bname
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for RmdirRequest {
    fn is_initialized(&self) -> bool {
        if self.pargfid.is_none() {
            return false;
        }
        if self.xflags.is_none() {
            return false;
        }
        if self.bname.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pargfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.xflags = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bname)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pargfid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.xflags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.bname.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pargfid.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.xflags {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.bname.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RmdirRequest {
    fn new() -> RmdirRequest {
        RmdirRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<RmdirRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pargfid",
                    RmdirRequest::get_pargfid_for_reflect,
                    RmdirRequest::mut_pargfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "xflags",
                    RmdirRequest::get_xflags_for_reflect,
                    RmdirRequest::mut_xflags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bname",
                    RmdirRequest::get_bname_for_reflect,
                    RmdirRequest::mut_bname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    RmdirRequest::get_extra_data_for_reflect,
                    RmdirRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RmdirRequest>(
                    "RmdirRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RmdirRequest {
    fn clear(&mut self) {
        self.clear_pargfid();
        self.clear_xflags();
        self.clear_bname();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RmdirRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RmdirRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rmdirResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    preparent: ::protobuf::SingularPtrField<Iatt>,
    postparent: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for rmdirResponse {}

impl rmdirResponse {
    pub fn new() -> rmdirResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static rmdirResponse {
        static mut instance: ::protobuf::lazy::Lazy<rmdirResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rmdirResponse,
        };
        unsafe {
            instance.get(rmdirResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt preparent = 2;

    pub fn clear_preparent(&mut self) {
        self.preparent.clear();
    }

    pub fn has_preparent(&self) -> bool {
        self.preparent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preparent(&mut self, v: Iatt) {
        self.preparent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preparent(&mut self) -> &mut Iatt {
        if self.preparent.is_none() {
            self.preparent.set_default();
        }
        self.preparent.as_mut().unwrap()
    }

    // Take field
    pub fn take_preparent(&mut self) -> Iatt {
        self.preparent.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_preparent(&self) -> &Iatt {
        self.preparent.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_preparent_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.preparent
    }

    fn mut_preparent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.preparent
    }

    // optional .rusix.Iatt postparent = 3;

    pub fn clear_postparent(&mut self) {
        self.postparent.clear();
    }

    pub fn has_postparent(&self) -> bool {
        self.postparent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postparent(&mut self, v: Iatt) {
        self.postparent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postparent(&mut self) -> &mut Iatt {
        if self.postparent.is_none() {
            self.postparent.set_default();
        }
        self.postparent.as_mut().unwrap()
    }

    // Take field
    pub fn take_postparent(&mut self) -> Iatt {
        self.postparent.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_postparent(&self) -> &Iatt {
        self.postparent.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_postparent_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.postparent
    }

    fn mut_postparent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.postparent
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for rmdirResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preparent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.postparent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preparent)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.postparent)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.preparent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.postparent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.preparent.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.postparent.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for rmdirResponse {
    fn new() -> rmdirResponse {
        rmdirResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<rmdirResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    rmdirResponse::get_result_for_reflect,
                    rmdirResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "preparent",
                    rmdirResponse::get_preparent_for_reflect,
                    rmdirResponse::mut_preparent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "postparent",
                    rmdirResponse::get_postparent_for_reflect,
                    rmdirResponse::mut_postparent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    rmdirResponse::get_extra_data_for_reflect,
                    rmdirResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rmdirResponse>(
                    "rmdirResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for rmdirResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_preparent();
        self.clear_postparent();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rmdirResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rmdirResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SymlinkRequest {
    // message fields
    pargfid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    bname: ::protobuf::SingularField<::std::string::String>,
    umask: ::std::option::Option<u32>,
    linkname: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SymlinkRequest {}

impl SymlinkRequest {
    pub fn new() -> SymlinkRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SymlinkRequest {
        static mut instance: ::protobuf::lazy::Lazy<SymlinkRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SymlinkRequest,
        };
        unsafe {
            instance.get(SymlinkRequest::new)
        }
    }

    // required bytes pargfid = 1;

    pub fn clear_pargfid(&mut self) {
        self.pargfid.clear();
    }

    pub fn has_pargfid(&self) -> bool {
        self.pargfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pargfid(&mut self, v: ::std::vec::Vec<u8>) {
        self.pargfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pargfid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pargfid.is_none() {
            self.pargfid.set_default();
        }
        self.pargfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_pargfid(&mut self) -> ::std::vec::Vec<u8> {
        self.pargfid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_pargfid(&self) -> &[u8] {
        match self.pargfid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_pargfid_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.pargfid
    }

    fn mut_pargfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.pargfid
    }

    // required string bname = 2;

    pub fn clear_bname(&mut self) {
        self.bname.clear();
    }

    pub fn has_bname(&self) -> bool {
        self.bname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bname(&mut self, v: ::std::string::String) {
        self.bname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bname(&mut self) -> &mut ::std::string::String {
        if self.bname.is_none() {
            self.bname.set_default();
        }
        self.bname.as_mut().unwrap()
    }

    // Take field
    pub fn take_bname(&mut self) -> ::std::string::String {
        self.bname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_bname(&self) -> &str {
        match self.bname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_bname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.bname
    }

    fn mut_bname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.bname
    }

    // required uint32 umask = 3;

    pub fn clear_umask(&mut self) {
        self.umask = ::std::option::Option::None;
    }

    pub fn has_umask(&self) -> bool {
        self.umask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_umask(&mut self, v: u32) {
        self.umask = ::std::option::Option::Some(v);
    }

    pub fn get_umask(&self) -> u32 {
        self.umask.unwrap_or(0)
    }

    fn get_umask_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.umask
    }

    fn mut_umask_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.umask
    }

    // required string linkname = 4;

    pub fn clear_linkname(&mut self) {
        self.linkname.clear();
    }

    pub fn has_linkname(&self) -> bool {
        self.linkname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_linkname(&mut self, v: ::std::string::String) {
        self.linkname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_linkname(&mut self) -> &mut ::std::string::String {
        if self.linkname.is_none() {
            self.linkname.set_default();
        }
        self.linkname.as_mut().unwrap()
    }

    // Take field
    pub fn take_linkname(&mut self) -> ::std::string::String {
        self.linkname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_linkname(&self) -> &str {
        match self.linkname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_linkname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.linkname
    }

    fn mut_linkname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.linkname
    }

    // optional bytes extra_data = 5;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for SymlinkRequest {
    fn is_initialized(&self) -> bool {
        if self.pargfid.is_none() {
            return false;
        }
        if self.bname.is_none() {
            return false;
        }
        if self.umask.is_none() {
            return false;
        }
        if self.linkname.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pargfid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bname)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.umask = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.linkname)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pargfid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.bname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.umask {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.linkname.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pargfid.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.bname.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.umask {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.linkname.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SymlinkRequest {
    fn new() -> SymlinkRequest {
        SymlinkRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<SymlinkRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pargfid",
                    SymlinkRequest::get_pargfid_for_reflect,
                    SymlinkRequest::mut_pargfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bname",
                    SymlinkRequest::get_bname_for_reflect,
                    SymlinkRequest::mut_bname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "umask",
                    SymlinkRequest::get_umask_for_reflect,
                    SymlinkRequest::mut_umask_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "linkname",
                    SymlinkRequest::get_linkname_for_reflect,
                    SymlinkRequest::mut_linkname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    SymlinkRequest::get_extra_data_for_reflect,
                    SymlinkRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SymlinkRequest>(
                    "SymlinkRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SymlinkRequest {
    fn clear(&mut self) {
        self.clear_pargfid();
        self.clear_bname();
        self.clear_umask();
        self.clear_linkname();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SymlinkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SymlinkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SymlinkResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    stat: ::protobuf::SingularPtrField<Iatt>,
    preparent: ::protobuf::SingularPtrField<Iatt>,
    postparent: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SymlinkResponse {}

impl SymlinkResponse {
    pub fn new() -> SymlinkResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SymlinkResponse {
        static mut instance: ::protobuf::lazy::Lazy<SymlinkResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SymlinkResponse,
        };
        unsafe {
            instance.get(SymlinkResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt stat = 2;

    pub fn clear_stat(&mut self) {
        self.stat.clear();
    }

    pub fn has_stat(&self) -> bool {
        self.stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: Iatt) {
        self.stat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat(&mut self) -> &mut Iatt {
        if self.stat.is_none() {
            self.stat.set_default();
        }
        self.stat.as_mut().unwrap()
    }

    // Take field
    pub fn take_stat(&mut self) -> Iatt {
        self.stat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_stat(&self) -> &Iatt {
        self.stat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_stat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.stat
    }

    fn mut_stat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.stat
    }

    // optional .rusix.Iatt preparent = 3;

    pub fn clear_preparent(&mut self) {
        self.preparent.clear();
    }

    pub fn has_preparent(&self) -> bool {
        self.preparent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preparent(&mut self, v: Iatt) {
        self.preparent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preparent(&mut self) -> &mut Iatt {
        if self.preparent.is_none() {
            self.preparent.set_default();
        }
        self.preparent.as_mut().unwrap()
    }

    // Take field
    pub fn take_preparent(&mut self) -> Iatt {
        self.preparent.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_preparent(&self) -> &Iatt {
        self.preparent.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_preparent_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.preparent
    }

    fn mut_preparent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.preparent
    }

    // optional .rusix.Iatt postparent = 4;

    pub fn clear_postparent(&mut self) {
        self.postparent.clear();
    }

    pub fn has_postparent(&self) -> bool {
        self.postparent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postparent(&mut self, v: Iatt) {
        self.postparent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postparent(&mut self) -> &mut Iatt {
        if self.postparent.is_none() {
            self.postparent.set_default();
        }
        self.postparent.as_mut().unwrap()
    }

    // Take field
    pub fn take_postparent(&mut self) -> Iatt {
        self.postparent.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_postparent(&self) -> &Iatt {
        self.postparent.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_postparent_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.postparent
    }

    fn mut_postparent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.postparent
    }

    // optional bytes extra_data = 5;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for SymlinkResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preparent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.postparent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stat)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preparent)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.postparent)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.preparent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.postparent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stat.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.preparent.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.postparent.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SymlinkResponse {
    fn new() -> SymlinkResponse {
        SymlinkResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<SymlinkResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    SymlinkResponse::get_result_for_reflect,
                    SymlinkResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "stat",
                    SymlinkResponse::get_stat_for_reflect,
                    SymlinkResponse::mut_stat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "preparent",
                    SymlinkResponse::get_preparent_for_reflect,
                    SymlinkResponse::mut_preparent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "postparent",
                    SymlinkResponse::get_postparent_for_reflect,
                    SymlinkResponse::mut_postparent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    SymlinkResponse::get_extra_data_for_reflect,
                    SymlinkResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SymlinkResponse>(
                    "SymlinkResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SymlinkResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_stat();
        self.clear_preparent();
        self.clear_postparent();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SymlinkResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SymlinkResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenameRequest {
    // message fields
    oldgfid: ::protobuf::SingularField<::std::string::String>,
    newgfid: ::protobuf::SingularField<::std::string::String>,
    oldbname: ::protobuf::SingularField<::std::string::String>,
    newbname: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RenameRequest {}

impl RenameRequest {
    pub fn new() -> RenameRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RenameRequest {
        static mut instance: ::protobuf::lazy::Lazy<RenameRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenameRequest,
        };
        unsafe {
            instance.get(RenameRequest::new)
        }
    }

    // required string oldgfid = 1;

    pub fn clear_oldgfid(&mut self) {
        self.oldgfid.clear();
    }

    pub fn has_oldgfid(&self) -> bool {
        self.oldgfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oldgfid(&mut self, v: ::std::string::String) {
        self.oldgfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oldgfid(&mut self) -> &mut ::std::string::String {
        if self.oldgfid.is_none() {
            self.oldgfid.set_default();
        }
        self.oldgfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_oldgfid(&mut self) -> ::std::string::String {
        self.oldgfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_oldgfid(&self) -> &str {
        match self.oldgfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_oldgfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.oldgfid
    }

    fn mut_oldgfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.oldgfid
    }

    // required string newgfid = 2;

    pub fn clear_newgfid(&mut self) {
        self.newgfid.clear();
    }

    pub fn has_newgfid(&self) -> bool {
        self.newgfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newgfid(&mut self, v: ::std::string::String) {
        self.newgfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newgfid(&mut self) -> &mut ::std::string::String {
        if self.newgfid.is_none() {
            self.newgfid.set_default();
        }
        self.newgfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_newgfid(&mut self) -> ::std::string::String {
        self.newgfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_newgfid(&self) -> &str {
        match self.newgfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_newgfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.newgfid
    }

    fn mut_newgfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.newgfid
    }

    // required string oldbname = 3;

    pub fn clear_oldbname(&mut self) {
        self.oldbname.clear();
    }

    pub fn has_oldbname(&self) -> bool {
        self.oldbname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oldbname(&mut self, v: ::std::string::String) {
        self.oldbname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oldbname(&mut self) -> &mut ::std::string::String {
        if self.oldbname.is_none() {
            self.oldbname.set_default();
        }
        self.oldbname.as_mut().unwrap()
    }

    // Take field
    pub fn take_oldbname(&mut self) -> ::std::string::String {
        self.oldbname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_oldbname(&self) -> &str {
        match self.oldbname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_oldbname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.oldbname
    }

    fn mut_oldbname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.oldbname
    }

    // required string newbname = 4;

    pub fn clear_newbname(&mut self) {
        self.newbname.clear();
    }

    pub fn has_newbname(&self) -> bool {
        self.newbname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newbname(&mut self, v: ::std::string::String) {
        self.newbname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newbname(&mut self) -> &mut ::std::string::String {
        if self.newbname.is_none() {
            self.newbname.set_default();
        }
        self.newbname.as_mut().unwrap()
    }

    // Take field
    pub fn take_newbname(&mut self) -> ::std::string::String {
        self.newbname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_newbname(&self) -> &str {
        match self.newbname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_newbname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.newbname
    }

    fn mut_newbname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.newbname
    }

    // optional bytes extra_data = 5;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for RenameRequest {
    fn is_initialized(&self) -> bool {
        if self.oldgfid.is_none() {
            return false;
        }
        if self.newgfid.is_none() {
            return false;
        }
        if self.oldbname.is_none() {
            return false;
        }
        if self.newbname.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.oldgfid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.newgfid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.oldbname)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.newbname)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.oldgfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.newgfid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.oldbname.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.newbname.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.oldgfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.newgfid.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.oldbname.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.newbname.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RenameRequest {
    fn new() -> RenameRequest {
        RenameRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<RenameRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "oldgfid",
                    RenameRequest::get_oldgfid_for_reflect,
                    RenameRequest::mut_oldgfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "newgfid",
                    RenameRequest::get_newgfid_for_reflect,
                    RenameRequest::mut_newgfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "oldbname",
                    RenameRequest::get_oldbname_for_reflect,
                    RenameRequest::mut_oldbname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "newbname",
                    RenameRequest::get_newbname_for_reflect,
                    RenameRequest::mut_newbname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    RenameRequest::get_extra_data_for_reflect,
                    RenameRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RenameRequest>(
                    "RenameRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RenameRequest {
    fn clear(&mut self) {
        self.clear_oldgfid();
        self.clear_newgfid();
        self.clear_oldbname();
        self.clear_newbname();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenameRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct renameResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    stat: ::protobuf::SingularPtrField<Iatt>,
    preoldparent: ::protobuf::SingularPtrField<Iatt>,
    postoldparent: ::protobuf::SingularPtrField<Iatt>,
    prenewparent: ::protobuf::SingularPtrField<Iatt>,
    postnewparent: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for renameResponse {}

impl renameResponse {
    pub fn new() -> renameResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static renameResponse {
        static mut instance: ::protobuf::lazy::Lazy<renameResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const renameResponse,
        };
        unsafe {
            instance.get(renameResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt stat = 2;

    pub fn clear_stat(&mut self) {
        self.stat.clear();
    }

    pub fn has_stat(&self) -> bool {
        self.stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: Iatt) {
        self.stat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat(&mut self) -> &mut Iatt {
        if self.stat.is_none() {
            self.stat.set_default();
        }
        self.stat.as_mut().unwrap()
    }

    // Take field
    pub fn take_stat(&mut self) -> Iatt {
        self.stat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_stat(&self) -> &Iatt {
        self.stat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_stat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.stat
    }

    fn mut_stat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.stat
    }

    // optional .rusix.Iatt preoldparent = 3;

    pub fn clear_preoldparent(&mut self) {
        self.preoldparent.clear();
    }

    pub fn has_preoldparent(&self) -> bool {
        self.preoldparent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preoldparent(&mut self, v: Iatt) {
        self.preoldparent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preoldparent(&mut self) -> &mut Iatt {
        if self.preoldparent.is_none() {
            self.preoldparent.set_default();
        }
        self.preoldparent.as_mut().unwrap()
    }

    // Take field
    pub fn take_preoldparent(&mut self) -> Iatt {
        self.preoldparent.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_preoldparent(&self) -> &Iatt {
        self.preoldparent.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_preoldparent_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.preoldparent
    }

    fn mut_preoldparent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.preoldparent
    }

    // optional .rusix.Iatt postoldparent = 4;

    pub fn clear_postoldparent(&mut self) {
        self.postoldparent.clear();
    }

    pub fn has_postoldparent(&self) -> bool {
        self.postoldparent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postoldparent(&mut self, v: Iatt) {
        self.postoldparent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postoldparent(&mut self) -> &mut Iatt {
        if self.postoldparent.is_none() {
            self.postoldparent.set_default();
        }
        self.postoldparent.as_mut().unwrap()
    }

    // Take field
    pub fn take_postoldparent(&mut self) -> Iatt {
        self.postoldparent.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_postoldparent(&self) -> &Iatt {
        self.postoldparent.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_postoldparent_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.postoldparent
    }

    fn mut_postoldparent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.postoldparent
    }

    // optional .rusix.Iatt prenewparent = 5;

    pub fn clear_prenewparent(&mut self) {
        self.prenewparent.clear();
    }

    pub fn has_prenewparent(&self) -> bool {
        self.prenewparent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prenewparent(&mut self, v: Iatt) {
        self.prenewparent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prenewparent(&mut self) -> &mut Iatt {
        if self.prenewparent.is_none() {
            self.prenewparent.set_default();
        }
        self.prenewparent.as_mut().unwrap()
    }

    // Take field
    pub fn take_prenewparent(&mut self) -> Iatt {
        self.prenewparent.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_prenewparent(&self) -> &Iatt {
        self.prenewparent.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_prenewparent_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.prenewparent
    }

    fn mut_prenewparent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.prenewparent
    }

    // optional .rusix.Iatt postnewparent = 6;

    pub fn clear_postnewparent(&mut self) {
        self.postnewparent.clear();
    }

    pub fn has_postnewparent(&self) -> bool {
        self.postnewparent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postnewparent(&mut self, v: Iatt) {
        self.postnewparent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postnewparent(&mut self) -> &mut Iatt {
        if self.postnewparent.is_none() {
            self.postnewparent.set_default();
        }
        self.postnewparent.as_mut().unwrap()
    }

    // Take field
    pub fn take_postnewparent(&mut self) -> Iatt {
        self.postnewparent.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_postnewparent(&self) -> &Iatt {
        self.postnewparent.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_postnewparent_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.postnewparent
    }

    fn mut_postnewparent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.postnewparent
    }

    // optional bytes extra_data = 7;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for renameResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preoldparent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.postoldparent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prenewparent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.postnewparent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stat)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preoldparent)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.postoldparent)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.prenewparent)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.postnewparent)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.preoldparent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.postoldparent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.prenewparent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.postnewparent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stat.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.preoldparent.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.postoldparent.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.prenewparent.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.postnewparent.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for renameResponse {
    fn new() -> renameResponse {
        renameResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<renameResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    renameResponse::get_result_for_reflect,
                    renameResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "stat",
                    renameResponse::get_stat_for_reflect,
                    renameResponse::mut_stat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "preoldparent",
                    renameResponse::get_preoldparent_for_reflect,
                    renameResponse::mut_preoldparent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "postoldparent",
                    renameResponse::get_postoldparent_for_reflect,
                    renameResponse::mut_postoldparent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "prenewparent",
                    renameResponse::get_prenewparent_for_reflect,
                    renameResponse::mut_prenewparent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "postnewparent",
                    renameResponse::get_postnewparent_for_reflect,
                    renameResponse::mut_postnewparent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    renameResponse::get_extra_data_for_reflect,
                    renameResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<renameResponse>(
                    "renameResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for renameResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_stat();
        self.clear_preoldparent();
        self.clear_postoldparent();
        self.clear_prenewparent();
        self.clear_postnewparent();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for renameResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for renameResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct linkRequest {
    // message fields
    oldgfid: ::protobuf::SingularField<::std::string::String>,
    newgfid: ::protobuf::SingularField<::std::string::String>,
    newbname: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for linkRequest {}

impl linkRequest {
    pub fn new() -> linkRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static linkRequest {
        static mut instance: ::protobuf::lazy::Lazy<linkRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const linkRequest,
        };
        unsafe {
            instance.get(linkRequest::new)
        }
    }

    // required string oldgfid = 1;

    pub fn clear_oldgfid(&mut self) {
        self.oldgfid.clear();
    }

    pub fn has_oldgfid(&self) -> bool {
        self.oldgfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oldgfid(&mut self, v: ::std::string::String) {
        self.oldgfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oldgfid(&mut self) -> &mut ::std::string::String {
        if self.oldgfid.is_none() {
            self.oldgfid.set_default();
        }
        self.oldgfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_oldgfid(&mut self) -> ::std::string::String {
        self.oldgfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_oldgfid(&self) -> &str {
        match self.oldgfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_oldgfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.oldgfid
    }

    fn mut_oldgfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.oldgfid
    }

    // required string newgfid = 2;

    pub fn clear_newgfid(&mut self) {
        self.newgfid.clear();
    }

    pub fn has_newgfid(&self) -> bool {
        self.newgfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newgfid(&mut self, v: ::std::string::String) {
        self.newgfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newgfid(&mut self) -> &mut ::std::string::String {
        if self.newgfid.is_none() {
            self.newgfid.set_default();
        }
        self.newgfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_newgfid(&mut self) -> ::std::string::String {
        self.newgfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_newgfid(&self) -> &str {
        match self.newgfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_newgfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.newgfid
    }

    fn mut_newgfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.newgfid
    }

    // required string newbname = 3;

    pub fn clear_newbname(&mut self) {
        self.newbname.clear();
    }

    pub fn has_newbname(&self) -> bool {
        self.newbname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newbname(&mut self, v: ::std::string::String) {
        self.newbname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newbname(&mut self) -> &mut ::std::string::String {
        if self.newbname.is_none() {
            self.newbname.set_default();
        }
        self.newbname.as_mut().unwrap()
    }

    // Take field
    pub fn take_newbname(&mut self) -> ::std::string::String {
        self.newbname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_newbname(&self) -> &str {
        match self.newbname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_newbname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.newbname
    }

    fn mut_newbname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.newbname
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for linkRequest {
    fn is_initialized(&self) -> bool {
        if self.oldgfid.is_none() {
            return false;
        }
        if self.newgfid.is_none() {
            return false;
        }
        if self.newbname.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.oldgfid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.newgfid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.newbname)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.oldgfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.newgfid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.newbname.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.oldgfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.newgfid.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.newbname.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for linkRequest {
    fn new() -> linkRequest {
        linkRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<linkRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "oldgfid",
                    linkRequest::get_oldgfid_for_reflect,
                    linkRequest::mut_oldgfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "newgfid",
                    linkRequest::get_newgfid_for_reflect,
                    linkRequest::mut_newgfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "newbname",
                    linkRequest::get_newbname_for_reflect,
                    linkRequest::mut_newbname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    linkRequest::get_extra_data_for_reflect,
                    linkRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<linkRequest>(
                    "linkRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for linkRequest {
    fn clear(&mut self) {
        self.clear_oldgfid();
        self.clear_newgfid();
        self.clear_newbname();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for linkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for linkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct linkResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    stat: ::protobuf::SingularPtrField<Iatt>,
    preparent: ::protobuf::SingularPtrField<Iatt>,
    postparent: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for linkResponse {}

impl linkResponse {
    pub fn new() -> linkResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static linkResponse {
        static mut instance: ::protobuf::lazy::Lazy<linkResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const linkResponse,
        };
        unsafe {
            instance.get(linkResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt stat = 2;

    pub fn clear_stat(&mut self) {
        self.stat.clear();
    }

    pub fn has_stat(&self) -> bool {
        self.stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: Iatt) {
        self.stat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat(&mut self) -> &mut Iatt {
        if self.stat.is_none() {
            self.stat.set_default();
        }
        self.stat.as_mut().unwrap()
    }

    // Take field
    pub fn take_stat(&mut self) -> Iatt {
        self.stat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_stat(&self) -> &Iatt {
        self.stat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_stat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.stat
    }

    fn mut_stat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.stat
    }

    // optional .rusix.Iatt preparent = 3;

    pub fn clear_preparent(&mut self) {
        self.preparent.clear();
    }

    pub fn has_preparent(&self) -> bool {
        self.preparent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preparent(&mut self, v: Iatt) {
        self.preparent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preparent(&mut self) -> &mut Iatt {
        if self.preparent.is_none() {
            self.preparent.set_default();
        }
        self.preparent.as_mut().unwrap()
    }

    // Take field
    pub fn take_preparent(&mut self) -> Iatt {
        self.preparent.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_preparent(&self) -> &Iatt {
        self.preparent.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_preparent_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.preparent
    }

    fn mut_preparent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.preparent
    }

    // optional .rusix.Iatt postparent = 4;

    pub fn clear_postparent(&mut self) {
        self.postparent.clear();
    }

    pub fn has_postparent(&self) -> bool {
        self.postparent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postparent(&mut self, v: Iatt) {
        self.postparent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postparent(&mut self) -> &mut Iatt {
        if self.postparent.is_none() {
            self.postparent.set_default();
        }
        self.postparent.as_mut().unwrap()
    }

    // Take field
    pub fn take_postparent(&mut self) -> Iatt {
        self.postparent.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_postparent(&self) -> &Iatt {
        self.postparent.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_postparent_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.postparent
    }

    fn mut_postparent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.postparent
    }

    // optional bytes extra_data = 5;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for linkResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preparent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.postparent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stat)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preparent)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.postparent)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.preparent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.postparent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stat.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.preparent.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.postparent.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for linkResponse {
    fn new() -> linkResponse {
        linkResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<linkResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    linkResponse::get_result_for_reflect,
                    linkResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "stat",
                    linkResponse::get_stat_for_reflect,
                    linkResponse::mut_stat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "preparent",
                    linkResponse::get_preparent_for_reflect,
                    linkResponse::mut_preparent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "postparent",
                    linkResponse::get_postparent_for_reflect,
                    linkResponse::mut_postparent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    linkResponse::get_extra_data_for_reflect,
                    linkResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<linkResponse>(
                    "linkResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for linkResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_stat();
        self.clear_preparent();
        self.clear_postparent();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for linkResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for linkResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct truncateRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    offset: ::std::option::Option<u64>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for truncateRequest {}

impl truncateRequest {
    pub fn new() -> truncateRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static truncateRequest {
        static mut instance: ::protobuf::lazy::Lazy<truncateRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const truncateRequest,
        };
        unsafe {
            instance.get(truncateRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 offset = 2;

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }

    fn get_offset_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.offset
    }

    fn mut_offset_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.offset
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for truncateRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for truncateRequest {
    fn new() -> truncateRequest {
        truncateRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<truncateRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    truncateRequest::get_gfid_for_reflect,
                    truncateRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "offset",
                    truncateRequest::get_offset_for_reflect,
                    truncateRequest::mut_offset_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    truncateRequest::get_extra_data_for_reflect,
                    truncateRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<truncateRequest>(
                    "truncateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for truncateRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_offset();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for truncateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for truncateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct truncateResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    prestat: ::protobuf::SingularPtrField<Iatt>,
    poststat: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for truncateResponse {}

impl truncateResponse {
    pub fn new() -> truncateResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static truncateResponse {
        static mut instance: ::protobuf::lazy::Lazy<truncateResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const truncateResponse,
        };
        unsafe {
            instance.get(truncateResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt prestat = 2;

    pub fn clear_prestat(&mut self) {
        self.prestat.clear();
    }

    pub fn has_prestat(&self) -> bool {
        self.prestat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prestat(&mut self, v: Iatt) {
        self.prestat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prestat(&mut self) -> &mut Iatt {
        if self.prestat.is_none() {
            self.prestat.set_default();
        }
        self.prestat.as_mut().unwrap()
    }

    // Take field
    pub fn take_prestat(&mut self) -> Iatt {
        self.prestat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_prestat(&self) -> &Iatt {
        self.prestat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_prestat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.prestat
    }

    fn mut_prestat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.prestat
    }

    // optional .rusix.Iatt poststat = 3;

    pub fn clear_poststat(&mut self) {
        self.poststat.clear();
    }

    pub fn has_poststat(&self) -> bool {
        self.poststat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poststat(&mut self, v: Iatt) {
        self.poststat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poststat(&mut self) -> &mut Iatt {
        if self.poststat.is_none() {
            self.poststat.set_default();
        }
        self.poststat.as_mut().unwrap()
    }

    // Take field
    pub fn take_poststat(&mut self) -> Iatt {
        self.poststat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_poststat(&self) -> &Iatt {
        self.poststat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_poststat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.poststat
    }

    fn mut_poststat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.poststat
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for truncateResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prestat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.poststat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.prestat)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.poststat)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.prestat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.poststat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.prestat.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.poststat.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for truncateResponse {
    fn new() -> truncateResponse {
        truncateResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<truncateResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    truncateResponse::get_result_for_reflect,
                    truncateResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "prestat",
                    truncateResponse::get_prestat_for_reflect,
                    truncateResponse::mut_prestat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "poststat",
                    truncateResponse::get_poststat_for_reflect,
                    truncateResponse::mut_poststat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    truncateResponse::get_extra_data_for_reflect,
                    truncateResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<truncateResponse>(
                    "truncateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for truncateResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_prestat();
        self.clear_poststat();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for truncateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for truncateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct openRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    flags: ::std::option::Option<u32>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for openRequest {}

impl openRequest {
    pub fn new() -> openRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static openRequest {
        static mut instance: ::protobuf::lazy::Lazy<openRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const openRequest,
        };
        unsafe {
            instance.get(openRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint32 flags = 2;

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    fn get_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.flags
    }

    fn mut_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.flags
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for openRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.flags.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for openRequest {
    fn new() -> openRequest {
        openRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<openRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    openRequest::get_gfid_for_reflect,
                    openRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    openRequest::get_flags_for_reflect,
                    openRequest::mut_flags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    openRequest::get_extra_data_for_reflect,
                    openRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<openRequest>(
                    "openRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for openRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_flags();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for openRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for openRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct openResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    fd: ::std::option::Option<u64>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for openResponse {}

impl openResponse {
    pub fn new() -> openResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static openResponse {
        static mut instance: ::protobuf::lazy::Lazy<openResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const openResponse,
        };
        unsafe {
            instance.get(openResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for openResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for openResponse {
    fn new() -> openResponse {
        openResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<openResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    openResponse::get_result_for_reflect,
                    openResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    openResponse::get_fd_for_reflect,
                    openResponse::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    openResponse::get_extra_data_for_reflect,
                    openResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<openResponse>(
                    "openResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for openResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_fd();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for openResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for openResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct readRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<u64>,
    offset: ::std::option::Option<u64>,
    size: ::std::option::Option<u32>,
    flag: ::std::option::Option<u32>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for readRequest {}

impl readRequest {
    pub fn new() -> readRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static readRequest {
        static mut instance: ::protobuf::lazy::Lazy<readRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const readRequest,
        };
        unsafe {
            instance.get(readRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // required uint64 offset = 3;

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }

    fn get_offset_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.offset
    }

    fn mut_offset_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.offset
    }

    // required uint32 size = 4;

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    pub fn get_size(&self) -> u32 {
        self.size.unwrap_or(0)
    }

    fn get_size_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.size
    }

    fn mut_size_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.size
    }

    // required uint32 flag = 5;

    pub fn clear_flag(&mut self) {
        self.flag = ::std::option::Option::None;
    }

    pub fn has_flag(&self) -> bool {
        self.flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flag(&mut self, v: u32) {
        self.flag = ::std::option::Option::Some(v);
    }

    pub fn get_flag(&self) -> u32 {
        self.flag.unwrap_or(0)
    }

    fn get_flag_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.flag
    }

    fn mut_flag_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.flag
    }

    // optional bytes extra_data = 6;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for readRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        if self.size.is_none() {
            return false;
        }
        if self.flag.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flag = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flag {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.flag {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for readRequest {
    fn new() -> readRequest {
        readRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<readRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    readRequest::get_gfid_for_reflect,
                    readRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    readRequest::get_fd_for_reflect,
                    readRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "offset",
                    readRequest::get_offset_for_reflect,
                    readRequest::mut_offset_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "size",
                    readRequest::get_size_for_reflect,
                    readRequest::mut_size_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flag",
                    readRequest::get_flag_for_reflect,
                    readRequest::mut_flag_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    readRequest::get_extra_data_for_reflect,
                    readRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<readRequest>(
                    "readRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for readRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_offset();
        self.clear_size();
        self.clear_flag();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for readRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for readRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct readResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    stat: ::protobuf::SingularPtrField<Iatt>,
    size: ::std::option::Option<u32>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for readResponse {}

impl readResponse {
    pub fn new() -> readResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static readResponse {
        static mut instance: ::protobuf::lazy::Lazy<readResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const readResponse,
        };
        unsafe {
            instance.get(readResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt stat = 2;

    pub fn clear_stat(&mut self) {
        self.stat.clear();
    }

    pub fn has_stat(&self) -> bool {
        self.stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: Iatt) {
        self.stat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat(&mut self) -> &mut Iatt {
        if self.stat.is_none() {
            self.stat.set_default();
        }
        self.stat.as_mut().unwrap()
    }

    // Take field
    pub fn take_stat(&mut self) -> Iatt {
        self.stat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_stat(&self) -> &Iatt {
        self.stat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_stat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.stat
    }

    fn mut_stat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.stat
    }

    // optional uint32 size = 3;

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    pub fn get_size(&self) -> u32 {
        self.size.unwrap_or(0)
    }

    fn get_size_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.size
    }

    fn mut_size_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.size
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for readResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stat)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stat.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for readResponse {
    fn new() -> readResponse {
        readResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<readResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    readResponse::get_result_for_reflect,
                    readResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "stat",
                    readResponse::get_stat_for_reflect,
                    readResponse::mut_stat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "size",
                    readResponse::get_size_for_reflect,
                    readResponse::mut_size_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    readResponse::get_extra_data_for_reflect,
                    readResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<readResponse>(
                    "readResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for readResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_stat();
        self.clear_size();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for readResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for readResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct lookupRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    pargfid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    flags: ::std::option::Option<u32>,
    bname: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for lookupRequest {}

impl lookupRequest {
    pub fn new() -> lookupRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static lookupRequest {
        static mut instance: ::protobuf::lazy::Lazy<lookupRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const lookupRequest,
        };
        unsafe {
            instance.get(lookupRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required bytes pargfid = 2;

    pub fn clear_pargfid(&mut self) {
        self.pargfid.clear();
    }

    pub fn has_pargfid(&self) -> bool {
        self.pargfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pargfid(&mut self, v: ::std::vec::Vec<u8>) {
        self.pargfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pargfid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pargfid.is_none() {
            self.pargfid.set_default();
        }
        self.pargfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_pargfid(&mut self) -> ::std::vec::Vec<u8> {
        self.pargfid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_pargfid(&self) -> &[u8] {
        match self.pargfid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_pargfid_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.pargfid
    }

    fn mut_pargfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.pargfid
    }

    // required uint32 flags = 3;

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    fn get_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.flags
    }

    fn mut_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.flags
    }

    // required string bname = 4;

    pub fn clear_bname(&mut self) {
        self.bname.clear();
    }

    pub fn has_bname(&self) -> bool {
        self.bname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bname(&mut self, v: ::std::string::String) {
        self.bname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bname(&mut self) -> &mut ::std::string::String {
        if self.bname.is_none() {
            self.bname.set_default();
        }
        self.bname.as_mut().unwrap()
    }

    // Take field
    pub fn take_bname(&mut self) -> ::std::string::String {
        self.bname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_bname(&self) -> &str {
        match self.bname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_bname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.bname
    }

    fn mut_bname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.bname
    }

    // optional bytes extra_data = 5;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for lookupRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.pargfid.is_none() {
            return false;
        }
        if self.flags.is_none() {
            return false;
        }
        if self.bname.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pargfid)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bname)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.pargfid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.bname.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.pargfid.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.bname.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for lookupRequest {
    fn new() -> lookupRequest {
        lookupRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<lookupRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    lookupRequest::get_gfid_for_reflect,
                    lookupRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pargfid",
                    lookupRequest::get_pargfid_for_reflect,
                    lookupRequest::mut_pargfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    lookupRequest::get_flags_for_reflect,
                    lookupRequest::mut_flags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bname",
                    lookupRequest::get_bname_for_reflect,
                    lookupRequest::mut_bname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    lookupRequest::get_extra_data_for_reflect,
                    lookupRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<lookupRequest>(
                    "lookupRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for lookupRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_pargfid();
        self.clear_flags();
        self.clear_bname();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for lookupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for lookupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct lookupResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    stat: ::protobuf::SingularPtrField<Iatt>,
    postparent: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for lookupResponse {}

impl lookupResponse {
    pub fn new() -> lookupResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static lookupResponse {
        static mut instance: ::protobuf::lazy::Lazy<lookupResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const lookupResponse,
        };
        unsafe {
            instance.get(lookupResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt stat = 2;

    pub fn clear_stat(&mut self) {
        self.stat.clear();
    }

    pub fn has_stat(&self) -> bool {
        self.stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: Iatt) {
        self.stat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat(&mut self) -> &mut Iatt {
        if self.stat.is_none() {
            self.stat.set_default();
        }
        self.stat.as_mut().unwrap()
    }

    // Take field
    pub fn take_stat(&mut self) -> Iatt {
        self.stat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_stat(&self) -> &Iatt {
        self.stat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_stat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.stat
    }

    fn mut_stat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.stat
    }

    // optional .rusix.Iatt postparent = 3;

    pub fn clear_postparent(&mut self) {
        self.postparent.clear();
    }

    pub fn has_postparent(&self) -> bool {
        self.postparent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postparent(&mut self, v: Iatt) {
        self.postparent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postparent(&mut self) -> &mut Iatt {
        if self.postparent.is_none() {
            self.postparent.set_default();
        }
        self.postparent.as_mut().unwrap()
    }

    // Take field
    pub fn take_postparent(&mut self) -> Iatt {
        self.postparent.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_postparent(&self) -> &Iatt {
        self.postparent.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_postparent_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.postparent
    }

    fn mut_postparent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.postparent
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for lookupResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.postparent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stat)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.postparent)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.postparent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stat.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.postparent.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for lookupResponse {
    fn new() -> lookupResponse {
        lookupResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<lookupResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    lookupResponse::get_result_for_reflect,
                    lookupResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "stat",
                    lookupResponse::get_stat_for_reflect,
                    lookupResponse::mut_stat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "postparent",
                    lookupResponse::get_postparent_for_reflect,
                    lookupResponse::mut_postparent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    lookupResponse::get_extra_data_for_reflect,
                    lookupResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<lookupResponse>(
                    "lookupResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for lookupResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_stat();
        self.clear_postparent();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for lookupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for lookupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct writeRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<u64>,
    offset: ::std::option::Option<u64>,
    size: ::std::option::Option<u32>,
    flag: ::std::option::Option<u32>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for writeRequest {}

impl writeRequest {
    pub fn new() -> writeRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static writeRequest {
        static mut instance: ::protobuf::lazy::Lazy<writeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const writeRequest,
        };
        unsafe {
            instance.get(writeRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // required uint64 offset = 3;

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }

    fn get_offset_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.offset
    }

    fn mut_offset_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.offset
    }

    // required uint32 size = 4;

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    pub fn get_size(&self) -> u32 {
        self.size.unwrap_or(0)
    }

    fn get_size_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.size
    }

    fn mut_size_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.size
    }

    // required uint32 flag = 5;

    pub fn clear_flag(&mut self) {
        self.flag = ::std::option::Option::None;
    }

    pub fn has_flag(&self) -> bool {
        self.flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flag(&mut self, v: u32) {
        self.flag = ::std::option::Option::Some(v);
    }

    pub fn get_flag(&self) -> u32 {
        self.flag.unwrap_or(0)
    }

    fn get_flag_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.flag
    }

    fn mut_flag_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.flag
    }

    // optional bytes extra_data = 6;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for writeRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        if self.size.is_none() {
            return false;
        }
        if self.flag.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flag = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flag {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.flag {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for writeRequest {
    fn new() -> writeRequest {
        writeRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<writeRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    writeRequest::get_gfid_for_reflect,
                    writeRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    writeRequest::get_fd_for_reflect,
                    writeRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "offset",
                    writeRequest::get_offset_for_reflect,
                    writeRequest::mut_offset_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "size",
                    writeRequest::get_size_for_reflect,
                    writeRequest::mut_size_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flag",
                    writeRequest::get_flag_for_reflect,
                    writeRequest::mut_flag_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    writeRequest::get_extra_data_for_reflect,
                    writeRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<writeRequest>(
                    "writeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for writeRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_offset();
        self.clear_size();
        self.clear_flag();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for writeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for writeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct writeResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    prestat: ::protobuf::SingularPtrField<Iatt>,
    poststat: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for writeResponse {}

impl writeResponse {
    pub fn new() -> writeResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static writeResponse {
        static mut instance: ::protobuf::lazy::Lazy<writeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const writeResponse,
        };
        unsafe {
            instance.get(writeResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt prestat = 2;

    pub fn clear_prestat(&mut self) {
        self.prestat.clear();
    }

    pub fn has_prestat(&self) -> bool {
        self.prestat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prestat(&mut self, v: Iatt) {
        self.prestat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prestat(&mut self) -> &mut Iatt {
        if self.prestat.is_none() {
            self.prestat.set_default();
        }
        self.prestat.as_mut().unwrap()
    }

    // Take field
    pub fn take_prestat(&mut self) -> Iatt {
        self.prestat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_prestat(&self) -> &Iatt {
        self.prestat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_prestat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.prestat
    }

    fn mut_prestat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.prestat
    }

    // optional .rusix.Iatt poststat = 3;

    pub fn clear_poststat(&mut self) {
        self.poststat.clear();
    }

    pub fn has_poststat(&self) -> bool {
        self.poststat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poststat(&mut self, v: Iatt) {
        self.poststat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poststat(&mut self) -> &mut Iatt {
        if self.poststat.is_none() {
            self.poststat.set_default();
        }
        self.poststat.as_mut().unwrap()
    }

    // Take field
    pub fn take_poststat(&mut self) -> Iatt {
        self.poststat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_poststat(&self) -> &Iatt {
        self.poststat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_poststat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.poststat
    }

    fn mut_poststat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.poststat
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for writeResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prestat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.poststat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.prestat)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.poststat)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.prestat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.poststat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.prestat.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.poststat.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for writeResponse {
    fn new() -> writeResponse {
        writeResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<writeResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    writeResponse::get_result_for_reflect,
                    writeResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "prestat",
                    writeResponse::get_prestat_for_reflect,
                    writeResponse::mut_prestat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "poststat",
                    writeResponse::get_poststat_for_reflect,
                    writeResponse::mut_poststat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    writeResponse::get_extra_data_for_reflect,
                    writeResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<writeResponse>(
                    "writeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for writeResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_prestat();
        self.clear_poststat();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for writeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for writeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct statfsRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for statfsRequest {}

impl statfsRequest {
    pub fn new() -> statfsRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static statfsRequest {
        static mut instance: ::protobuf::lazy::Lazy<statfsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const statfsRequest,
        };
        unsafe {
            instance.get(statfsRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // optional bytes extra_data = 2;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for statfsRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for statfsRequest {
    fn new() -> statfsRequest {
        statfsRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<statfsRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    statfsRequest::get_gfid_for_reflect,
                    statfsRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    statfsRequest::get_extra_data_for_reflect,
                    statfsRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<statfsRequest>(
                    "statfsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for statfsRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for statfsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for statfsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct statfsResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    statfs: ::protobuf::SingularPtrField<Statfs>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for statfsResponse {}

impl statfsResponse {
    pub fn new() -> statfsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static statfsResponse {
        static mut instance: ::protobuf::lazy::Lazy<statfsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const statfsResponse,
        };
        unsafe {
            instance.get(statfsResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Statfs statfs = 2;

    pub fn clear_statfs(&mut self) {
        self.statfs.clear();
    }

    pub fn has_statfs(&self) -> bool {
        self.statfs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statfs(&mut self, v: Statfs) {
        self.statfs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statfs(&mut self) -> &mut Statfs {
        if self.statfs.is_none() {
            self.statfs.set_default();
        }
        self.statfs.as_mut().unwrap()
    }

    // Take field
    pub fn take_statfs(&mut self) -> Statfs {
        self.statfs.take().unwrap_or_else(|| Statfs::new())
    }

    pub fn get_statfs(&self) -> &Statfs {
        self.statfs.as_ref().unwrap_or_else(|| Statfs::default_instance())
    }

    fn get_statfs_for_reflect(&self) -> &::protobuf::SingularPtrField<Statfs> {
        &self.statfs
    }

    fn mut_statfs_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Statfs> {
        &mut self.statfs
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for statfsResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statfs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statfs)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.statfs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.statfs.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for statfsResponse {
    fn new() -> statfsResponse {
        statfsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<statfsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    statfsResponse::get_result_for_reflect,
                    statfsResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Statfs>>(
                    "statfs",
                    statfsResponse::get_statfs_for_reflect,
                    statfsResponse::mut_statfs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    statfsResponse::get_extra_data_for_reflect,
                    statfsResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<statfsResponse>(
                    "statfsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for statfsResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_statfs();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for statfsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for statfsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct lkRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<i64>,
    cmd: ::std::option::Option<u32>,
    field_type: ::std::option::Option<u32>,
    flock: ::protobuf::SingularPtrField<ProtoFlock>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for lkRequest {}

impl lkRequest {
    pub fn new() -> lkRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static lkRequest {
        static mut instance: ::protobuf::lazy::Lazy<lkRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const lkRequest,
        };
        unsafe {
            instance.get(lkRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required int64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: i64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> i64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.fd
    }

    // required uint32 cmd = 3;

    pub fn clear_cmd(&mut self) {
        self.cmd = ::std::option::Option::None;
    }

    pub fn has_cmd(&self) -> bool {
        self.cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd(&mut self, v: u32) {
        self.cmd = ::std::option::Option::Some(v);
    }

    pub fn get_cmd(&self) -> u32 {
        self.cmd.unwrap_or(0)
    }

    fn get_cmd_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cmd
    }

    fn mut_cmd_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cmd
    }

    // required uint32 type = 4;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.field_type
    }

    // required .rusix.ProtoFlock flock = 5;

    pub fn clear_flock(&mut self) {
        self.flock.clear();
    }

    pub fn has_flock(&self) -> bool {
        self.flock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flock(&mut self, v: ProtoFlock) {
        self.flock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flock(&mut self) -> &mut ProtoFlock {
        if self.flock.is_none() {
            self.flock.set_default();
        }
        self.flock.as_mut().unwrap()
    }

    // Take field
    pub fn take_flock(&mut self) -> ProtoFlock {
        self.flock.take().unwrap_or_else(|| ProtoFlock::new())
    }

    pub fn get_flock(&self) -> &ProtoFlock {
        self.flock.as_ref().unwrap_or_else(|| ProtoFlock::default_instance())
    }

    fn get_flock_for_reflect(&self) -> &::protobuf::SingularPtrField<ProtoFlock> {
        &self.flock
    }

    fn mut_flock_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ProtoFlock> {
        &mut self.flock
    }

    // optional bytes extra_data = 6;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for lkRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        if self.cmd.is_none() {
            return false;
        }
        if self.field_type.is_none() {
            return false;
        }
        if self.flock.is_none() {
            return false;
        }
        for v in &self.flock {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cmd = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flock)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cmd {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.flock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.cmd {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.flock.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for lkRequest {
    fn new() -> lkRequest {
        lkRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<lkRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    lkRequest::get_gfid_for_reflect,
                    lkRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fd",
                    lkRequest::get_fd_for_reflect,
                    lkRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cmd",
                    lkRequest::get_cmd_for_reflect,
                    lkRequest::mut_cmd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    lkRequest::get_field_type_for_reflect,
                    lkRequest::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProtoFlock>>(
                    "flock",
                    lkRequest::get_flock_for_reflect,
                    lkRequest::mut_flock_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    lkRequest::get_extra_data_for_reflect,
                    lkRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<lkRequest>(
                    "lkRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for lkRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_cmd();
        self.clear_field_type();
        self.clear_flock();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for lkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for lkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct lkResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    flock: ::protobuf::SingularPtrField<ProtoFlock>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for lkResponse {}

impl lkResponse {
    pub fn new() -> lkResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static lkResponse {
        static mut instance: ::protobuf::lazy::Lazy<lkResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const lkResponse,
        };
        unsafe {
            instance.get(lkResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.ProtoFlock flock = 2;

    pub fn clear_flock(&mut self) {
        self.flock.clear();
    }

    pub fn has_flock(&self) -> bool {
        self.flock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flock(&mut self, v: ProtoFlock) {
        self.flock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flock(&mut self) -> &mut ProtoFlock {
        if self.flock.is_none() {
            self.flock.set_default();
        }
        self.flock.as_mut().unwrap()
    }

    // Take field
    pub fn take_flock(&mut self) -> ProtoFlock {
        self.flock.take().unwrap_or_else(|| ProtoFlock::new())
    }

    pub fn get_flock(&self) -> &ProtoFlock {
        self.flock.as_ref().unwrap_or_else(|| ProtoFlock::default_instance())
    }

    fn get_flock_for_reflect(&self) -> &::protobuf::SingularPtrField<ProtoFlock> {
        &self.flock
    }

    fn mut_flock_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ProtoFlock> {
        &mut self.flock
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for lkResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flock {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flock)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.flock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.flock.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for lkResponse {
    fn new() -> lkResponse {
        lkResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<lkResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    lkResponse::get_result_for_reflect,
                    lkResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProtoFlock>>(
                    "flock",
                    lkResponse::get_flock_for_reflect,
                    lkResponse::mut_flock_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    lkResponse::get_extra_data_for_reflect,
                    lkResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<lkResponse>(
                    "lkResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for lkResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_flock();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for lkResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for lkResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct leaseRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    lease: ::protobuf::SingularPtrField<ProtoLease>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for leaseRequest {}

impl leaseRequest {
    pub fn new() -> leaseRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static leaseRequest {
        static mut instance: ::protobuf::lazy::Lazy<leaseRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const leaseRequest,
        };
        unsafe {
            instance.get(leaseRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required .rusix.ProtoLease lease = 2;

    pub fn clear_lease(&mut self) {
        self.lease.clear();
    }

    pub fn has_lease(&self) -> bool {
        self.lease.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lease(&mut self, v: ProtoLease) {
        self.lease = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lease(&mut self) -> &mut ProtoLease {
        if self.lease.is_none() {
            self.lease.set_default();
        }
        self.lease.as_mut().unwrap()
    }

    // Take field
    pub fn take_lease(&mut self) -> ProtoLease {
        self.lease.take().unwrap_or_else(|| ProtoLease::new())
    }

    pub fn get_lease(&self) -> &ProtoLease {
        self.lease.as_ref().unwrap_or_else(|| ProtoLease::default_instance())
    }

    fn get_lease_for_reflect(&self) -> &::protobuf::SingularPtrField<ProtoLease> {
        &self.lease
    }

    fn mut_lease_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ProtoLease> {
        &mut self.lease
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for leaseRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.lease.is_none() {
            return false;
        }
        for v in &self.lease {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lease)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.lease.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.lease.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for leaseRequest {
    fn new() -> leaseRequest {
        leaseRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<leaseRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    leaseRequest::get_gfid_for_reflect,
                    leaseRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProtoLease>>(
                    "lease",
                    leaseRequest::get_lease_for_reflect,
                    leaseRequest::mut_lease_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    leaseRequest::get_extra_data_for_reflect,
                    leaseRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<leaseRequest>(
                    "leaseRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for leaseRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_lease();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for leaseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for leaseRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct leaseResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    lease: ::protobuf::SingularPtrField<ProtoLease>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for leaseResponse {}

impl leaseResponse {
    pub fn new() -> leaseResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static leaseResponse {
        static mut instance: ::protobuf::lazy::Lazy<leaseResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const leaseResponse,
        };
        unsafe {
            instance.get(leaseResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.ProtoLease lease = 2;

    pub fn clear_lease(&mut self) {
        self.lease.clear();
    }

    pub fn has_lease(&self) -> bool {
        self.lease.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lease(&mut self, v: ProtoLease) {
        self.lease = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lease(&mut self) -> &mut ProtoLease {
        if self.lease.is_none() {
            self.lease.set_default();
        }
        self.lease.as_mut().unwrap()
    }

    // Take field
    pub fn take_lease(&mut self) -> ProtoLease {
        self.lease.take().unwrap_or_else(|| ProtoLease::new())
    }

    pub fn get_lease(&self) -> &ProtoLease {
        self.lease.as_ref().unwrap_or_else(|| ProtoLease::default_instance())
    }

    fn get_lease_for_reflect(&self) -> &::protobuf::SingularPtrField<ProtoLease> {
        &self.lease
    }

    fn mut_lease_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ProtoLease> {
        &mut self.lease
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for leaseResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lease {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lease)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lease.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lease.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for leaseResponse {
    fn new() -> leaseResponse {
        leaseResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<leaseResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    leaseResponse::get_result_for_reflect,
                    leaseResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProtoLease>>(
                    "lease",
                    leaseResponse::get_lease_for_reflect,
                    leaseResponse::mut_lease_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    leaseResponse::get_extra_data_for_reflect,
                    leaseResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<leaseResponse>(
                    "leaseResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for leaseResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_lease();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for leaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for leaseResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct recall_leaseRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    lease_type: ::std::option::Option<u32>,
    tid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for recall_leaseRequest {}

impl recall_leaseRequest {
    pub fn new() -> recall_leaseRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static recall_leaseRequest {
        static mut instance: ::protobuf::lazy::Lazy<recall_leaseRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const recall_leaseRequest,
        };
        unsafe {
            instance.get(recall_leaseRequest::new)
        }
    }

    // required bytes gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::vec::Vec<u8>) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::vec::Vec<u8> {
        self.gfid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_gfid(&self) -> &[u8] {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.gfid
    }

    // required uint32 lease_type = 2;

    pub fn clear_lease_type(&mut self) {
        self.lease_type = ::std::option::Option::None;
    }

    pub fn has_lease_type(&self) -> bool {
        self.lease_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lease_type(&mut self, v: u32) {
        self.lease_type = ::std::option::Option::Some(v);
    }

    pub fn get_lease_type(&self) -> u32 {
        self.lease_type.unwrap_or(0)
    }

    fn get_lease_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.lease_type
    }

    fn mut_lease_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.lease_type
    }

    // required bytes tid = 3;

    pub fn clear_tid(&mut self) {
        self.tid.clear();
    }

    pub fn has_tid(&self) -> bool {
        self.tid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tid(&mut self, v: ::std::vec::Vec<u8>) {
        self.tid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tid.is_none() {
            self.tid.set_default();
        }
        self.tid.as_mut().unwrap()
    }

    // Take field
    pub fn take_tid(&mut self) -> ::std::vec::Vec<u8> {
        self.tid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_tid(&self) -> &[u8] {
        match self.tid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_tid_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.tid
    }

    fn mut_tid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.tid
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for recall_leaseRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.lease_type.is_none() {
            return false;
        }
        if self.tid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lease_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.tid)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.lease_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.lease_type {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.tid.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for recall_leaseRequest {
    fn new() -> recall_leaseRequest {
        recall_leaseRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<recall_leaseRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "gfid",
                    recall_leaseRequest::get_gfid_for_reflect,
                    recall_leaseRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lease_type",
                    recall_leaseRequest::get_lease_type_for_reflect,
                    recall_leaseRequest::mut_lease_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "tid",
                    recall_leaseRequest::get_tid_for_reflect,
                    recall_leaseRequest::mut_tid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    recall_leaseRequest::get_extra_data_for_reflect,
                    recall_leaseRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<recall_leaseRequest>(
                    "recall_leaseRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for recall_leaseRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_lease_type();
        self.clear_tid();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for recall_leaseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for recall_leaseRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct inodelkRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    cmd: ::std::option::Option<u32>,
    field_type: ::std::option::Option<u32>,
    flock: ::protobuf::SingularPtrField<ProtoFlock>,
    volume: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for inodelkRequest {}

impl inodelkRequest {
    pub fn new() -> inodelkRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static inodelkRequest {
        static mut instance: ::protobuf::lazy::Lazy<inodelkRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const inodelkRequest,
        };
        unsafe {
            instance.get(inodelkRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint32 cmd = 2;

    pub fn clear_cmd(&mut self) {
        self.cmd = ::std::option::Option::None;
    }

    pub fn has_cmd(&self) -> bool {
        self.cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd(&mut self, v: u32) {
        self.cmd = ::std::option::Option::Some(v);
    }

    pub fn get_cmd(&self) -> u32 {
        self.cmd.unwrap_or(0)
    }

    fn get_cmd_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cmd
    }

    fn mut_cmd_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cmd
    }

    // required uint32 type = 3;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.field_type
    }

    // required .rusix.ProtoFlock flock = 4;

    pub fn clear_flock(&mut self) {
        self.flock.clear();
    }

    pub fn has_flock(&self) -> bool {
        self.flock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flock(&mut self, v: ProtoFlock) {
        self.flock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flock(&mut self) -> &mut ProtoFlock {
        if self.flock.is_none() {
            self.flock.set_default();
        }
        self.flock.as_mut().unwrap()
    }

    // Take field
    pub fn take_flock(&mut self) -> ProtoFlock {
        self.flock.take().unwrap_or_else(|| ProtoFlock::new())
    }

    pub fn get_flock(&self) -> &ProtoFlock {
        self.flock.as_ref().unwrap_or_else(|| ProtoFlock::default_instance())
    }

    fn get_flock_for_reflect(&self) -> &::protobuf::SingularPtrField<ProtoFlock> {
        &self.flock
    }

    fn mut_flock_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ProtoFlock> {
        &mut self.flock
    }

    // required string volume = 5;

    pub fn clear_volume(&mut self) {
        self.volume.clear();
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: ::std::string::String) {
        self.volume = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume(&mut self) -> &mut ::std::string::String {
        if self.volume.is_none() {
            self.volume.set_default();
        }
        self.volume.as_mut().unwrap()
    }

    // Take field
    pub fn take_volume(&mut self) -> ::std::string::String {
        self.volume.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_volume(&self) -> &str {
        match self.volume.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_volume_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.volume
    }

    fn mut_volume_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.volume
    }

    // optional bytes extra_data = 6;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for inodelkRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.cmd.is_none() {
            return false;
        }
        if self.field_type.is_none() {
            return false;
        }
        if self.flock.is_none() {
            return false;
        }
        if self.volume.is_none() {
            return false;
        }
        for v in &self.flock {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cmd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flock)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volume)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.cmd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.flock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.volume.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.cmd {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.flock.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.volume.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for inodelkRequest {
    fn new() -> inodelkRequest {
        inodelkRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<inodelkRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    inodelkRequest::get_gfid_for_reflect,
                    inodelkRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cmd",
                    inodelkRequest::get_cmd_for_reflect,
                    inodelkRequest::mut_cmd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    inodelkRequest::get_field_type_for_reflect,
                    inodelkRequest::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProtoFlock>>(
                    "flock",
                    inodelkRequest::get_flock_for_reflect,
                    inodelkRequest::mut_flock_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "volume",
                    inodelkRequest::get_volume_for_reflect,
                    inodelkRequest::mut_volume_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    inodelkRequest::get_extra_data_for_reflect,
                    inodelkRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<inodelkRequest>(
                    "inodelkRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for inodelkRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_cmd();
        self.clear_field_type();
        self.clear_flock();
        self.clear_volume();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for inodelkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for inodelkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct finodelkRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<u64>,
    cmd: ::std::option::Option<u32>,
    field_type: ::std::option::Option<u32>,
    flock: ::protobuf::SingularPtrField<ProtoFlock>,
    volume: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for finodelkRequest {}

impl finodelkRequest {
    pub fn new() -> finodelkRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static finodelkRequest {
        static mut instance: ::protobuf::lazy::Lazy<finodelkRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const finodelkRequest,
        };
        unsafe {
            instance.get(finodelkRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // required uint32 cmd = 3;

    pub fn clear_cmd(&mut self) {
        self.cmd = ::std::option::Option::None;
    }

    pub fn has_cmd(&self) -> bool {
        self.cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd(&mut self, v: u32) {
        self.cmd = ::std::option::Option::Some(v);
    }

    pub fn get_cmd(&self) -> u32 {
        self.cmd.unwrap_or(0)
    }

    fn get_cmd_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cmd
    }

    fn mut_cmd_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cmd
    }

    // required uint32 type = 4;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.field_type
    }

    // required .rusix.ProtoFlock flock = 5;

    pub fn clear_flock(&mut self) {
        self.flock.clear();
    }

    pub fn has_flock(&self) -> bool {
        self.flock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flock(&mut self, v: ProtoFlock) {
        self.flock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flock(&mut self) -> &mut ProtoFlock {
        if self.flock.is_none() {
            self.flock.set_default();
        }
        self.flock.as_mut().unwrap()
    }

    // Take field
    pub fn take_flock(&mut self) -> ProtoFlock {
        self.flock.take().unwrap_or_else(|| ProtoFlock::new())
    }

    pub fn get_flock(&self) -> &ProtoFlock {
        self.flock.as_ref().unwrap_or_else(|| ProtoFlock::default_instance())
    }

    fn get_flock_for_reflect(&self) -> &::protobuf::SingularPtrField<ProtoFlock> {
        &self.flock
    }

    fn mut_flock_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ProtoFlock> {
        &mut self.flock
    }

    // required string volume = 6;

    pub fn clear_volume(&mut self) {
        self.volume.clear();
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: ::std::string::String) {
        self.volume = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume(&mut self) -> &mut ::std::string::String {
        if self.volume.is_none() {
            self.volume.set_default();
        }
        self.volume.as_mut().unwrap()
    }

    // Take field
    pub fn take_volume(&mut self) -> ::std::string::String {
        self.volume.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_volume(&self) -> &str {
        match self.volume.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_volume_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.volume
    }

    fn mut_volume_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.volume
    }

    // optional bytes extra_data = 7;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for finodelkRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        if self.cmd.is_none() {
            return false;
        }
        if self.field_type.is_none() {
            return false;
        }
        if self.flock.is_none() {
            return false;
        }
        if self.volume.is_none() {
            return false;
        }
        for v in &self.flock {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cmd = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flock)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volume)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cmd {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.flock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.volume.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.cmd {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.flock.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.volume.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for finodelkRequest {
    fn new() -> finodelkRequest {
        finodelkRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<finodelkRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    finodelkRequest::get_gfid_for_reflect,
                    finodelkRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    finodelkRequest::get_fd_for_reflect,
                    finodelkRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cmd",
                    finodelkRequest::get_cmd_for_reflect,
                    finodelkRequest::mut_cmd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    finodelkRequest::get_field_type_for_reflect,
                    finodelkRequest::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProtoFlock>>(
                    "flock",
                    finodelkRequest::get_flock_for_reflect,
                    finodelkRequest::mut_flock_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "volume",
                    finodelkRequest::get_volume_for_reflect,
                    finodelkRequest::mut_volume_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    finodelkRequest::get_extra_data_for_reflect,
                    finodelkRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<finodelkRequest>(
                    "finodelkRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for finodelkRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_cmd();
        self.clear_field_type();
        self.clear_flock();
        self.clear_volume();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for finodelkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for finodelkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct flushRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<u64>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for flushRequest {}

impl flushRequest {
    pub fn new() -> flushRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static flushRequest {
        static mut instance: ::protobuf::lazy::Lazy<flushRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const flushRequest,
        };
        unsafe {
            instance.get(flushRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for flushRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for flushRequest {
    fn new() -> flushRequest {
        flushRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<flushRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    flushRequest::get_gfid_for_reflect,
                    flushRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    flushRequest::get_fd_for_reflect,
                    flushRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    flushRequest::get_extra_data_for_reflect,
                    flushRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<flushRequest>(
                    "flushRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for flushRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for flushRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for flushRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct fsyncRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<u64>,
    data: ::std::option::Option<u32>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for fsyncRequest {}

impl fsyncRequest {
    pub fn new() -> fsyncRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static fsyncRequest {
        static mut instance: ::protobuf::lazy::Lazy<fsyncRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const fsyncRequest,
        };
        unsafe {
            instance.get(fsyncRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // required uint32 data = 3;

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: u32) {
        self.data = ::std::option::Option::Some(v);
    }

    pub fn get_data(&self) -> u32 {
        self.data.unwrap_or(0)
    }

    fn get_data_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.data
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for fsyncRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        if self.data.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.data = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.data {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.data {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for fsyncRequest {
    fn new() -> fsyncRequest {
        fsyncRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<fsyncRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    fsyncRequest::get_gfid_for_reflect,
                    fsyncRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    fsyncRequest::get_fd_for_reflect,
                    fsyncRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "data",
                    fsyncRequest::get_data_for_reflect,
                    fsyncRequest::mut_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    fsyncRequest::get_extra_data_for_reflect,
                    fsyncRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<fsyncRequest>(
                    "fsyncRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for fsyncRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_data();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for fsyncRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for fsyncRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct fsyncResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    prestat: ::protobuf::SingularPtrField<Iatt>,
    poststat: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for fsyncResponse {}

impl fsyncResponse {
    pub fn new() -> fsyncResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static fsyncResponse {
        static mut instance: ::protobuf::lazy::Lazy<fsyncResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const fsyncResponse,
        };
        unsafe {
            instance.get(fsyncResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt prestat = 2;

    pub fn clear_prestat(&mut self) {
        self.prestat.clear();
    }

    pub fn has_prestat(&self) -> bool {
        self.prestat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prestat(&mut self, v: Iatt) {
        self.prestat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prestat(&mut self) -> &mut Iatt {
        if self.prestat.is_none() {
            self.prestat.set_default();
        }
        self.prestat.as_mut().unwrap()
    }

    // Take field
    pub fn take_prestat(&mut self) -> Iatt {
        self.prestat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_prestat(&self) -> &Iatt {
        self.prestat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_prestat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.prestat
    }

    fn mut_prestat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.prestat
    }

    // optional .rusix.Iatt poststat = 3;

    pub fn clear_poststat(&mut self) {
        self.poststat.clear();
    }

    pub fn has_poststat(&self) -> bool {
        self.poststat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poststat(&mut self, v: Iatt) {
        self.poststat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poststat(&mut self) -> &mut Iatt {
        if self.poststat.is_none() {
            self.poststat.set_default();
        }
        self.poststat.as_mut().unwrap()
    }

    // Take field
    pub fn take_poststat(&mut self) -> Iatt {
        self.poststat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_poststat(&self) -> &Iatt {
        self.poststat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_poststat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.poststat
    }

    fn mut_poststat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.poststat
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for fsyncResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prestat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.poststat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.prestat)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.poststat)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.prestat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.poststat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.prestat.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.poststat.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for fsyncResponse {
    fn new() -> fsyncResponse {
        fsyncResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<fsyncResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    fsyncResponse::get_result_for_reflect,
                    fsyncResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "prestat",
                    fsyncResponse::get_prestat_for_reflect,
                    fsyncResponse::mut_prestat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "poststat",
                    fsyncResponse::get_poststat_for_reflect,
                    fsyncResponse::mut_poststat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    fsyncResponse::get_extra_data_for_reflect,
                    fsyncResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<fsyncResponse>(
                    "fsyncResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for fsyncResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_prestat();
        self.clear_poststat();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for fsyncResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for fsyncResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setxattrRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    flags: ::std::option::Option<u32>,
    dict: ::protobuf::SingularPtrField<Dict>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setxattrRequest {}

impl setxattrRequest {
    pub fn new() -> setxattrRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setxattrRequest {
        static mut instance: ::protobuf::lazy::Lazy<setxattrRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setxattrRequest,
        };
        unsafe {
            instance.get(setxattrRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint32 flags = 2;

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    fn get_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.flags
    }

    fn mut_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.flags
    }

    // required .rusix.Dict dict = 3;

    pub fn clear_dict(&mut self) {
        self.dict.clear();
    }

    pub fn has_dict(&self) -> bool {
        self.dict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dict(&mut self, v: Dict) {
        self.dict = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dict(&mut self) -> &mut Dict {
        if self.dict.is_none() {
            self.dict.set_default();
        }
        self.dict.as_mut().unwrap()
    }

    // Take field
    pub fn take_dict(&mut self) -> Dict {
        self.dict.take().unwrap_or_else(|| Dict::new())
    }

    pub fn get_dict(&self) -> &Dict {
        self.dict.as_ref().unwrap_or_else(|| Dict::default_instance())
    }

    fn get_dict_for_reflect(&self) -> &::protobuf::SingularPtrField<Dict> {
        &self.dict
    }

    fn mut_dict_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Dict> {
        &mut self.dict
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for setxattrRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.flags.is_none() {
            return false;
        }
        if self.dict.is_none() {
            return false;
        }
        for v in &self.dict {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dict)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.dict.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.dict.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setxattrRequest {
    fn new() -> setxattrRequest {
        setxattrRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<setxattrRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    setxattrRequest::get_gfid_for_reflect,
                    setxattrRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    setxattrRequest::get_flags_for_reflect,
                    setxattrRequest::mut_flags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dict>>(
                    "dict",
                    setxattrRequest::get_dict_for_reflect,
                    setxattrRequest::mut_dict_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    setxattrRequest::get_extra_data_for_reflect,
                    setxattrRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<setxattrRequest>(
                    "setxattrRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setxattrRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_flags();
        self.clear_dict();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setxattrRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setxattrRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct fsetxattrRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<i64>,
    flags: ::std::option::Option<u32>,
    dict: ::protobuf::SingularPtrField<Dict>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for fsetxattrRequest {}

impl fsetxattrRequest {
    pub fn new() -> fsetxattrRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static fsetxattrRequest {
        static mut instance: ::protobuf::lazy::Lazy<fsetxattrRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const fsetxattrRequest,
        };
        unsafe {
            instance.get(fsetxattrRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required int64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: i64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> i64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.fd
    }

    // required uint32 flags = 3;

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    fn get_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.flags
    }

    fn mut_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.flags
    }

    // required .rusix.Dict dict = 4;

    pub fn clear_dict(&mut self) {
        self.dict.clear();
    }

    pub fn has_dict(&self) -> bool {
        self.dict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dict(&mut self, v: Dict) {
        self.dict = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dict(&mut self) -> &mut Dict {
        if self.dict.is_none() {
            self.dict.set_default();
        }
        self.dict.as_mut().unwrap()
    }

    // Take field
    pub fn take_dict(&mut self) -> Dict {
        self.dict.take().unwrap_or_else(|| Dict::new())
    }

    pub fn get_dict(&self) -> &Dict {
        self.dict.as_ref().unwrap_or_else(|| Dict::default_instance())
    }

    fn get_dict_for_reflect(&self) -> &::protobuf::SingularPtrField<Dict> {
        &self.dict
    }

    fn mut_dict_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Dict> {
        &mut self.dict
    }

    // optional bytes extra_data = 5;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for fsetxattrRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        if self.flags.is_none() {
            return false;
        }
        if self.dict.is_none() {
            return false;
        }
        for v in &self.dict {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dict)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.dict.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.dict.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for fsetxattrRequest {
    fn new() -> fsetxattrRequest {
        fsetxattrRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<fsetxattrRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    fsetxattrRequest::get_gfid_for_reflect,
                    fsetxattrRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fd",
                    fsetxattrRequest::get_fd_for_reflect,
                    fsetxattrRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    fsetxattrRequest::get_flags_for_reflect,
                    fsetxattrRequest::mut_flags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dict>>(
                    "dict",
                    fsetxattrRequest::get_dict_for_reflect,
                    fsetxattrRequest::mut_dict_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    fsetxattrRequest::get_extra_data_for_reflect,
                    fsetxattrRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<fsetxattrRequest>(
                    "fsetxattrRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for fsetxattrRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_flags();
        self.clear_dict();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for fsetxattrRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for fsetxattrRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct xattropRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    flags: ::std::option::Option<u32>,
    dict: ::protobuf::SingularPtrField<Dict>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for xattropRequest {}

impl xattropRequest {
    pub fn new() -> xattropRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static xattropRequest {
        static mut instance: ::protobuf::lazy::Lazy<xattropRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const xattropRequest,
        };
        unsafe {
            instance.get(xattropRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint32 flags = 2;

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    fn get_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.flags
    }

    fn mut_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.flags
    }

    // required .rusix.Dict dict = 3;

    pub fn clear_dict(&mut self) {
        self.dict.clear();
    }

    pub fn has_dict(&self) -> bool {
        self.dict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dict(&mut self, v: Dict) {
        self.dict = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dict(&mut self) -> &mut Dict {
        if self.dict.is_none() {
            self.dict.set_default();
        }
        self.dict.as_mut().unwrap()
    }

    // Take field
    pub fn take_dict(&mut self) -> Dict {
        self.dict.take().unwrap_or_else(|| Dict::new())
    }

    pub fn get_dict(&self) -> &Dict {
        self.dict.as_ref().unwrap_or_else(|| Dict::default_instance())
    }

    fn get_dict_for_reflect(&self) -> &::protobuf::SingularPtrField<Dict> {
        &self.dict
    }

    fn mut_dict_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Dict> {
        &mut self.dict
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for xattropRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.flags.is_none() {
            return false;
        }
        if self.dict.is_none() {
            return false;
        }
        for v in &self.dict {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dict)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.dict.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.dict.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for xattropRequest {
    fn new() -> xattropRequest {
        xattropRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<xattropRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    xattropRequest::get_gfid_for_reflect,
                    xattropRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    xattropRequest::get_flags_for_reflect,
                    xattropRequest::mut_flags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dict>>(
                    "dict",
                    xattropRequest::get_dict_for_reflect,
                    xattropRequest::mut_dict_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    xattropRequest::get_extra_data_for_reflect,
                    xattropRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<xattropRequest>(
                    "xattropRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for xattropRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_flags();
        self.clear_dict();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for xattropRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for xattropRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct xattropResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    dict: ::protobuf::SingularPtrField<Dict>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for xattropResponse {}

impl xattropResponse {
    pub fn new() -> xattropResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static xattropResponse {
        static mut instance: ::protobuf::lazy::Lazy<xattropResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const xattropResponse,
        };
        unsafe {
            instance.get(xattropResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Dict dict = 2;

    pub fn clear_dict(&mut self) {
        self.dict.clear();
    }

    pub fn has_dict(&self) -> bool {
        self.dict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dict(&mut self, v: Dict) {
        self.dict = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dict(&mut self) -> &mut Dict {
        if self.dict.is_none() {
            self.dict.set_default();
        }
        self.dict.as_mut().unwrap()
    }

    // Take field
    pub fn take_dict(&mut self) -> Dict {
        self.dict.take().unwrap_or_else(|| Dict::new())
    }

    pub fn get_dict(&self) -> &Dict {
        self.dict.as_ref().unwrap_or_else(|| Dict::default_instance())
    }

    fn get_dict_for_reflect(&self) -> &::protobuf::SingularPtrField<Dict> {
        &self.dict
    }

    fn mut_dict_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Dict> {
        &mut self.dict
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for xattropResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dict {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dict)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dict.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dict.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for xattropResponse {
    fn new() -> xattropResponse {
        xattropResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<xattropResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    xattropResponse::get_result_for_reflect,
                    xattropResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dict>>(
                    "dict",
                    xattropResponse::get_dict_for_reflect,
                    xattropResponse::mut_dict_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    xattropResponse::get_extra_data_for_reflect,
                    xattropResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<xattropResponse>(
                    "xattropResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for xattropResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_dict();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for xattropResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for xattropResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct fxattropRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<u64>,
    flags: ::std::option::Option<u32>,
    dict: ::protobuf::SingularPtrField<Dict>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for fxattropRequest {}

impl fxattropRequest {
    pub fn new() -> fxattropRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static fxattropRequest {
        static mut instance: ::protobuf::lazy::Lazy<fxattropRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const fxattropRequest,
        };
        unsafe {
            instance.get(fxattropRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // required uint32 flags = 3;

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    fn get_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.flags
    }

    fn mut_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.flags
    }

    // required .rusix.Dict dict = 4;

    pub fn clear_dict(&mut self) {
        self.dict.clear();
    }

    pub fn has_dict(&self) -> bool {
        self.dict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dict(&mut self, v: Dict) {
        self.dict = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dict(&mut self) -> &mut Dict {
        if self.dict.is_none() {
            self.dict.set_default();
        }
        self.dict.as_mut().unwrap()
    }

    // Take field
    pub fn take_dict(&mut self) -> Dict {
        self.dict.take().unwrap_or_else(|| Dict::new())
    }

    pub fn get_dict(&self) -> &Dict {
        self.dict.as_ref().unwrap_or_else(|| Dict::default_instance())
    }

    fn get_dict_for_reflect(&self) -> &::protobuf::SingularPtrField<Dict> {
        &self.dict
    }

    fn mut_dict_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Dict> {
        &mut self.dict
    }

    // optional bytes extra_data = 5;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for fxattropRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        if self.flags.is_none() {
            return false;
        }
        if self.dict.is_none() {
            return false;
        }
        for v in &self.dict {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dict)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.dict.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.dict.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for fxattropRequest {
    fn new() -> fxattropRequest {
        fxattropRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<fxattropRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    fxattropRequest::get_gfid_for_reflect,
                    fxattropRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    fxattropRequest::get_fd_for_reflect,
                    fxattropRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    fxattropRequest::get_flags_for_reflect,
                    fxattropRequest::mut_flags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dict>>(
                    "dict",
                    fxattropRequest::get_dict_for_reflect,
                    fxattropRequest::mut_dict_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    fxattropRequest::get_extra_data_for_reflect,
                    fxattropRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<fxattropRequest>(
                    "fxattropRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for fxattropRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_flags();
        self.clear_dict();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for fxattropRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for fxattropRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct fxattropResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    dict: ::protobuf::SingularPtrField<Dict>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for fxattropResponse {}

impl fxattropResponse {
    pub fn new() -> fxattropResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static fxattropResponse {
        static mut instance: ::protobuf::lazy::Lazy<fxattropResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const fxattropResponse,
        };
        unsafe {
            instance.get(fxattropResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Dict dict = 2;

    pub fn clear_dict(&mut self) {
        self.dict.clear();
    }

    pub fn has_dict(&self) -> bool {
        self.dict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dict(&mut self, v: Dict) {
        self.dict = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dict(&mut self) -> &mut Dict {
        if self.dict.is_none() {
            self.dict.set_default();
        }
        self.dict.as_mut().unwrap()
    }

    // Take field
    pub fn take_dict(&mut self) -> Dict {
        self.dict.take().unwrap_or_else(|| Dict::new())
    }

    pub fn get_dict(&self) -> &Dict {
        self.dict.as_ref().unwrap_or_else(|| Dict::default_instance())
    }

    fn get_dict_for_reflect(&self) -> &::protobuf::SingularPtrField<Dict> {
        &self.dict
    }

    fn mut_dict_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Dict> {
        &mut self.dict
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for fxattropResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dict {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dict)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dict.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dict.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for fxattropResponse {
    fn new() -> fxattropResponse {
        fxattropResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<fxattropResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    fxattropResponse::get_result_for_reflect,
                    fxattropResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dict>>(
                    "dict",
                    fxattropResponse::get_dict_for_reflect,
                    fxattropResponse::mut_dict_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    fxattropResponse::get_extra_data_for_reflect,
                    fxattropResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<fxattropResponse>(
                    "fxattropResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for fxattropResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_dict();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for fxattropResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for fxattropResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getxattrRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    namelen: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getxattrRequest {}

impl getxattrRequest {
    pub fn new() -> getxattrRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getxattrRequest {
        static mut instance: ::protobuf::lazy::Lazy<getxattrRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getxattrRequest,
        };
        unsafe {
            instance.get(getxattrRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint32 namelen = 2;

    pub fn clear_namelen(&mut self) {
        self.namelen = ::std::option::Option::None;
    }

    pub fn has_namelen(&self) -> bool {
        self.namelen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namelen(&mut self, v: u32) {
        self.namelen = ::std::option::Option::Some(v);
    }

    pub fn get_namelen(&self) -> u32 {
        self.namelen.unwrap_or(0)
    }

    fn get_namelen_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.namelen
    }

    fn mut_namelen_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.namelen
    }

    // required string name = 3;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for getxattrRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.namelen.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.namelen = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.namelen {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.namelen {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getxattrRequest {
    fn new() -> getxattrRequest {
        getxattrRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<getxattrRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    getxattrRequest::get_gfid_for_reflect,
                    getxattrRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "namelen",
                    getxattrRequest::get_namelen_for_reflect,
                    getxattrRequest::mut_namelen_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    getxattrRequest::get_name_for_reflect,
                    getxattrRequest::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    getxattrRequest::get_extra_data_for_reflect,
                    getxattrRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getxattrRequest>(
                    "getxattrRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getxattrRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_namelen();
        self.clear_name();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getxattrRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getxattrRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getxattrResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    dict: ::protobuf::SingularPtrField<Dict>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getxattrResponse {}

impl getxattrResponse {
    pub fn new() -> getxattrResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getxattrResponse {
        static mut instance: ::protobuf::lazy::Lazy<getxattrResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getxattrResponse,
        };
        unsafe {
            instance.get(getxattrResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Dict dict = 2;

    pub fn clear_dict(&mut self) {
        self.dict.clear();
    }

    pub fn has_dict(&self) -> bool {
        self.dict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dict(&mut self, v: Dict) {
        self.dict = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dict(&mut self) -> &mut Dict {
        if self.dict.is_none() {
            self.dict.set_default();
        }
        self.dict.as_mut().unwrap()
    }

    // Take field
    pub fn take_dict(&mut self) -> Dict {
        self.dict.take().unwrap_or_else(|| Dict::new())
    }

    pub fn get_dict(&self) -> &Dict {
        self.dict.as_ref().unwrap_or_else(|| Dict::default_instance())
    }

    fn get_dict_for_reflect(&self) -> &::protobuf::SingularPtrField<Dict> {
        &self.dict
    }

    fn mut_dict_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Dict> {
        &mut self.dict
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for getxattrResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dict {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dict)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dict.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dict.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getxattrResponse {
    fn new() -> getxattrResponse {
        getxattrResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<getxattrResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    getxattrResponse::get_result_for_reflect,
                    getxattrResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dict>>(
                    "dict",
                    getxattrResponse::get_dict_for_reflect,
                    getxattrResponse::mut_dict_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    getxattrResponse::get_extra_data_for_reflect,
                    getxattrResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getxattrResponse>(
                    "getxattrResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getxattrResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_dict();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getxattrResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getxattrResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct fgetxattrRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<u64>,
    namelen: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for fgetxattrRequest {}

impl fgetxattrRequest {
    pub fn new() -> fgetxattrRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static fgetxattrRequest {
        static mut instance: ::protobuf::lazy::Lazy<fgetxattrRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const fgetxattrRequest,
        };
        unsafe {
            instance.get(fgetxattrRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // required uint32 namelen = 3;

    pub fn clear_namelen(&mut self) {
        self.namelen = ::std::option::Option::None;
    }

    pub fn has_namelen(&self) -> bool {
        self.namelen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namelen(&mut self, v: u32) {
        self.namelen = ::std::option::Option::Some(v);
    }

    pub fn get_namelen(&self) -> u32 {
        self.namelen.unwrap_or(0)
    }

    fn get_namelen_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.namelen
    }

    fn mut_namelen_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.namelen
    }

    // required string name = 4;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional bytes extra_data = 5;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for fgetxattrRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        if self.namelen.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.namelen = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.namelen {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.namelen {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for fgetxattrRequest {
    fn new() -> fgetxattrRequest {
        fgetxattrRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<fgetxattrRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    fgetxattrRequest::get_gfid_for_reflect,
                    fgetxattrRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    fgetxattrRequest::get_fd_for_reflect,
                    fgetxattrRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "namelen",
                    fgetxattrRequest::get_namelen_for_reflect,
                    fgetxattrRequest::mut_namelen_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    fgetxattrRequest::get_name_for_reflect,
                    fgetxattrRequest::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    fgetxattrRequest::get_extra_data_for_reflect,
                    fgetxattrRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<fgetxattrRequest>(
                    "fgetxattrRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for fgetxattrRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_namelen();
        self.clear_name();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for fgetxattrRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for fgetxattrRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct fgetxattrResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    dict: ::protobuf::SingularPtrField<Dict>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for fgetxattrResponse {}

impl fgetxattrResponse {
    pub fn new() -> fgetxattrResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static fgetxattrResponse {
        static mut instance: ::protobuf::lazy::Lazy<fgetxattrResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const fgetxattrResponse,
        };
        unsafe {
            instance.get(fgetxattrResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Dict dict = 2;

    pub fn clear_dict(&mut self) {
        self.dict.clear();
    }

    pub fn has_dict(&self) -> bool {
        self.dict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dict(&mut self, v: Dict) {
        self.dict = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dict(&mut self) -> &mut Dict {
        if self.dict.is_none() {
            self.dict.set_default();
        }
        self.dict.as_mut().unwrap()
    }

    // Take field
    pub fn take_dict(&mut self) -> Dict {
        self.dict.take().unwrap_or_else(|| Dict::new())
    }

    pub fn get_dict(&self) -> &Dict {
        self.dict.as_ref().unwrap_or_else(|| Dict::default_instance())
    }

    fn get_dict_for_reflect(&self) -> &::protobuf::SingularPtrField<Dict> {
        &self.dict
    }

    fn mut_dict_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Dict> {
        &mut self.dict
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for fgetxattrResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dict {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dict)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dict.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dict.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for fgetxattrResponse {
    fn new() -> fgetxattrResponse {
        fgetxattrResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<fgetxattrResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    fgetxattrResponse::get_result_for_reflect,
                    fgetxattrResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dict>>(
                    "dict",
                    fgetxattrResponse::get_dict_for_reflect,
                    fgetxattrResponse::mut_dict_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    fgetxattrResponse::get_extra_data_for_reflect,
                    fgetxattrResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<fgetxattrResponse>(
                    "fgetxattrResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for fgetxattrResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_dict();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for fgetxattrResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for fgetxattrResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct removexattrRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for removexattrRequest {}

impl removexattrRequest {
    pub fn new() -> removexattrRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static removexattrRequest {
        static mut instance: ::protobuf::lazy::Lazy<removexattrRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const removexattrRequest,
        };
        unsafe {
            instance.get(removexattrRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for removexattrRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for removexattrRequest {
    fn new() -> removexattrRequest {
        removexattrRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<removexattrRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    removexattrRequest::get_gfid_for_reflect,
                    removexattrRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    removexattrRequest::get_name_for_reflect,
                    removexattrRequest::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    removexattrRequest::get_extra_data_for_reflect,
                    removexattrRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<removexattrRequest>(
                    "removexattrRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for removexattrRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_name();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for removexattrRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for removexattrRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct fremovexattrRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for fremovexattrRequest {}

impl fremovexattrRequest {
    pub fn new() -> fremovexattrRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static fremovexattrRequest {
        static mut instance: ::protobuf::lazy::Lazy<fremovexattrRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const fremovexattrRequest,
        };
        unsafe {
            instance.get(fremovexattrRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // required string name = 3;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for fremovexattrRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for fremovexattrRequest {
    fn new() -> fremovexattrRequest {
        fremovexattrRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<fremovexattrRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    fremovexattrRequest::get_gfid_for_reflect,
                    fremovexattrRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    fremovexattrRequest::get_fd_for_reflect,
                    fremovexattrRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    fremovexattrRequest::get_name_for_reflect,
                    fremovexattrRequest::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    fremovexattrRequest::get_extra_data_for_reflect,
                    fremovexattrRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<fremovexattrRequest>(
                    "fremovexattrRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for fremovexattrRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_name();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for fremovexattrRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for fremovexattrRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct opendirRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for opendirRequest {}

impl opendirRequest {
    pub fn new() -> opendirRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static opendirRequest {
        static mut instance: ::protobuf::lazy::Lazy<opendirRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const opendirRequest,
        };
        unsafe {
            instance.get(opendirRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // optional bytes extra_data = 2;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for opendirRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for opendirRequest {
    fn new() -> opendirRequest {
        opendirRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<opendirRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    opendirRequest::get_gfid_for_reflect,
                    opendirRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    opendirRequest::get_extra_data_for_reflect,
                    opendirRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<opendirRequest>(
                    "opendirRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for opendirRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for opendirRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for opendirRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct opendirResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    fd: ::std::option::Option<u64>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for opendirResponse {}

impl opendirResponse {
    pub fn new() -> opendirResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static opendirResponse {
        static mut instance: ::protobuf::lazy::Lazy<opendirResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const opendirResponse,
        };
        unsafe {
            instance.get(opendirResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for opendirResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for opendirResponse {
    fn new() -> opendirResponse {
        opendirResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<opendirResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    opendirResponse::get_result_for_reflect,
                    opendirResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    opendirResponse::get_fd_for_reflect,
                    opendirResponse::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    opendirResponse::get_extra_data_for_reflect,
                    opendirResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<opendirResponse>(
                    "opendirResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for opendirResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_fd();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for opendirResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for opendirResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct fsyncdirRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<u64>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for fsyncdirRequest {}

impl fsyncdirRequest {
    pub fn new() -> fsyncdirRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static fsyncdirRequest {
        static mut instance: ::protobuf::lazy::Lazy<fsyncdirRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const fsyncdirRequest,
        };
        unsafe {
            instance.get(fsyncdirRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for fsyncdirRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for fsyncdirRequest {
    fn new() -> fsyncdirRequest {
        fsyncdirRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<fsyncdirRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    fsyncdirRequest::get_gfid_for_reflect,
                    fsyncdirRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    fsyncdirRequest::get_fd_for_reflect,
                    fsyncdirRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    fsyncdirRequest::get_extra_data_for_reflect,
                    fsyncdirRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<fsyncdirRequest>(
                    "fsyncdirRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for fsyncdirRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for fsyncdirRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for fsyncdirRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReaddirRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<u64>,
    offset: ::std::option::Option<u64>,
    size: ::std::option::Option<u32>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ReaddirRequest {}

impl ReaddirRequest {
    pub fn new() -> ReaddirRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ReaddirRequest {
        static mut instance: ::protobuf::lazy::Lazy<ReaddirRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReaddirRequest,
        };
        unsafe {
            instance.get(ReaddirRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // required uint64 offset = 3;

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }

    fn get_offset_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.offset
    }

    fn mut_offset_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.offset
    }

    // required uint32 size = 4;

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    pub fn get_size(&self) -> u32 {
        self.size.unwrap_or(0)
    }

    fn get_size_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.size
    }

    fn mut_size_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.size
    }

    // optional bytes extra_data = 5;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for ReaddirRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        if self.size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ReaddirRequest {
    fn new() -> ReaddirRequest {
        ReaddirRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<ReaddirRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    ReaddirRequest::get_gfid_for_reflect,
                    ReaddirRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    ReaddirRequest::get_fd_for_reflect,
                    ReaddirRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "offset",
                    ReaddirRequest::get_offset_for_reflect,
                    ReaddirRequest::mut_offset_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "size",
                    ReaddirRequest::get_size_for_reflect,
                    ReaddirRequest::mut_size_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    ReaddirRequest::get_extra_data_for_reflect,
                    ReaddirRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReaddirRequest>(
                    "ReaddirRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ReaddirRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_offset();
        self.clear_size();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReaddirRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReaddirRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReaddirpRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<u64>,
    offset: ::std::option::Option<u64>,
    size: ::std::option::Option<u32>,
    dict: ::protobuf::SingularPtrField<Dict>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ReaddirpRequest {}

impl ReaddirpRequest {
    pub fn new() -> ReaddirpRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ReaddirpRequest {
        static mut instance: ::protobuf::lazy::Lazy<ReaddirpRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReaddirpRequest,
        };
        unsafe {
            instance.get(ReaddirpRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // required uint64 offset = 3;

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }

    fn get_offset_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.offset
    }

    fn mut_offset_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.offset
    }

    // required uint32 size = 4;

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    pub fn get_size(&self) -> u32 {
        self.size.unwrap_or(0)
    }

    fn get_size_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.size
    }

    fn mut_size_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.size
    }

    // required .rusix.Dict dict = 5;

    pub fn clear_dict(&mut self) {
        self.dict.clear();
    }

    pub fn has_dict(&self) -> bool {
        self.dict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dict(&mut self, v: Dict) {
        self.dict = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dict(&mut self) -> &mut Dict {
        if self.dict.is_none() {
            self.dict.set_default();
        }
        self.dict.as_mut().unwrap()
    }

    // Take field
    pub fn take_dict(&mut self) -> Dict {
        self.dict.take().unwrap_or_else(|| Dict::new())
    }

    pub fn get_dict(&self) -> &Dict {
        self.dict.as_ref().unwrap_or_else(|| Dict::default_instance())
    }

    fn get_dict_for_reflect(&self) -> &::protobuf::SingularPtrField<Dict> {
        &self.dict
    }

    fn mut_dict_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Dict> {
        &mut self.dict
    }
}

impl ::protobuf::Message for ReaddirpRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        if self.size.is_none() {
            return false;
        }
        if self.dict.is_none() {
            return false;
        }
        for v in &self.dict {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dict)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.dict.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.dict.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ReaddirpRequest {
    fn new() -> ReaddirpRequest {
        ReaddirpRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<ReaddirpRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    ReaddirpRequest::get_gfid_for_reflect,
                    ReaddirpRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    ReaddirpRequest::get_fd_for_reflect,
                    ReaddirpRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "offset",
                    ReaddirpRequest::get_offset_for_reflect,
                    ReaddirpRequest::mut_offset_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "size",
                    ReaddirpRequest::get_size_for_reflect,
                    ReaddirpRequest::mut_size_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dict>>(
                    "dict",
                    ReaddirpRequest::get_dict_for_reflect,
                    ReaddirpRequest::mut_dict_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReaddirpRequest>(
                    "ReaddirpRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ReaddirpRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_offset();
        self.clear_size();
        self.clear_dict();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReaddirpRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReaddirpRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct accessRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    mask: ::std::option::Option<u32>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for accessRequest {}

impl accessRequest {
    pub fn new() -> accessRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static accessRequest {
        static mut instance: ::protobuf::lazy::Lazy<accessRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const accessRequest,
        };
        unsafe {
            instance.get(accessRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint32 mask = 2;

    pub fn clear_mask(&mut self) {
        self.mask = ::std::option::Option::None;
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: u32) {
        self.mask = ::std::option::Option::Some(v);
    }

    pub fn get_mask(&self) -> u32 {
        self.mask.unwrap_or(0)
    }

    fn get_mask_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mask
    }

    fn mut_mask_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mask
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for accessRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.mask.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mask = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mask {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.mask {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for accessRequest {
    fn new() -> accessRequest {
        accessRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<accessRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    accessRequest::get_gfid_for_reflect,
                    accessRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mask",
                    accessRequest::get_mask_for_reflect,
                    accessRequest::mut_mask_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    accessRequest::get_extra_data_for_reflect,
                    accessRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<accessRequest>(
                    "accessRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for accessRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_mask();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for accessRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for accessRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct createRequest {
    // message fields
    pargfid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    flags: ::std::option::Option<u32>,
    mode: ::std::option::Option<u32>,
    umask: ::std::option::Option<u32>,
    bname: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for createRequest {}

impl createRequest {
    pub fn new() -> createRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static createRequest {
        static mut instance: ::protobuf::lazy::Lazy<createRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const createRequest,
        };
        unsafe {
            instance.get(createRequest::new)
        }
    }

    // required bytes pargfid = 1;

    pub fn clear_pargfid(&mut self) {
        self.pargfid.clear();
    }

    pub fn has_pargfid(&self) -> bool {
        self.pargfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pargfid(&mut self, v: ::std::vec::Vec<u8>) {
        self.pargfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pargfid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pargfid.is_none() {
            self.pargfid.set_default();
        }
        self.pargfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_pargfid(&mut self) -> ::std::vec::Vec<u8> {
        self.pargfid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_pargfid(&self) -> &[u8] {
        match self.pargfid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_pargfid_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.pargfid
    }

    fn mut_pargfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.pargfid
    }

    // required uint32 flags = 2;

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    fn get_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.flags
    }

    fn mut_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.flags
    }

    // required uint32 mode = 3;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: u32) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode(&self) -> u32 {
        self.mode.unwrap_or(0)
    }

    fn get_mode_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.mode
    }

    fn mut_mode_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.mode
    }

    // required uint32 umask = 4;

    pub fn clear_umask(&mut self) {
        self.umask = ::std::option::Option::None;
    }

    pub fn has_umask(&self) -> bool {
        self.umask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_umask(&mut self, v: u32) {
        self.umask = ::std::option::Option::Some(v);
    }

    pub fn get_umask(&self) -> u32 {
        self.umask.unwrap_or(0)
    }

    fn get_umask_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.umask
    }

    fn mut_umask_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.umask
    }

    // required string bname = 5;

    pub fn clear_bname(&mut self) {
        self.bname.clear();
    }

    pub fn has_bname(&self) -> bool {
        self.bname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bname(&mut self, v: ::std::string::String) {
        self.bname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bname(&mut self) -> &mut ::std::string::String {
        if self.bname.is_none() {
            self.bname.set_default();
        }
        self.bname.as_mut().unwrap()
    }

    // Take field
    pub fn take_bname(&mut self) -> ::std::string::String {
        self.bname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_bname(&self) -> &str {
        match self.bname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_bname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.bname
    }

    fn mut_bname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.bname
    }

    // optional bytes extra_data = 6;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for createRequest {
    fn is_initialized(&self) -> bool {
        if self.pargfid.is_none() {
            return false;
        }
        if self.flags.is_none() {
            return false;
        }
        if self.mode.is_none() {
            return false;
        }
        if self.umask.is_none() {
            return false;
        }
        if self.bname.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pargfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.umask = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bname)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pargfid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.umask {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.bname.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pargfid.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.mode {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.umask {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.bname.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for createRequest {
    fn new() -> createRequest {
        createRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<createRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pargfid",
                    createRequest::get_pargfid_for_reflect,
                    createRequest::mut_pargfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    createRequest::get_flags_for_reflect,
                    createRequest::mut_flags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mode",
                    createRequest::get_mode_for_reflect,
                    createRequest::mut_mode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "umask",
                    createRequest::get_umask_for_reflect,
                    createRequest::mut_umask_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bname",
                    createRequest::get_bname_for_reflect,
                    createRequest::mut_bname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    createRequest::get_extra_data_for_reflect,
                    createRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<createRequest>(
                    "createRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for createRequest {
    fn clear(&mut self) {
        self.clear_pargfid();
        self.clear_flags();
        self.clear_mode();
        self.clear_umask();
        self.clear_bname();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for createRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for createRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    stat: ::protobuf::SingularPtrField<Iatt>,
    fd: ::std::option::Option<u64>,
    preparent: ::protobuf::SingularPtrField<Iatt>,
    postparent: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CreateResponse {}

impl CreateResponse {
    pub fn new() -> CreateResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CreateResponse {
        static mut instance: ::protobuf::lazy::Lazy<CreateResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateResponse,
        };
        unsafe {
            instance.get(CreateResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt stat = 2;

    pub fn clear_stat(&mut self) {
        self.stat.clear();
    }

    pub fn has_stat(&self) -> bool {
        self.stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: Iatt) {
        self.stat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat(&mut self) -> &mut Iatt {
        if self.stat.is_none() {
            self.stat.set_default();
        }
        self.stat.as_mut().unwrap()
    }

    // Take field
    pub fn take_stat(&mut self) -> Iatt {
        self.stat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_stat(&self) -> &Iatt {
        self.stat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_stat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.stat
    }

    fn mut_stat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.stat
    }

    // optional uint64 fd = 3;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // optional .rusix.Iatt preparent = 4;

    pub fn clear_preparent(&mut self) {
        self.preparent.clear();
    }

    pub fn has_preparent(&self) -> bool {
        self.preparent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preparent(&mut self, v: Iatt) {
        self.preparent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preparent(&mut self) -> &mut Iatt {
        if self.preparent.is_none() {
            self.preparent.set_default();
        }
        self.preparent.as_mut().unwrap()
    }

    // Take field
    pub fn take_preparent(&mut self) -> Iatt {
        self.preparent.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_preparent(&self) -> &Iatt {
        self.preparent.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_preparent_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.preparent
    }

    fn mut_preparent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.preparent
    }

    // optional .rusix.Iatt postparent = 5;

    pub fn clear_postparent(&mut self) {
        self.postparent.clear();
    }

    pub fn has_postparent(&self) -> bool {
        self.postparent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postparent(&mut self, v: Iatt) {
        self.postparent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postparent(&mut self) -> &mut Iatt {
        if self.postparent.is_none() {
            self.postparent.set_default();
        }
        self.postparent.as_mut().unwrap()
    }

    // Take field
    pub fn take_postparent(&mut self) -> Iatt {
        self.postparent.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_postparent(&self) -> &Iatt {
        self.postparent.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_postparent_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.postparent
    }

    fn mut_postparent_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.postparent
    }

    // optional bytes extra_data = 6;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for CreateResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preparent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.postparent {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stat)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preparent)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.postparent)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.preparent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.postparent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stat.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.preparent.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.postparent.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CreateResponse {
    fn new() -> CreateResponse {
        CreateResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CreateResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    CreateResponse::get_result_for_reflect,
                    CreateResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "stat",
                    CreateResponse::get_stat_for_reflect,
                    CreateResponse::mut_stat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    CreateResponse::get_fd_for_reflect,
                    CreateResponse::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "preparent",
                    CreateResponse::get_preparent_for_reflect,
                    CreateResponse::mut_preparent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "postparent",
                    CreateResponse::get_postparent_for_reflect,
                    CreateResponse::mut_postparent_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    CreateResponse::get_extra_data_for_reflect,
                    CreateResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateResponse>(
                    "CreateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CreateResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_stat();
        self.clear_fd();
        self.clear_preparent();
        self.clear_postparent();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FtruncateRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<u64>,
    offset: ::std::option::Option<u64>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FtruncateRequest {}

impl FtruncateRequest {
    pub fn new() -> FtruncateRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FtruncateRequest {
        static mut instance: ::protobuf::lazy::Lazy<FtruncateRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FtruncateRequest,
        };
        unsafe {
            instance.get(FtruncateRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // required uint64 offset = 3;

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }

    fn get_offset_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.offset
    }

    fn mut_offset_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.offset
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for FtruncateRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FtruncateRequest {
    fn new() -> FtruncateRequest {
        FtruncateRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<FtruncateRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    FtruncateRequest::get_gfid_for_reflect,
                    FtruncateRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    FtruncateRequest::get_fd_for_reflect,
                    FtruncateRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "offset",
                    FtruncateRequest::get_offset_for_reflect,
                    FtruncateRequest::mut_offset_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    FtruncateRequest::get_extra_data_for_reflect,
                    FtruncateRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FtruncateRequest>(
                    "FtruncateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FtruncateRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_offset();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FtruncateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FtruncateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FtruncateResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    prestat: ::protobuf::SingularPtrField<Iatt>,
    poststat: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FtruncateResponse {}

impl FtruncateResponse {
    pub fn new() -> FtruncateResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FtruncateResponse {
        static mut instance: ::protobuf::lazy::Lazy<FtruncateResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FtruncateResponse,
        };
        unsafe {
            instance.get(FtruncateResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt prestat = 2;

    pub fn clear_prestat(&mut self) {
        self.prestat.clear();
    }

    pub fn has_prestat(&self) -> bool {
        self.prestat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prestat(&mut self, v: Iatt) {
        self.prestat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prestat(&mut self) -> &mut Iatt {
        if self.prestat.is_none() {
            self.prestat.set_default();
        }
        self.prestat.as_mut().unwrap()
    }

    // Take field
    pub fn take_prestat(&mut self) -> Iatt {
        self.prestat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_prestat(&self) -> &Iatt {
        self.prestat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_prestat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.prestat
    }

    fn mut_prestat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.prestat
    }

    // optional .rusix.Iatt poststat = 3;

    pub fn clear_poststat(&mut self) {
        self.poststat.clear();
    }

    pub fn has_poststat(&self) -> bool {
        self.poststat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poststat(&mut self, v: Iatt) {
        self.poststat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poststat(&mut self) -> &mut Iatt {
        if self.poststat.is_none() {
            self.poststat.set_default();
        }
        self.poststat.as_mut().unwrap()
    }

    // Take field
    pub fn take_poststat(&mut self) -> Iatt {
        self.poststat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_poststat(&self) -> &Iatt {
        self.poststat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_poststat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.poststat
    }

    fn mut_poststat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.poststat
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for FtruncateResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prestat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.poststat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.prestat)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.poststat)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.prestat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.poststat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.prestat.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.poststat.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FtruncateResponse {
    fn new() -> FtruncateResponse {
        FtruncateResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<FtruncateResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    FtruncateResponse::get_result_for_reflect,
                    FtruncateResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "prestat",
                    FtruncateResponse::get_prestat_for_reflect,
                    FtruncateResponse::mut_prestat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "poststat",
                    FtruncateResponse::get_poststat_for_reflect,
                    FtruncateResponse::mut_poststat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    FtruncateResponse::get_extra_data_for_reflect,
                    FtruncateResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FtruncateResponse>(
                    "FtruncateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FtruncateResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_prestat();
        self.clear_poststat();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FtruncateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FtruncateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FstatRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<u64>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FstatRequest {}

impl FstatRequest {
    pub fn new() -> FstatRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FstatRequest {
        static mut instance: ::protobuf::lazy::Lazy<FstatRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FstatRequest,
        };
        unsafe {
            instance.get(FstatRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for FstatRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FstatRequest {
    fn new() -> FstatRequest {
        FstatRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<FstatRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    FstatRequest::get_gfid_for_reflect,
                    FstatRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    FstatRequest::get_fd_for_reflect,
                    FstatRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    FstatRequest::get_extra_data_for_reflect,
                    FstatRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FstatRequest>(
                    "FstatRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FstatRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FstatRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FstatRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct fstatResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    stat: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for fstatResponse {}

impl fstatResponse {
    pub fn new() -> fstatResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static fstatResponse {
        static mut instance: ::protobuf::lazy::Lazy<fstatResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const fstatResponse,
        };
        unsafe {
            instance.get(fstatResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt stat = 2;

    pub fn clear_stat(&mut self) {
        self.stat.clear();
    }

    pub fn has_stat(&self) -> bool {
        self.stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: Iatt) {
        self.stat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat(&mut self) -> &mut Iatt {
        if self.stat.is_none() {
            self.stat.set_default();
        }
        self.stat.as_mut().unwrap()
    }

    // Take field
    pub fn take_stat(&mut self) -> Iatt {
        self.stat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_stat(&self) -> &Iatt {
        self.stat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_stat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.stat
    }

    fn mut_stat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.stat
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for fstatResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stat)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stat.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for fstatResponse {
    fn new() -> fstatResponse {
        fstatResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<fstatResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    fstatResponse::get_result_for_reflect,
                    fstatResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "stat",
                    fstatResponse::get_stat_for_reflect,
                    fstatResponse::mut_stat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    fstatResponse::get_extra_data_for_reflect,
                    fstatResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<fstatResponse>(
                    "fstatResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for fstatResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_stat();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for fstatResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for fstatResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct entrylkRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    cmd: ::std::option::Option<u32>,
    field_type: ::std::option::Option<u32>,
    namelen: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    volume: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for entrylkRequest {}

impl entrylkRequest {
    pub fn new() -> entrylkRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static entrylkRequest {
        static mut instance: ::protobuf::lazy::Lazy<entrylkRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const entrylkRequest,
        };
        unsafe {
            instance.get(entrylkRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint32 cmd = 2;

    pub fn clear_cmd(&mut self) {
        self.cmd = ::std::option::Option::None;
    }

    pub fn has_cmd(&self) -> bool {
        self.cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd(&mut self, v: u32) {
        self.cmd = ::std::option::Option::Some(v);
    }

    pub fn get_cmd(&self) -> u32 {
        self.cmd.unwrap_or(0)
    }

    fn get_cmd_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cmd
    }

    fn mut_cmd_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cmd
    }

    // required uint32 type = 3;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.field_type
    }

    // required uint64 namelen = 4;

    pub fn clear_namelen(&mut self) {
        self.namelen = ::std::option::Option::None;
    }

    pub fn has_namelen(&self) -> bool {
        self.namelen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namelen(&mut self, v: u64) {
        self.namelen = ::std::option::Option::Some(v);
    }

    pub fn get_namelen(&self) -> u64 {
        self.namelen.unwrap_or(0)
    }

    fn get_namelen_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.namelen
    }

    fn mut_namelen_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.namelen
    }

    // required string name = 5;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // required string volume = 6;

    pub fn clear_volume(&mut self) {
        self.volume.clear();
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: ::std::string::String) {
        self.volume = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume(&mut self) -> &mut ::std::string::String {
        if self.volume.is_none() {
            self.volume.set_default();
        }
        self.volume.as_mut().unwrap()
    }

    // Take field
    pub fn take_volume(&mut self) -> ::std::string::String {
        self.volume.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_volume(&self) -> &str {
        match self.volume.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_volume_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.volume
    }

    fn mut_volume_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.volume
    }

    // optional bytes extra_data = 7;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for entrylkRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.cmd.is_none() {
            return false;
        }
        if self.field_type.is_none() {
            return false;
        }
        if self.namelen.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        if self.volume.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cmd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.namelen = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volume)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.cmd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.namelen {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.volume.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.cmd {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.namelen {
            os.write_uint64(4, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.volume.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for entrylkRequest {
    fn new() -> entrylkRequest {
        entrylkRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<entrylkRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    entrylkRequest::get_gfid_for_reflect,
                    entrylkRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cmd",
                    entrylkRequest::get_cmd_for_reflect,
                    entrylkRequest::mut_cmd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    entrylkRequest::get_field_type_for_reflect,
                    entrylkRequest::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "namelen",
                    entrylkRequest::get_namelen_for_reflect,
                    entrylkRequest::mut_namelen_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    entrylkRequest::get_name_for_reflect,
                    entrylkRequest::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "volume",
                    entrylkRequest::get_volume_for_reflect,
                    entrylkRequest::mut_volume_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    entrylkRequest::get_extra_data_for_reflect,
                    entrylkRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<entrylkRequest>(
                    "entrylkRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for entrylkRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_cmd();
        self.clear_field_type();
        self.clear_namelen();
        self.clear_name();
        self.clear_volume();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for entrylkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for entrylkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct fentrylkRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<u64>,
    cmd: ::std::option::Option<u32>,
    field_type: ::std::option::Option<u32>,
    namelen: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    volume: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for fentrylkRequest {}

impl fentrylkRequest {
    pub fn new() -> fentrylkRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static fentrylkRequest {
        static mut instance: ::protobuf::lazy::Lazy<fentrylkRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const fentrylkRequest,
        };
        unsafe {
            instance.get(fentrylkRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // required uint32 cmd = 3;

    pub fn clear_cmd(&mut self) {
        self.cmd = ::std::option::Option::None;
    }

    pub fn has_cmd(&self) -> bool {
        self.cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd(&mut self, v: u32) {
        self.cmd = ::std::option::Option::Some(v);
    }

    pub fn get_cmd(&self) -> u32 {
        self.cmd.unwrap_or(0)
    }

    fn get_cmd_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.cmd
    }

    fn mut_cmd_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.cmd
    }

    // required uint32 type = 4;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }

    fn get_field_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.field_type
    }

    // required uint64 namelen = 5;

    pub fn clear_namelen(&mut self) {
        self.namelen = ::std::option::Option::None;
    }

    pub fn has_namelen(&self) -> bool {
        self.namelen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namelen(&mut self, v: u64) {
        self.namelen = ::std::option::Option::Some(v);
    }

    pub fn get_namelen(&self) -> u64 {
        self.namelen.unwrap_or(0)
    }

    fn get_namelen_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.namelen
    }

    fn mut_namelen_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.namelen
    }

    // required string name = 6;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // required string volume = 7;

    pub fn clear_volume(&mut self) {
        self.volume.clear();
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: ::std::string::String) {
        self.volume = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume(&mut self) -> &mut ::std::string::String {
        if self.volume.is_none() {
            self.volume.set_default();
        }
        self.volume.as_mut().unwrap()
    }

    // Take field
    pub fn take_volume(&mut self) -> ::std::string::String {
        self.volume.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_volume(&self) -> &str {
        match self.volume.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_volume_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.volume
    }

    fn mut_volume_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.volume
    }

    // optional bytes extra_data = 8;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for fentrylkRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        if self.cmd.is_none() {
            return false;
        }
        if self.field_type.is_none() {
            return false;
        }
        if self.namelen.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        if self.volume.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cmd = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.namelen = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volume)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cmd {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.namelen {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.volume.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.cmd {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.namelen {
            os.write_uint64(5, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.volume.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for fentrylkRequest {
    fn new() -> fentrylkRequest {
        fentrylkRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<fentrylkRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    fentrylkRequest::get_gfid_for_reflect,
                    fentrylkRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    fentrylkRequest::get_fd_for_reflect,
                    fentrylkRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cmd",
                    fentrylkRequest::get_cmd_for_reflect,
                    fentrylkRequest::mut_cmd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type",
                    fentrylkRequest::get_field_type_for_reflect,
                    fentrylkRequest::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "namelen",
                    fentrylkRequest::get_namelen_for_reflect,
                    fentrylkRequest::mut_namelen_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    fentrylkRequest::get_name_for_reflect,
                    fentrylkRequest::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "volume",
                    fentrylkRequest::get_volume_for_reflect,
                    fentrylkRequest::mut_volume_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    fentrylkRequest::get_extra_data_for_reflect,
                    fentrylkRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<fentrylkRequest>(
                    "fentrylkRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for fentrylkRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_cmd();
        self.clear_field_type();
        self.clear_namelen();
        self.clear_name();
        self.clear_volume();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for fentrylkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for fentrylkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setattrRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    stbuf: ::protobuf::SingularPtrField<Iatt>,
    valid: ::std::option::Option<i32>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setattrRequest {}

impl setattrRequest {
    pub fn new() -> setattrRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setattrRequest {
        static mut instance: ::protobuf::lazy::Lazy<setattrRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setattrRequest,
        };
        unsafe {
            instance.get(setattrRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required .rusix.Iatt stbuf = 2;

    pub fn clear_stbuf(&mut self) {
        self.stbuf.clear();
    }

    pub fn has_stbuf(&self) -> bool {
        self.stbuf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stbuf(&mut self, v: Iatt) {
        self.stbuf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stbuf(&mut self) -> &mut Iatt {
        if self.stbuf.is_none() {
            self.stbuf.set_default();
        }
        self.stbuf.as_mut().unwrap()
    }

    // Take field
    pub fn take_stbuf(&mut self) -> Iatt {
        self.stbuf.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_stbuf(&self) -> &Iatt {
        self.stbuf.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_stbuf_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.stbuf
    }

    fn mut_stbuf_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.stbuf
    }

    // required int32 valid = 3;

    pub fn clear_valid(&mut self) {
        self.valid = ::std::option::Option::None;
    }

    pub fn has_valid(&self) -> bool {
        self.valid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_valid(&mut self, v: i32) {
        self.valid = ::std::option::Option::Some(v);
    }

    pub fn get_valid(&self) -> i32 {
        self.valid.unwrap_or(0)
    }

    fn get_valid_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.valid
    }

    fn mut_valid_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.valid
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for setattrRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.stbuf.is_none() {
            return false;
        }
        if self.valid.is_none() {
            return false;
        }
        for v in &self.stbuf {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stbuf)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.valid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.stbuf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.valid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.stbuf.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.valid {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setattrRequest {
    fn new() -> setattrRequest {
        setattrRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<setattrRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    setattrRequest::get_gfid_for_reflect,
                    setattrRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "stbuf",
                    setattrRequest::get_stbuf_for_reflect,
                    setattrRequest::mut_stbuf_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "valid",
                    setattrRequest::get_valid_for_reflect,
                    setattrRequest::mut_valid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    setattrRequest::get_extra_data_for_reflect,
                    setattrRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<setattrRequest>(
                    "setattrRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setattrRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_stbuf();
        self.clear_valid();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setattrRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setattrRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setattrResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    statpre: ::protobuf::SingularPtrField<Iatt>,
    statpost: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setattrResponse {}

impl setattrResponse {
    pub fn new() -> setattrResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setattrResponse {
        static mut instance: ::protobuf::lazy::Lazy<setattrResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setattrResponse,
        };
        unsafe {
            instance.get(setattrResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt statpre = 2;

    pub fn clear_statpre(&mut self) {
        self.statpre.clear();
    }

    pub fn has_statpre(&self) -> bool {
        self.statpre.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statpre(&mut self, v: Iatt) {
        self.statpre = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statpre(&mut self) -> &mut Iatt {
        if self.statpre.is_none() {
            self.statpre.set_default();
        }
        self.statpre.as_mut().unwrap()
    }

    // Take field
    pub fn take_statpre(&mut self) -> Iatt {
        self.statpre.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_statpre(&self) -> &Iatt {
        self.statpre.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_statpre_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.statpre
    }

    fn mut_statpre_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.statpre
    }

    // optional .rusix.Iatt statpost = 3;

    pub fn clear_statpost(&mut self) {
        self.statpost.clear();
    }

    pub fn has_statpost(&self) -> bool {
        self.statpost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statpost(&mut self, v: Iatt) {
        self.statpost = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statpost(&mut self) -> &mut Iatt {
        if self.statpost.is_none() {
            self.statpost.set_default();
        }
        self.statpost.as_mut().unwrap()
    }

    // Take field
    pub fn take_statpost(&mut self) -> Iatt {
        self.statpost.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_statpost(&self) -> &Iatt {
        self.statpost.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_statpost_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.statpost
    }

    fn mut_statpost_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.statpost
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for setattrResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statpre {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statpost {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statpre)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statpost)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.statpre.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.statpost.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.statpre.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.statpost.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setattrResponse {
    fn new() -> setattrResponse {
        setattrResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<setattrResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    setattrResponse::get_result_for_reflect,
                    setattrResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "statpre",
                    setattrResponse::get_statpre_for_reflect,
                    setattrResponse::mut_statpre_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "statpost",
                    setattrResponse::get_statpost_for_reflect,
                    setattrResponse::mut_statpost_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    setattrResponse::get_extra_data_for_reflect,
                    setattrResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<setattrResponse>(
                    "setattrResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setattrResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_statpre();
        self.clear_statpost();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setattrResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setattrResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct fsetattrRequest {
    // message fields
    fd: ::std::option::Option<u64>,
    stbuf: ::protobuf::SingularPtrField<Iatt>,
    valid: ::std::option::Option<i32>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for fsetattrRequest {}

impl fsetattrRequest {
    pub fn new() -> fsetattrRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static fsetattrRequest {
        static mut instance: ::protobuf::lazy::Lazy<fsetattrRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const fsetattrRequest,
        };
        unsafe {
            instance.get(fsetattrRequest::new)
        }
    }

    // required uint64 fd = 1;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // required .rusix.Iatt stbuf = 2;

    pub fn clear_stbuf(&mut self) {
        self.stbuf.clear();
    }

    pub fn has_stbuf(&self) -> bool {
        self.stbuf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stbuf(&mut self, v: Iatt) {
        self.stbuf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stbuf(&mut self) -> &mut Iatt {
        if self.stbuf.is_none() {
            self.stbuf.set_default();
        }
        self.stbuf.as_mut().unwrap()
    }

    // Take field
    pub fn take_stbuf(&mut self) -> Iatt {
        self.stbuf.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_stbuf(&self) -> &Iatt {
        self.stbuf.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_stbuf_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.stbuf
    }

    fn mut_stbuf_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.stbuf
    }

    // required int32 valid = 3;

    pub fn clear_valid(&mut self) {
        self.valid = ::std::option::Option::None;
    }

    pub fn has_valid(&self) -> bool {
        self.valid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_valid(&mut self, v: i32) {
        self.valid = ::std::option::Option::Some(v);
    }

    pub fn get_valid(&self) -> i32 {
        self.valid.unwrap_or(0)
    }

    fn get_valid_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.valid
    }

    fn mut_valid_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.valid
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for fsetattrRequest {
    fn is_initialized(&self) -> bool {
        if self.fd.is_none() {
            return false;
        }
        if self.stbuf.is_none() {
            return false;
        }
        if self.valid.is_none() {
            return false;
        }
        for v in &self.stbuf {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stbuf)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.valid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.stbuf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.valid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fd {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.stbuf.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.valid {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for fsetattrRequest {
    fn new() -> fsetattrRequest {
        fsetattrRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<fsetattrRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    fsetattrRequest::get_fd_for_reflect,
                    fsetattrRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "stbuf",
                    fsetattrRequest::get_stbuf_for_reflect,
                    fsetattrRequest::mut_stbuf_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "valid",
                    fsetattrRequest::get_valid_for_reflect,
                    fsetattrRequest::mut_valid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    fsetattrRequest::get_extra_data_for_reflect,
                    fsetattrRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<fsetattrRequest>(
                    "fsetattrRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for fsetattrRequest {
    fn clear(&mut self) {
        self.clear_fd();
        self.clear_stbuf();
        self.clear_valid();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for fsetattrRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for fsetattrRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct fsetattrResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    statpre: ::protobuf::SingularPtrField<Iatt>,
    statpost: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for fsetattrResponse {}

impl fsetattrResponse {
    pub fn new() -> fsetattrResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static fsetattrResponse {
        static mut instance: ::protobuf::lazy::Lazy<fsetattrResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const fsetattrResponse,
        };
        unsafe {
            instance.get(fsetattrResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt statpre = 2;

    pub fn clear_statpre(&mut self) {
        self.statpre.clear();
    }

    pub fn has_statpre(&self) -> bool {
        self.statpre.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statpre(&mut self, v: Iatt) {
        self.statpre = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statpre(&mut self) -> &mut Iatt {
        if self.statpre.is_none() {
            self.statpre.set_default();
        }
        self.statpre.as_mut().unwrap()
    }

    // Take field
    pub fn take_statpre(&mut self) -> Iatt {
        self.statpre.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_statpre(&self) -> &Iatt {
        self.statpre.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_statpre_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.statpre
    }

    fn mut_statpre_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.statpre
    }

    // optional .rusix.Iatt statpost = 3;

    pub fn clear_statpost(&mut self) {
        self.statpost.clear();
    }

    pub fn has_statpost(&self) -> bool {
        self.statpost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statpost(&mut self, v: Iatt) {
        self.statpost = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statpost(&mut self) -> &mut Iatt {
        if self.statpost.is_none() {
            self.statpost.set_default();
        }
        self.statpost.as_mut().unwrap()
    }

    // Take field
    pub fn take_statpost(&mut self) -> Iatt {
        self.statpost.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_statpost(&self) -> &Iatt {
        self.statpost.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_statpost_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.statpost
    }

    fn mut_statpost_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.statpost
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for fsetattrResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statpre {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statpost {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statpre)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statpost)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.statpre.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.statpost.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.statpre.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.statpost.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for fsetattrResponse {
    fn new() -> fsetattrResponse {
        fsetattrResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<fsetattrResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    fsetattrResponse::get_result_for_reflect,
                    fsetattrResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "statpre",
                    fsetattrResponse::get_statpre_for_reflect,
                    fsetattrResponse::mut_statpre_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "statpost",
                    fsetattrResponse::get_statpost_for_reflect,
                    fsetattrResponse::mut_statpost_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    fsetattrResponse::get_extra_data_for_reflect,
                    fsetattrResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<fsetattrResponse>(
                    "fsetattrResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for fsetattrResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_statpre();
        self.clear_statpost();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for fsetattrResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for fsetattrResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct fallocateRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<u64>,
    flags: ::std::option::Option<u32>,
    offset: ::std::option::Option<u64>,
    size: ::std::option::Option<u64>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for fallocateRequest {}

impl fallocateRequest {
    pub fn new() -> fallocateRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static fallocateRequest {
        static mut instance: ::protobuf::lazy::Lazy<fallocateRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const fallocateRequest,
        };
        unsafe {
            instance.get(fallocateRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // required uint32 flags = 3;

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    fn get_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.flags
    }

    fn mut_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.flags
    }

    // required uint64 offset = 4;

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }

    fn get_offset_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.offset
    }

    fn mut_offset_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.offset
    }

    // required uint64 size = 5;

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = ::std::option::Option::Some(v);
    }

    pub fn get_size(&self) -> u64 {
        self.size.unwrap_or(0)
    }

    fn get_size_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.size
    }

    fn mut_size_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.size
    }

    // optional bytes extra_data = 6;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for fallocateRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        if self.flags.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        if self.size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint64(5, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for fallocateRequest {
    fn new() -> fallocateRequest {
        fallocateRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<fallocateRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    fallocateRequest::get_gfid_for_reflect,
                    fallocateRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    fallocateRequest::get_fd_for_reflect,
                    fallocateRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    fallocateRequest::get_flags_for_reflect,
                    fallocateRequest::mut_flags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "offset",
                    fallocateRequest::get_offset_for_reflect,
                    fallocateRequest::mut_offset_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "size",
                    fallocateRequest::get_size_for_reflect,
                    fallocateRequest::mut_size_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    fallocateRequest::get_extra_data_for_reflect,
                    fallocateRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<fallocateRequest>(
                    "fallocateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for fallocateRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_flags();
        self.clear_offset();
        self.clear_size();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for fallocateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for fallocateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct fallocateResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    statpre: ::protobuf::SingularPtrField<Iatt>,
    statpost: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for fallocateResponse {}

impl fallocateResponse {
    pub fn new() -> fallocateResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static fallocateResponse {
        static mut instance: ::protobuf::lazy::Lazy<fallocateResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const fallocateResponse,
        };
        unsafe {
            instance.get(fallocateResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt statpre = 2;

    pub fn clear_statpre(&mut self) {
        self.statpre.clear();
    }

    pub fn has_statpre(&self) -> bool {
        self.statpre.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statpre(&mut self, v: Iatt) {
        self.statpre = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statpre(&mut self) -> &mut Iatt {
        if self.statpre.is_none() {
            self.statpre.set_default();
        }
        self.statpre.as_mut().unwrap()
    }

    // Take field
    pub fn take_statpre(&mut self) -> Iatt {
        self.statpre.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_statpre(&self) -> &Iatt {
        self.statpre.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_statpre_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.statpre
    }

    fn mut_statpre_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.statpre
    }

    // optional .rusix.Iatt statpost = 3;

    pub fn clear_statpost(&mut self) {
        self.statpost.clear();
    }

    pub fn has_statpost(&self) -> bool {
        self.statpost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statpost(&mut self, v: Iatt) {
        self.statpost = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statpost(&mut self) -> &mut Iatt {
        if self.statpost.is_none() {
            self.statpost.set_default();
        }
        self.statpost.as_mut().unwrap()
    }

    // Take field
    pub fn take_statpost(&mut self) -> Iatt {
        self.statpost.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_statpost(&self) -> &Iatt {
        self.statpost.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_statpost_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.statpost
    }

    fn mut_statpost_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.statpost
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for fallocateResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statpre {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statpost {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statpre)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statpost)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.statpre.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.statpost.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.statpre.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.statpost.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for fallocateResponse {
    fn new() -> fallocateResponse {
        fallocateResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<fallocateResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    fallocateResponse::get_result_for_reflect,
                    fallocateResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "statpre",
                    fallocateResponse::get_statpre_for_reflect,
                    fallocateResponse::mut_statpre_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "statpost",
                    fallocateResponse::get_statpost_for_reflect,
                    fallocateResponse::mut_statpost_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    fallocateResponse::get_extra_data_for_reflect,
                    fallocateResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<fallocateResponse>(
                    "fallocateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for fallocateResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_statpre();
        self.clear_statpost();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for fallocateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for fallocateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct discardRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<u64>,
    offset: ::std::option::Option<u64>,
    size: ::std::option::Option<u64>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for discardRequest {}

impl discardRequest {
    pub fn new() -> discardRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static discardRequest {
        static mut instance: ::protobuf::lazy::Lazy<discardRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const discardRequest,
        };
        unsafe {
            instance.get(discardRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // required uint64 offset = 3;

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }

    fn get_offset_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.offset
    }

    fn mut_offset_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.offset
    }

    // required uint64 size = 4;

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = ::std::option::Option::Some(v);
    }

    pub fn get_size(&self) -> u64 {
        self.size.unwrap_or(0)
    }

    fn get_size_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.size
    }

    fn mut_size_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.size
    }

    // optional bytes extra_data = 5;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for discardRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        if self.size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint64(4, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for discardRequest {
    fn new() -> discardRequest {
        discardRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<discardRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    discardRequest::get_gfid_for_reflect,
                    discardRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    discardRequest::get_fd_for_reflect,
                    discardRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "offset",
                    discardRequest::get_offset_for_reflect,
                    discardRequest::mut_offset_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "size",
                    discardRequest::get_size_for_reflect,
                    discardRequest::mut_size_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    discardRequest::get_extra_data_for_reflect,
                    discardRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<discardRequest>(
                    "discardRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for discardRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_offset();
        self.clear_size();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for discardRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for discardRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct discardResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    statpre: ::protobuf::SingularPtrField<Iatt>,
    statpost: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for discardResponse {}

impl discardResponse {
    pub fn new() -> discardResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static discardResponse {
        static mut instance: ::protobuf::lazy::Lazy<discardResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const discardResponse,
        };
        unsafe {
            instance.get(discardResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt statpre = 2;

    pub fn clear_statpre(&mut self) {
        self.statpre.clear();
    }

    pub fn has_statpre(&self) -> bool {
        self.statpre.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statpre(&mut self, v: Iatt) {
        self.statpre = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statpre(&mut self) -> &mut Iatt {
        if self.statpre.is_none() {
            self.statpre.set_default();
        }
        self.statpre.as_mut().unwrap()
    }

    // Take field
    pub fn take_statpre(&mut self) -> Iatt {
        self.statpre.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_statpre(&self) -> &Iatt {
        self.statpre.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_statpre_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.statpre
    }

    fn mut_statpre_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.statpre
    }

    // optional .rusix.Iatt statpost = 3;

    pub fn clear_statpost(&mut self) {
        self.statpost.clear();
    }

    pub fn has_statpost(&self) -> bool {
        self.statpost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statpost(&mut self, v: Iatt) {
        self.statpost = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statpost(&mut self) -> &mut Iatt {
        if self.statpost.is_none() {
            self.statpost.set_default();
        }
        self.statpost.as_mut().unwrap()
    }

    // Take field
    pub fn take_statpost(&mut self) -> Iatt {
        self.statpost.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_statpost(&self) -> &Iatt {
        self.statpost.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_statpost_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.statpost
    }

    fn mut_statpost_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.statpost
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for discardResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statpre {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statpost {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statpre)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statpost)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.statpre.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.statpost.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.statpre.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.statpost.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for discardResponse {
    fn new() -> discardResponse {
        discardResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<discardResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    discardResponse::get_result_for_reflect,
                    discardResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "statpre",
                    discardResponse::get_statpre_for_reflect,
                    discardResponse::mut_statpre_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "statpost",
                    discardResponse::get_statpost_for_reflect,
                    discardResponse::mut_statpost_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    discardResponse::get_extra_data_for_reflect,
                    discardResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<discardResponse>(
                    "discardResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for discardResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_statpre();
        self.clear_statpost();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for discardResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for discardResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct zerofillRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<u64>,
    offset: ::std::option::Option<u64>,
    size: ::std::option::Option<u64>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for zerofillRequest {}

impl zerofillRequest {
    pub fn new() -> zerofillRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static zerofillRequest {
        static mut instance: ::protobuf::lazy::Lazy<zerofillRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const zerofillRequest,
        };
        unsafe {
            instance.get(zerofillRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // required uint64 offset = 3;

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }

    fn get_offset_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.offset
    }

    fn mut_offset_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.offset
    }

    // required uint64 size = 4;

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = ::std::option::Option::Some(v);
    }

    pub fn get_size(&self) -> u64 {
        self.size.unwrap_or(0)
    }

    fn get_size_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.size
    }

    fn mut_size_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.size
    }

    // optional bytes extra_data = 5;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for zerofillRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        if self.size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint64(4, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for zerofillRequest {
    fn new() -> zerofillRequest {
        zerofillRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<zerofillRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    zerofillRequest::get_gfid_for_reflect,
                    zerofillRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    zerofillRequest::get_fd_for_reflect,
                    zerofillRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "offset",
                    zerofillRequest::get_offset_for_reflect,
                    zerofillRequest::mut_offset_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "size",
                    zerofillRequest::get_size_for_reflect,
                    zerofillRequest::mut_size_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    zerofillRequest::get_extra_data_for_reflect,
                    zerofillRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<zerofillRequest>(
                    "zerofillRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for zerofillRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_offset();
        self.clear_size();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for zerofillRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for zerofillRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct zerofillResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    statpre: ::protobuf::SingularPtrField<Iatt>,
    statpost: ::protobuf::SingularPtrField<Iatt>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for zerofillResponse {}

impl zerofillResponse {
    pub fn new() -> zerofillResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static zerofillResponse {
        static mut instance: ::protobuf::lazy::Lazy<zerofillResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const zerofillResponse,
        };
        unsafe {
            instance.get(zerofillResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Iatt statpre = 2;

    pub fn clear_statpre(&mut self) {
        self.statpre.clear();
    }

    pub fn has_statpre(&self) -> bool {
        self.statpre.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statpre(&mut self, v: Iatt) {
        self.statpre = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statpre(&mut self) -> &mut Iatt {
        if self.statpre.is_none() {
            self.statpre.set_default();
        }
        self.statpre.as_mut().unwrap()
    }

    // Take field
    pub fn take_statpre(&mut self) -> Iatt {
        self.statpre.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_statpre(&self) -> &Iatt {
        self.statpre.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_statpre_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.statpre
    }

    fn mut_statpre_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.statpre
    }

    // optional .rusix.Iatt statpost = 3;

    pub fn clear_statpost(&mut self) {
        self.statpost.clear();
    }

    pub fn has_statpost(&self) -> bool {
        self.statpost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statpost(&mut self, v: Iatt) {
        self.statpost = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statpost(&mut self) -> &mut Iatt {
        if self.statpost.is_none() {
            self.statpost.set_default();
        }
        self.statpost.as_mut().unwrap()
    }

    // Take field
    pub fn take_statpost(&mut self) -> Iatt {
        self.statpost.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_statpost(&self) -> &Iatt {
        self.statpost.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_statpost_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.statpost
    }

    fn mut_statpost_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.statpost
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for zerofillResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statpre {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statpost {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statpre)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statpost)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.statpre.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.statpost.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.statpre.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.statpost.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for zerofillResponse {
    fn new() -> zerofillResponse {
        zerofillResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<zerofillResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    zerofillResponse::get_result_for_reflect,
                    zerofillResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "statpre",
                    zerofillResponse::get_statpre_for_reflect,
                    zerofillResponse::mut_statpre_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "statpost",
                    zerofillResponse::get_statpost_for_reflect,
                    zerofillResponse::mut_statpost_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    zerofillResponse::get_extra_data_for_reflect,
                    zerofillResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<zerofillResponse>(
                    "zerofillResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for zerofillResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_statpre();
        self.clear_statpost();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for zerofillResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for zerofillResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rchecksumRequest {
    // message fields
    fd: ::std::option::Option<u64>,
    offset: ::std::option::Option<u64>,
    len: ::std::option::Option<u32>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for rchecksumRequest {}

impl rchecksumRequest {
    pub fn new() -> rchecksumRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static rchecksumRequest {
        static mut instance: ::protobuf::lazy::Lazy<rchecksumRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rchecksumRequest,
        };
        unsafe {
            instance.get(rchecksumRequest::new)
        }
    }

    // required uint64 fd = 1;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // required uint64 offset = 2;

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }

    fn get_offset_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.offset
    }

    fn mut_offset_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.offset
    }

    // required uint32 len = 3;

    pub fn clear_len(&mut self) {
        self.len = ::std::option::Option::None;
    }

    pub fn has_len(&self) -> bool {
        self.len.is_some()
    }

    // Param is passed by value, moved
    pub fn set_len(&mut self, v: u32) {
        self.len = ::std::option::Option::Some(v);
    }

    pub fn get_len(&self) -> u32 {
        self.len.unwrap_or(0)
    }

    fn get_len_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.len
    }

    fn mut_len_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.len
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for rchecksumRequest {
    fn is_initialized(&self) -> bool {
        if self.fd.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        if self.len.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.len = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.len {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fd {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.len {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for rchecksumRequest {
    fn new() -> rchecksumRequest {
        rchecksumRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<rchecksumRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    rchecksumRequest::get_fd_for_reflect,
                    rchecksumRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "offset",
                    rchecksumRequest::get_offset_for_reflect,
                    rchecksumRequest::mut_offset_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "len",
                    rchecksumRequest::get_len_for_reflect,
                    rchecksumRequest::mut_len_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    rchecksumRequest::get_extra_data_for_reflect,
                    rchecksumRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rchecksumRequest>(
                    "rchecksumRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for rchecksumRequest {
    fn clear(&mut self) {
        self.clear_fd();
        self.clear_offset();
        self.clear_len();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rchecksumRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rchecksumRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rchecksumResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    weak_checksum: ::std::option::Option<u32>,
    strong_checksum: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for rchecksumResponse {}

impl rchecksumResponse {
    pub fn new() -> rchecksumResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static rchecksumResponse {
        static mut instance: ::protobuf::lazy::Lazy<rchecksumResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rchecksumResponse,
        };
        unsafe {
            instance.get(rchecksumResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional uint32 weak_checksum = 2;

    pub fn clear_weak_checksum(&mut self) {
        self.weak_checksum = ::std::option::Option::None;
    }

    pub fn has_weak_checksum(&self) -> bool {
        self.weak_checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weak_checksum(&mut self, v: u32) {
        self.weak_checksum = ::std::option::Option::Some(v);
    }

    pub fn get_weak_checksum(&self) -> u32 {
        self.weak_checksum.unwrap_or(0)
    }

    fn get_weak_checksum_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.weak_checksum
    }

    fn mut_weak_checksum_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.weak_checksum
    }

    // optional bytes strong_checksum = 3;

    pub fn clear_strong_checksum(&mut self) {
        self.strong_checksum.clear();
    }

    pub fn has_strong_checksum(&self) -> bool {
        self.strong_checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strong_checksum(&mut self, v: ::std::vec::Vec<u8>) {
        self.strong_checksum = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_strong_checksum(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.strong_checksum.is_none() {
            self.strong_checksum.set_default();
        }
        self.strong_checksum.as_mut().unwrap()
    }

    // Take field
    pub fn take_strong_checksum(&mut self) -> ::std::vec::Vec<u8> {
        self.strong_checksum.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_strong_checksum(&self) -> &[u8] {
        match self.strong_checksum.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_strong_checksum_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.strong_checksum
    }

    fn mut_strong_checksum_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.strong_checksum
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for rchecksumResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.weak_checksum = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.strong_checksum)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.weak_checksum {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.strong_checksum.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.weak_checksum {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.strong_checksum.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for rchecksumResponse {
    fn new() -> rchecksumResponse {
        rchecksumResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<rchecksumResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    rchecksumResponse::get_result_for_reflect,
                    rchecksumResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "weak_checksum",
                    rchecksumResponse::get_weak_checksum_for_reflect,
                    rchecksumResponse::mut_weak_checksum_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "strong_checksum",
                    rchecksumResponse::get_strong_checksum_for_reflect,
                    rchecksumResponse::mut_strong_checksum_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    rchecksumResponse::get_extra_data_for_reflect,
                    rchecksumResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rchecksumResponse>(
                    "rchecksumResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for rchecksumResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_weak_checksum();
        self.clear_strong_checksum();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rchecksumResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rchecksumResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ipcRequest {
    // message fields
    op: ::std::option::Option<u32>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ipcRequest {}

impl ipcRequest {
    pub fn new() -> ipcRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ipcRequest {
        static mut instance: ::protobuf::lazy::Lazy<ipcRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ipcRequest,
        };
        unsafe {
            instance.get(ipcRequest::new)
        }
    }

    // required uint32 op = 1;

    pub fn clear_op(&mut self) {
        self.op = ::std::option::Option::None;
    }

    pub fn has_op(&self) -> bool {
        self.op.is_some()
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: u32) {
        self.op = ::std::option::Option::Some(v);
    }

    pub fn get_op(&self) -> u32 {
        self.op.unwrap_or(0)
    }

    fn get_op_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.op
    }

    fn mut_op_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.op
    }

    // optional bytes extra_data = 2;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for ipcRequest {
    fn is_initialized(&self) -> bool {
        if self.op.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.op = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.op {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.op {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ipcRequest {
    fn new() -> ipcRequest {
        ipcRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<ipcRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "op",
                    ipcRequest::get_op_for_reflect,
                    ipcRequest::mut_op_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    ipcRequest::get_extra_data_for_reflect,
                    ipcRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ipcRequest>(
                    "ipcRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ipcRequest {
    fn clear(&mut self) {
        self.clear_op();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ipcRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ipcRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ipcResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ipcResponse {}

impl ipcResponse {
    pub fn new() -> ipcResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ipcResponse {
        static mut instance: ::protobuf::lazy::Lazy<ipcResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ipcResponse,
        };
        unsafe {
            instance.get(ipcResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional bytes extra_data = 2;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for ipcResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ipcResponse {
    fn new() -> ipcResponse {
        ipcResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<ipcResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    ipcResponse::get_result_for_reflect,
                    ipcResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    ipcResponse::get_extra_data_for_reflect,
                    ipcResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ipcResponse>(
                    "ipcResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ipcResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ipcResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ipcResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct seekRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<u64>,
    offset: ::std::option::Option<u64>,
    what: ::std::option::Option<i32>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for seekRequest {}

impl seekRequest {
    pub fn new() -> seekRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static seekRequest {
        static mut instance: ::protobuf::lazy::Lazy<seekRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const seekRequest,
        };
        unsafe {
            instance.get(seekRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // required uint64 offset = 3;

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }

    fn get_offset_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.offset
    }

    fn mut_offset_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.offset
    }

    // required int32 what = 4;

    pub fn clear_what(&mut self) {
        self.what = ::std::option::Option::None;
    }

    pub fn has_what(&self) -> bool {
        self.what.is_some()
    }

    // Param is passed by value, moved
    pub fn set_what(&mut self, v: i32) {
        self.what = ::std::option::Option::Some(v);
    }

    pub fn get_what(&self) -> i32 {
        self.what.unwrap_or(0)
    }

    fn get_what_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.what
    }

    fn mut_what_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.what
    }

    // optional bytes extra_data = 5;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for seekRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        if self.what.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.what = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.what {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.what {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for seekRequest {
    fn new() -> seekRequest {
        seekRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<seekRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    seekRequest::get_gfid_for_reflect,
                    seekRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    seekRequest::get_fd_for_reflect,
                    seekRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "offset",
                    seekRequest::get_offset_for_reflect,
                    seekRequest::mut_offset_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "what",
                    seekRequest::get_what_for_reflect,
                    seekRequest::mut_what_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    seekRequest::get_extra_data_for_reflect,
                    seekRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<seekRequest>(
                    "seekRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for seekRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_offset();
        self.clear_what();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for seekRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for seekRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct seekResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    offset: ::std::option::Option<u64>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for seekResponse {}

impl seekResponse {
    pub fn new() -> seekResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static seekResponse {
        static mut instance: ::protobuf::lazy::Lazy<seekResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const seekResponse,
        };
        unsafe {
            instance.get(seekResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional uint64 offset = 2;

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }

    fn get_offset_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.offset
    }

    fn mut_offset_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.offset
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for seekResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for seekResponse {
    fn new() -> seekResponse {
        seekResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<seekResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    seekResponse::get_result_for_reflect,
                    seekResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "offset",
                    seekResponse::get_offset_for_reflect,
                    seekResponse::mut_offset_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    seekResponse::get_extra_data_for_reflect,
                    seekResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<seekResponse>(
                    "seekResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for seekResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_offset();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for seekResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for seekResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setvolumeRequest {
    // message fields
    dict: ::protobuf::SingularPtrField<Dict>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setvolumeRequest {}

impl setvolumeRequest {
    pub fn new() -> setvolumeRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setvolumeRequest {
        static mut instance: ::protobuf::lazy::Lazy<setvolumeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setvolumeRequest,
        };
        unsafe {
            instance.get(setvolumeRequest::new)
        }
    }

    // required .rusix.Dict dict = 1;

    pub fn clear_dict(&mut self) {
        self.dict.clear();
    }

    pub fn has_dict(&self) -> bool {
        self.dict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dict(&mut self, v: Dict) {
        self.dict = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dict(&mut self) -> &mut Dict {
        if self.dict.is_none() {
            self.dict.set_default();
        }
        self.dict.as_mut().unwrap()
    }

    // Take field
    pub fn take_dict(&mut self) -> Dict {
        self.dict.take().unwrap_or_else(|| Dict::new())
    }

    pub fn get_dict(&self) -> &Dict {
        self.dict.as_ref().unwrap_or_else(|| Dict::default_instance())
    }

    fn get_dict_for_reflect(&self) -> &::protobuf::SingularPtrField<Dict> {
        &self.dict
    }

    fn mut_dict_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Dict> {
        &mut self.dict
    }
}

impl ::protobuf::Message for setvolumeRequest {
    fn is_initialized(&self) -> bool {
        if self.dict.is_none() {
            return false;
        }
        for v in &self.dict {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dict)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dict.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dict.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setvolumeRequest {
    fn new() -> setvolumeRequest {
        setvolumeRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<setvolumeRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dict>>(
                    "dict",
                    setvolumeRequest::get_dict_for_reflect,
                    setvolumeRequest::mut_dict_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<setvolumeRequest>(
                    "setvolumeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setvolumeRequest {
    fn clear(&mut self) {
        self.clear_dict();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setvolumeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setvolumeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct setvolumeResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    dict: ::protobuf::SingularPtrField<Dict>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for setvolumeResponse {}

impl setvolumeResponse {
    pub fn new() -> setvolumeResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static setvolumeResponse {
        static mut instance: ::protobuf::lazy::Lazy<setvolumeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const setvolumeResponse,
        };
        unsafe {
            instance.get(setvolumeResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Dict dict = 2;

    pub fn clear_dict(&mut self) {
        self.dict.clear();
    }

    pub fn has_dict(&self) -> bool {
        self.dict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dict(&mut self, v: Dict) {
        self.dict = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dict(&mut self) -> &mut Dict {
        if self.dict.is_none() {
            self.dict.set_default();
        }
        self.dict.as_mut().unwrap()
    }

    // Take field
    pub fn take_dict(&mut self) -> Dict {
        self.dict.take().unwrap_or_else(|| Dict::new())
    }

    pub fn get_dict(&self) -> &Dict {
        self.dict.as_ref().unwrap_or_else(|| Dict::default_instance())
    }

    fn get_dict_for_reflect(&self) -> &::protobuf::SingularPtrField<Dict> {
        &self.dict
    }

    fn mut_dict_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Dict> {
        &mut self.dict
    }
}

impl ::protobuf::Message for setvolumeResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dict {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dict)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dict.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dict.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for setvolumeResponse {
    fn new() -> setvolumeResponse {
        setvolumeResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<setvolumeResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    setvolumeResponse::get_result_for_reflect,
                    setvolumeResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dict>>(
                    "dict",
                    setvolumeResponse::get_dict_for_reflect,
                    setvolumeResponse::mut_dict_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<setvolumeResponse>(
                    "setvolumeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for setvolumeResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_dict();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for setvolumeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for setvolumeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getspecRequest {
    // message fields
    flags: ::std::option::Option<u32>,
    key: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getspecRequest {}

impl getspecRequest {
    pub fn new() -> getspecRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getspecRequest {
        static mut instance: ::protobuf::lazy::Lazy<getspecRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getspecRequest,
        };
        unsafe {
            instance.get(getspecRequest::new)
        }
    }

    // required uint32 flags = 1;

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    fn get_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.flags
    }

    fn mut_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.flags
    }

    // required string key = 2;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_key_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.key
    }

    fn mut_key_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.key
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for getspecRequest {
    fn is_initialized(&self) -> bool {
        if self.flags.is_none() {
            return false;
        }
        if self.key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.flags {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getspecRequest {
    fn new() -> getspecRequest {
        getspecRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<getspecRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    getspecRequest::get_flags_for_reflect,
                    getspecRequest::mut_flags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    getspecRequest::get_key_for_reflect,
                    getspecRequest::mut_key_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    getspecRequest::get_extra_data_for_reflect,
                    getspecRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getspecRequest>(
                    "getspecRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getspecRequest {
    fn clear(&mut self) {
        self.clear_flags();
        self.clear_key();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getspecRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getspecRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getspecResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    spec: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for getspecResponse {}

impl getspecResponse {
    pub fn new() -> getspecResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static getspecResponse {
        static mut instance: ::protobuf::lazy::Lazy<getspecResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getspecResponse,
        };
        unsafe {
            instance.get(getspecResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional string spec = 2;

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ::std::string::String) {
        self.spec = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ::std::string::String {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> ::std::string::String {
        self.spec.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_spec(&self) -> &str {
        match self.spec.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_spec_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.spec
    }

    fn mut_spec_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.spec
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for getspecResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for getspecResponse {
    fn new() -> getspecResponse {
        getspecResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<getspecResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    getspecResponse::get_result_for_reflect,
                    getspecResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "spec",
                    getspecResponse::get_spec_for_reflect,
                    getspecResponse::mut_spec_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    getspecResponse::get_extra_data_for_reflect,
                    getspecResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getspecResponse>(
                    "getspecResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for getspecResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_spec();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getspecResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getspecResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct get_volume_infoRequest {
    // message fields
    dict: ::protobuf::SingularPtrField<Dict>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for get_volume_infoRequest {}

impl get_volume_infoRequest {
    pub fn new() -> get_volume_infoRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static get_volume_infoRequest {
        static mut instance: ::protobuf::lazy::Lazy<get_volume_infoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const get_volume_infoRequest,
        };
        unsafe {
            instance.get(get_volume_infoRequest::new)
        }
    }

    // required .rusix.Dict dict = 1;

    pub fn clear_dict(&mut self) {
        self.dict.clear();
    }

    pub fn has_dict(&self) -> bool {
        self.dict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dict(&mut self, v: Dict) {
        self.dict = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dict(&mut self) -> &mut Dict {
        if self.dict.is_none() {
            self.dict.set_default();
        }
        self.dict.as_mut().unwrap()
    }

    // Take field
    pub fn take_dict(&mut self) -> Dict {
        self.dict.take().unwrap_or_else(|| Dict::new())
    }

    pub fn get_dict(&self) -> &Dict {
        self.dict.as_ref().unwrap_or_else(|| Dict::default_instance())
    }

    fn get_dict_for_reflect(&self) -> &::protobuf::SingularPtrField<Dict> {
        &self.dict
    }

    fn mut_dict_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Dict> {
        &mut self.dict
    }
}

impl ::protobuf::Message for get_volume_infoRequest {
    fn is_initialized(&self) -> bool {
        if self.dict.is_none() {
            return false;
        }
        for v in &self.dict {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dict)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dict.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dict.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for get_volume_infoRequest {
    fn new() -> get_volume_infoRequest {
        get_volume_infoRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<get_volume_infoRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dict>>(
                    "dict",
                    get_volume_infoRequest::get_dict_for_reflect,
                    get_volume_infoRequest::mut_dict_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<get_volume_infoRequest>(
                    "get_volume_infoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for get_volume_infoRequest {
    fn clear(&mut self) {
        self.clear_dict();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for get_volume_infoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for get_volume_infoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct get_volume_infoResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    op_errstr: ::protobuf::SingularField<::std::string::String>,
    dict: ::protobuf::SingularPtrField<Dict>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for get_volume_infoResponse {}

impl get_volume_infoResponse {
    pub fn new() -> get_volume_infoResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static get_volume_infoResponse {
        static mut instance: ::protobuf::lazy::Lazy<get_volume_infoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const get_volume_infoResponse,
        };
        unsafe {
            instance.get(get_volume_infoResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional string op_errstr = 2;

    pub fn clear_op_errstr(&mut self) {
        self.op_errstr.clear();
    }

    pub fn has_op_errstr(&self) -> bool {
        self.op_errstr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_op_errstr(&mut self, v: ::std::string::String) {
        self.op_errstr = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op_errstr(&mut self) -> &mut ::std::string::String {
        if self.op_errstr.is_none() {
            self.op_errstr.set_default();
        }
        self.op_errstr.as_mut().unwrap()
    }

    // Take field
    pub fn take_op_errstr(&mut self) -> ::std::string::String {
        self.op_errstr.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_op_errstr(&self) -> &str {
        match self.op_errstr.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_op_errstr_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.op_errstr
    }

    fn mut_op_errstr_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.op_errstr
    }

    // optional .rusix.Dict dict = 3;

    pub fn clear_dict(&mut self) {
        self.dict.clear();
    }

    pub fn has_dict(&self) -> bool {
        self.dict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dict(&mut self, v: Dict) {
        self.dict = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dict(&mut self) -> &mut Dict {
        if self.dict.is_none() {
            self.dict.set_default();
        }
        self.dict.as_mut().unwrap()
    }

    // Take field
    pub fn take_dict(&mut self) -> Dict {
        self.dict.take().unwrap_or_else(|| Dict::new())
    }

    pub fn get_dict(&self) -> &Dict {
        self.dict.as_ref().unwrap_or_else(|| Dict::default_instance())
    }

    fn get_dict_for_reflect(&self) -> &::protobuf::SingularPtrField<Dict> {
        &self.dict
    }

    fn mut_dict_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Dict> {
        &mut self.dict
    }
}

impl ::protobuf::Message for get_volume_infoResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dict {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.op_errstr)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dict)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.op_errstr.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.dict.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.op_errstr.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.dict.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for get_volume_infoResponse {
    fn new() -> get_volume_infoResponse {
        get_volume_infoResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<get_volume_infoResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    get_volume_infoResponse::get_result_for_reflect,
                    get_volume_infoResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "op_errstr",
                    get_volume_infoResponse::get_op_errstr_for_reflect,
                    get_volume_infoResponse::mut_op_errstr_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dict>>(
                    "dict",
                    get_volume_infoResponse::get_dict_for_reflect,
                    get_volume_infoResponse::mut_dict_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<get_volume_infoResponse>(
                    "get_volume_infoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for get_volume_infoResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_op_errstr();
        self.clear_dict();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for get_volume_infoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for get_volume_infoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct mgmt_hndskRequest {
    // message fields
    hndsk: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for mgmt_hndskRequest {}

impl mgmt_hndskRequest {
    pub fn new() -> mgmt_hndskRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static mgmt_hndskRequest {
        static mut instance: ::protobuf::lazy::Lazy<mgmt_hndskRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const mgmt_hndskRequest,
        };
        unsafe {
            instance.get(mgmt_hndskRequest::new)
        }
    }

    // required bytes hndsk = 1;

    pub fn clear_hndsk(&mut self) {
        self.hndsk.clear();
    }

    pub fn has_hndsk(&self) -> bool {
        self.hndsk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hndsk(&mut self, v: ::std::vec::Vec<u8>) {
        self.hndsk = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hndsk(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hndsk.is_none() {
            self.hndsk.set_default();
        }
        self.hndsk.as_mut().unwrap()
    }

    // Take field
    pub fn take_hndsk(&mut self) -> ::std::vec::Vec<u8> {
        self.hndsk.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_hndsk(&self) -> &[u8] {
        match self.hndsk.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_hndsk_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.hndsk
    }

    fn mut_hndsk_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.hndsk
    }
}

impl ::protobuf::Message for mgmt_hndskRequest {
    fn is_initialized(&self) -> bool {
        if self.hndsk.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.hndsk)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.hndsk.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.hndsk.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for mgmt_hndskRequest {
    fn new() -> mgmt_hndskRequest {
        mgmt_hndskRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<mgmt_hndskRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hndsk",
                    mgmt_hndskRequest::get_hndsk_for_reflect,
                    mgmt_hndskRequest::mut_hndsk_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<mgmt_hndskRequest>(
                    "mgmt_hndskRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for mgmt_hndskRequest {
    fn clear(&mut self) {
        self.clear_hndsk();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for mgmt_hndskRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for mgmt_hndskRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct mgmt_hndskResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    hndsk: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for mgmt_hndskResponse {}

impl mgmt_hndskResponse {
    pub fn new() -> mgmt_hndskResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static mgmt_hndskResponse {
        static mut instance: ::protobuf::lazy::Lazy<mgmt_hndskResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const mgmt_hndskResponse,
        };
        unsafe {
            instance.get(mgmt_hndskResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional bytes hndsk = 2;

    pub fn clear_hndsk(&mut self) {
        self.hndsk.clear();
    }

    pub fn has_hndsk(&self) -> bool {
        self.hndsk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hndsk(&mut self, v: ::std::vec::Vec<u8>) {
        self.hndsk = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hndsk(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hndsk.is_none() {
            self.hndsk.set_default();
        }
        self.hndsk.as_mut().unwrap()
    }

    // Take field
    pub fn take_hndsk(&mut self) -> ::std::vec::Vec<u8> {
        self.hndsk.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_hndsk(&self) -> &[u8] {
        match self.hndsk.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_hndsk_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.hndsk
    }

    fn mut_hndsk_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.hndsk
    }
}

impl ::protobuf::Message for mgmt_hndskResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.hndsk)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.hndsk.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.hndsk.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for mgmt_hndskResponse {
    fn new() -> mgmt_hndskResponse {
        mgmt_hndskResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<mgmt_hndskResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    mgmt_hndskResponse::get_result_for_reflect,
                    mgmt_hndskResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hndsk",
                    mgmt_hndskResponse::get_hndsk_for_reflect,
                    mgmt_hndskResponse::mut_hndsk_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<mgmt_hndskResponse>(
                    "mgmt_hndskResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for mgmt_hndskResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_hndsk();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for mgmt_hndskResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for mgmt_hndskResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogRequest {
    // message fields
    msg: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for LogRequest {}

impl LogRequest {
    pub fn new() -> LogRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static LogRequest {
        static mut instance: ::protobuf::lazy::Lazy<LogRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LogRequest,
        };
        unsafe {
            instance.get(LogRequest::new)
        }
    }

    // required bytes msg = 1;

    pub fn clear_msg(&mut self) {
        self.msg.clear();
    }

    pub fn has_msg(&self) -> bool {
        self.msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg(&mut self, v: ::std::vec::Vec<u8>) {
        self.msg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.msg.is_none() {
            self.msg.set_default();
        }
        self.msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg(&mut self) -> ::std::vec::Vec<u8> {
        self.msg.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_msg(&self) -> &[u8] {
        match self.msg.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_msg_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.msg
    }

    fn mut_msg_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.msg
    }
}

impl ::protobuf::Message for LogRequest {
    fn is_initialized(&self) -> bool {
        if self.msg.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.msg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.msg.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.msg.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for LogRequest {
    fn new() -> LogRequest {
        LogRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<LogRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "msg",
                    LogRequest::get_msg_for_reflect,
                    LogRequest::mut_msg_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LogRequest>(
                    "LogRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for LogRequest {
    fn clear(&mut self) {
        self.clear_msg();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct notifyRequest {
    // message fields
    flags: ::std::option::Option<u32>,
    buf: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for notifyRequest {}

impl notifyRequest {
    pub fn new() -> notifyRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static notifyRequest {
        static mut instance: ::protobuf::lazy::Lazy<notifyRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const notifyRequest,
        };
        unsafe {
            instance.get(notifyRequest::new)
        }
    }

    // required uint32 flags = 1;

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    fn get_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.flags
    }

    fn mut_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.flags
    }

    // required string buf = 2;

    pub fn clear_buf(&mut self) {
        self.buf.clear();
    }

    pub fn has_buf(&self) -> bool {
        self.buf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buf(&mut self, v: ::std::string::String) {
        self.buf = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buf(&mut self) -> &mut ::std::string::String {
        if self.buf.is_none() {
            self.buf.set_default();
        }
        self.buf.as_mut().unwrap()
    }

    // Take field
    pub fn take_buf(&mut self) -> ::std::string::String {
        self.buf.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_buf(&self) -> &str {
        match self.buf.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_buf_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.buf
    }

    fn mut_buf_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.buf
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for notifyRequest {
    fn is_initialized(&self) -> bool {
        if self.flags.is_none() {
            return false;
        }
        if self.buf.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.buf)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.buf.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.flags {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.buf.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for notifyRequest {
    fn new() -> notifyRequest {
        notifyRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<notifyRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    notifyRequest::get_flags_for_reflect,
                    notifyRequest::mut_flags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "buf",
                    notifyRequest::get_buf_for_reflect,
                    notifyRequest::mut_buf_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    notifyRequest::get_extra_data_for_reflect,
                    notifyRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<notifyRequest>(
                    "notifyRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for notifyRequest {
    fn clear(&mut self) {
        self.clear_flags();
        self.clear_buf();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for notifyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for notifyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct notifyResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    flags: ::std::option::Option<u32>,
    buf: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for notifyResponse {}

impl notifyResponse {
    pub fn new() -> notifyResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static notifyResponse {
        static mut instance: ::protobuf::lazy::Lazy<notifyResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const notifyResponse,
        };
        unsafe {
            instance.get(notifyResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional uint32 flags = 2;

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    fn get_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.flags
    }

    fn mut_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.flags
    }

    // optional string buf = 3;

    pub fn clear_buf(&mut self) {
        self.buf.clear();
    }

    pub fn has_buf(&self) -> bool {
        self.buf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buf(&mut self, v: ::std::string::String) {
        self.buf = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buf(&mut self) -> &mut ::std::string::String {
        if self.buf.is_none() {
            self.buf.set_default();
        }
        self.buf.as_mut().unwrap()
    }

    // Take field
    pub fn take_buf(&mut self) -> ::std::string::String {
        self.buf.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_buf(&self) -> &str {
        match self.buf.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_buf_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.buf
    }

    fn mut_buf_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.buf
    }

    // optional bytes extra_data = 4;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for notifyResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.buf)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.buf.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.buf.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for notifyResponse {
    fn new() -> notifyResponse {
        notifyResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<notifyResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    notifyResponse::get_result_for_reflect,
                    notifyResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flags",
                    notifyResponse::get_flags_for_reflect,
                    notifyResponse::mut_flags_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "buf",
                    notifyResponse::get_buf_for_reflect,
                    notifyResponse::mut_buf_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    notifyResponse::get_extra_data_for_reflect,
                    notifyResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<notifyResponse>(
                    "notifyResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for notifyResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_flags();
        self.clear_buf();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for notifyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for notifyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReleasedirRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<u64>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ReleasedirRequest {}

impl ReleasedirRequest {
    pub fn new() -> ReleasedirRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ReleasedirRequest {
        static mut instance: ::protobuf::lazy::Lazy<ReleasedirRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReleasedirRequest,
        };
        unsafe {
            instance.get(ReleasedirRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for ReleasedirRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ReleasedirRequest {
    fn new() -> ReleasedirRequest {
        ReleasedirRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<ReleasedirRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    ReleasedirRequest::get_gfid_for_reflect,
                    ReleasedirRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    ReleasedirRequest::get_fd_for_reflect,
                    ReleasedirRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    ReleasedirRequest::get_extra_data_for_reflect,
                    ReleasedirRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReleasedirRequest>(
                    "ReleasedirRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ReleasedirRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReleasedirRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReleasedirRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReleaseRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    fd: ::std::option::Option<u64>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ReleaseRequest {}

impl ReleaseRequest {
    pub fn new() -> ReleaseRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ReleaseRequest {
        static mut instance: ::protobuf::lazy::Lazy<ReleaseRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReleaseRequest,
        };
        unsafe {
            instance.get(ReleaseRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required uint64 fd = 2;

    pub fn clear_fd(&mut self) {
        self.fd = ::std::option::Option::None;
    }

    pub fn has_fd(&self) -> bool {
        self.fd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fd(&mut self, v: u64) {
        self.fd = ::std::option::Option::Some(v);
    }

    pub fn get_fd(&self) -> u64 {
        self.fd.unwrap_or(0)
    }

    fn get_fd_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.fd
    }

    fn mut_fd_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.fd
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for ReleaseRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.fd.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fd = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fd {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.fd {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ReleaseRequest {
    fn new() -> ReleaseRequest {
        ReleaseRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<ReleaseRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    ReleaseRequest::get_gfid_for_reflect,
                    ReleaseRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fd",
                    ReleaseRequest::get_fd_for_reflect,
                    ReleaseRequest::mut_fd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    ReleaseRequest::get_extra_data_for_reflect,
                    ReleaseRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReleaseRequest>(
                    "ReleaseRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ReleaseRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_fd();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReleaseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReleaseRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirListEntry {
    // message fields
    d_ino: ::std::option::Option<u64>,
    d_off: ::std::option::Option<u64>,
    d_len: ::std::option::Option<u32>,
    d_type: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DirListEntry {}

impl DirListEntry {
    pub fn new() -> DirListEntry {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DirListEntry {
        static mut instance: ::protobuf::lazy::Lazy<DirListEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DirListEntry,
        };
        unsafe {
            instance.get(DirListEntry::new)
        }
    }

    // required uint64 d_ino = 1;

    pub fn clear_d_ino(&mut self) {
        self.d_ino = ::std::option::Option::None;
    }

    pub fn has_d_ino(&self) -> bool {
        self.d_ino.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d_ino(&mut self, v: u64) {
        self.d_ino = ::std::option::Option::Some(v);
    }

    pub fn get_d_ino(&self) -> u64 {
        self.d_ino.unwrap_or(0)
    }

    fn get_d_ino_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.d_ino
    }

    fn mut_d_ino_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.d_ino
    }

    // required uint64 d_off = 2;

    pub fn clear_d_off(&mut self) {
        self.d_off = ::std::option::Option::None;
    }

    pub fn has_d_off(&self) -> bool {
        self.d_off.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d_off(&mut self, v: u64) {
        self.d_off = ::std::option::Option::Some(v);
    }

    pub fn get_d_off(&self) -> u64 {
        self.d_off.unwrap_or(0)
    }

    fn get_d_off_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.d_off
    }

    fn mut_d_off_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.d_off
    }

    // required uint32 d_len = 3;

    pub fn clear_d_len(&mut self) {
        self.d_len = ::std::option::Option::None;
    }

    pub fn has_d_len(&self) -> bool {
        self.d_len.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d_len(&mut self, v: u32) {
        self.d_len = ::std::option::Option::Some(v);
    }

    pub fn get_d_len(&self) -> u32 {
        self.d_len.unwrap_or(0)
    }

    fn get_d_len_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.d_len
    }

    fn mut_d_len_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.d_len
    }

    // required uint32 d_type = 4;

    pub fn clear_d_type(&mut self) {
        self.d_type = ::std::option::Option::None;
    }

    pub fn has_d_type(&self) -> bool {
        self.d_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d_type(&mut self, v: u32) {
        self.d_type = ::std::option::Option::Some(v);
    }

    pub fn get_d_type(&self) -> u32 {
        self.d_type.unwrap_or(0)
    }

    fn get_d_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.d_type
    }

    fn mut_d_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.d_type
    }

    // required string name = 5;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }
}

impl ::protobuf::Message for DirListEntry {
    fn is_initialized(&self) -> bool {
        if self.d_ino.is_none() {
            return false;
        }
        if self.d_off.is_none() {
            return false;
        }
        if self.d_len.is_none() {
            return false;
        }
        if self.d_type.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.d_ino = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.d_off = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.d_len = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.d_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.d_ino {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.d_off {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.d_len {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.d_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.d_ino {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.d_off {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.d_len {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.d_type {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DirListEntry {
    fn new() -> DirListEntry {
        DirListEntry::new()
    }

    fn descriptor_static(_: ::std::option::Option<DirListEntry>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "d_ino",
                    DirListEntry::get_d_ino_for_reflect,
                    DirListEntry::mut_d_ino_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "d_off",
                    DirListEntry::get_d_off_for_reflect,
                    DirListEntry::mut_d_off_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "d_len",
                    DirListEntry::get_d_len_for_reflect,
                    DirListEntry::mut_d_len_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "d_type",
                    DirListEntry::get_d_type_for_reflect,
                    DirListEntry::mut_d_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    DirListEntry::get_name_for_reflect,
                    DirListEntry::mut_name_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DirListEntry>(
                    "DirListEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DirListEntry {
    fn clear(&mut self) {
        self.clear_d_ino();
        self.clear_d_off();
        self.clear_d_len();
        self.clear_d_type();
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirListEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirListEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirList {
    // message fields
    entry: ::protobuf::RepeatedField<DirListEntry>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DirList {}

impl DirList {
    pub fn new() -> DirList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DirList {
        static mut instance: ::protobuf::lazy::Lazy<DirList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DirList,
        };
        unsafe {
            instance.get(DirList::new)
        }
    }

    // repeated .rusix.DirListEntry entry = 1;

    pub fn clear_entry(&mut self) {
        self.entry.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry(&mut self, v: ::protobuf::RepeatedField<DirListEntry>) {
        self.entry = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entry(&mut self) -> &mut ::protobuf::RepeatedField<DirListEntry> {
        &mut self.entry
    }

    // Take field
    pub fn take_entry(&mut self) -> ::protobuf::RepeatedField<DirListEntry> {
        ::std::mem::replace(&mut self.entry, ::protobuf::RepeatedField::new())
    }

    pub fn get_entry(&self) -> &[DirListEntry] {
        &self.entry
    }

    fn get_entry_for_reflect(&self) -> &::protobuf::RepeatedField<DirListEntry> {
        &self.entry
    }

    fn mut_entry_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<DirListEntry> {
        &mut self.entry
    }
}

impl ::protobuf::Message for DirList {
    fn is_initialized(&self) -> bool {
        for v in &self.entry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entry {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DirList {
    fn new() -> DirList {
        DirList::new()
    }

    fn descriptor_static(_: ::std::option::Option<DirList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DirListEntry>>(
                    "entry",
                    DirList::get_entry_for_reflect,
                    DirList::mut_entry_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DirList>(
                    "DirList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DirList {
    fn clear(&mut self) {
        self.clear_entry();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReaddirResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    reply: ::protobuf::SingularPtrField<DirList>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ReaddirResponse {}

impl ReaddirResponse {
    pub fn new() -> ReaddirResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ReaddirResponse {
        static mut instance: ::protobuf::lazy::Lazy<ReaddirResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReaddirResponse,
        };
        unsafe {
            instance.get(ReaddirResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.DirList reply = 2;

    pub fn clear_reply(&mut self) {
        self.reply.clear();
    }

    pub fn has_reply(&self) -> bool {
        self.reply.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reply(&mut self, v: DirList) {
        self.reply = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reply(&mut self) -> &mut DirList {
        if self.reply.is_none() {
            self.reply.set_default();
        }
        self.reply.as_mut().unwrap()
    }

    // Take field
    pub fn take_reply(&mut self) -> DirList {
        self.reply.take().unwrap_or_else(|| DirList::new())
    }

    pub fn get_reply(&self) -> &DirList {
        self.reply.as_ref().unwrap_or_else(|| DirList::default_instance())
    }

    fn get_reply_for_reflect(&self) -> &::protobuf::SingularPtrField<DirList> {
        &self.reply
    }

    fn mut_reply_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<DirList> {
        &mut self.reply
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for ReaddirResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reply {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reply)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reply.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reply.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ReaddirResponse {
    fn new() -> ReaddirResponse {
        ReaddirResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<ReaddirResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    ReaddirResponse::get_result_for_reflect,
                    ReaddirResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DirList>>(
                    "reply",
                    ReaddirResponse::get_reply_for_reflect,
                    ReaddirResponse::mut_reply_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    ReaddirResponse::get_extra_data_for_reflect,
                    ReaddirResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReaddirResponse>(
                    "ReaddirResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ReaddirResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_reply();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReaddirResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReaddirResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirPListEntry {
    // message fields
    d_ino: ::std::option::Option<u64>,
    d_off: ::std::option::Option<u64>,
    d_len: ::std::option::Option<u32>,
    d_type: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    stat: ::protobuf::SingularPtrField<Iatt>,
    dict: ::protobuf::SingularPtrField<Dict>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DirPListEntry {}

impl DirPListEntry {
    pub fn new() -> DirPListEntry {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DirPListEntry {
        static mut instance: ::protobuf::lazy::Lazy<DirPListEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DirPListEntry,
        };
        unsafe {
            instance.get(DirPListEntry::new)
        }
    }

    // required uint64 d_ino = 1;

    pub fn clear_d_ino(&mut self) {
        self.d_ino = ::std::option::Option::None;
    }

    pub fn has_d_ino(&self) -> bool {
        self.d_ino.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d_ino(&mut self, v: u64) {
        self.d_ino = ::std::option::Option::Some(v);
    }

    pub fn get_d_ino(&self) -> u64 {
        self.d_ino.unwrap_or(0)
    }

    fn get_d_ino_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.d_ino
    }

    fn mut_d_ino_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.d_ino
    }

    // required uint64 d_off = 2;

    pub fn clear_d_off(&mut self) {
        self.d_off = ::std::option::Option::None;
    }

    pub fn has_d_off(&self) -> bool {
        self.d_off.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d_off(&mut self, v: u64) {
        self.d_off = ::std::option::Option::Some(v);
    }

    pub fn get_d_off(&self) -> u64 {
        self.d_off.unwrap_or(0)
    }

    fn get_d_off_for_reflect(&self) -> &::std::option::Option<u64> {
        &self.d_off
    }

    fn mut_d_off_for_reflect(&mut self) -> &mut ::std::option::Option<u64> {
        &mut self.d_off
    }

    // required uint32 d_len = 3;

    pub fn clear_d_len(&mut self) {
        self.d_len = ::std::option::Option::None;
    }

    pub fn has_d_len(&self) -> bool {
        self.d_len.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d_len(&mut self, v: u32) {
        self.d_len = ::std::option::Option::Some(v);
    }

    pub fn get_d_len(&self) -> u32 {
        self.d_len.unwrap_or(0)
    }

    fn get_d_len_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.d_len
    }

    fn mut_d_len_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.d_len
    }

    // required uint32 d_type = 4;

    pub fn clear_d_type(&mut self) {
        self.d_type = ::std::option::Option::None;
    }

    pub fn has_d_type(&self) -> bool {
        self.d_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d_type(&mut self, v: u32) {
        self.d_type = ::std::option::Option::Some(v);
    }

    pub fn get_d_type(&self) -> u32 {
        self.d_type.unwrap_or(0)
    }

    fn get_d_type_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.d_type
    }

    fn mut_d_type_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.d_type
    }

    // required string name = 5;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // required .rusix.Iatt stat = 6;

    pub fn clear_stat(&mut self) {
        self.stat.clear();
    }

    pub fn has_stat(&self) -> bool {
        self.stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: Iatt) {
        self.stat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat(&mut self) -> &mut Iatt {
        if self.stat.is_none() {
            self.stat.set_default();
        }
        self.stat.as_mut().unwrap()
    }

    // Take field
    pub fn take_stat(&mut self) -> Iatt {
        self.stat.take().unwrap_or_else(|| Iatt::new())
    }

    pub fn get_stat(&self) -> &Iatt {
        self.stat.as_ref().unwrap_or_else(|| Iatt::default_instance())
    }

    fn get_stat_for_reflect(&self) -> &::protobuf::SingularPtrField<Iatt> {
        &self.stat
    }

    fn mut_stat_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Iatt> {
        &mut self.stat
    }

    // required .rusix.Dict dict = 7;

    pub fn clear_dict(&mut self) {
        self.dict.clear();
    }

    pub fn has_dict(&self) -> bool {
        self.dict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dict(&mut self, v: Dict) {
        self.dict = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dict(&mut self) -> &mut Dict {
        if self.dict.is_none() {
            self.dict.set_default();
        }
        self.dict.as_mut().unwrap()
    }

    // Take field
    pub fn take_dict(&mut self) -> Dict {
        self.dict.take().unwrap_or_else(|| Dict::new())
    }

    pub fn get_dict(&self) -> &Dict {
        self.dict.as_ref().unwrap_or_else(|| Dict::default_instance())
    }

    fn get_dict_for_reflect(&self) -> &::protobuf::SingularPtrField<Dict> {
        &self.dict
    }

    fn mut_dict_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Dict> {
        &mut self.dict
    }
}

impl ::protobuf::Message for DirPListEntry {
    fn is_initialized(&self) -> bool {
        if self.d_ino.is_none() {
            return false;
        }
        if self.d_off.is_none() {
            return false;
        }
        if self.d_len.is_none() {
            return false;
        }
        if self.d_type.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        if self.stat.is_none() {
            return false;
        }
        if self.dict.is_none() {
            return false;
        }
        for v in &self.stat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dict {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.d_ino = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.d_off = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.d_len = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.d_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stat)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dict)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.d_ino {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.d_off {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.d_len {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.d_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dict.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.d_ino {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.d_off {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.d_len {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.d_type {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.stat.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dict.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DirPListEntry {
    fn new() -> DirPListEntry {
        DirPListEntry::new()
    }

    fn descriptor_static(_: ::std::option::Option<DirPListEntry>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "d_ino",
                    DirPListEntry::get_d_ino_for_reflect,
                    DirPListEntry::mut_d_ino_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "d_off",
                    DirPListEntry::get_d_off_for_reflect,
                    DirPListEntry::mut_d_off_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "d_len",
                    DirPListEntry::get_d_len_for_reflect,
                    DirPListEntry::mut_d_len_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "d_type",
                    DirPListEntry::get_d_type_for_reflect,
                    DirPListEntry::mut_d_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    DirPListEntry::get_name_for_reflect,
                    DirPListEntry::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Iatt>>(
                    "stat",
                    DirPListEntry::get_stat_for_reflect,
                    DirPListEntry::mut_stat_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dict>>(
                    "dict",
                    DirPListEntry::get_dict_for_reflect,
                    DirPListEntry::mut_dict_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DirPListEntry>(
                    "DirPListEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DirPListEntry {
    fn clear(&mut self) {
        self.clear_d_ino();
        self.clear_d_off();
        self.clear_d_len();
        self.clear_d_type();
        self.clear_name();
        self.clear_stat();
        self.clear_dict();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirPListEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirPListEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirPList {
    // message fields
    entry: ::protobuf::RepeatedField<DirPListEntry>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DirPList {}

impl DirPList {
    pub fn new() -> DirPList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DirPList {
        static mut instance: ::protobuf::lazy::Lazy<DirPList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DirPList,
        };
        unsafe {
            instance.get(DirPList::new)
        }
    }

    // repeated .rusix.DirPListEntry entry = 1;

    pub fn clear_entry(&mut self) {
        self.entry.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry(&mut self, v: ::protobuf::RepeatedField<DirPListEntry>) {
        self.entry = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entry(&mut self) -> &mut ::protobuf::RepeatedField<DirPListEntry> {
        &mut self.entry
    }

    // Take field
    pub fn take_entry(&mut self) -> ::protobuf::RepeatedField<DirPListEntry> {
        ::std::mem::replace(&mut self.entry, ::protobuf::RepeatedField::new())
    }

    pub fn get_entry(&self) -> &[DirPListEntry] {
        &self.entry
    }

    fn get_entry_for_reflect(&self) -> &::protobuf::RepeatedField<DirPListEntry> {
        &self.entry
    }

    fn mut_entry_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<DirPListEntry> {
        &mut self.entry
    }
}

impl ::protobuf::Message for DirPList {
    fn is_initialized(&self) -> bool {
        for v in &self.entry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entry {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DirPList {
    fn new() -> DirPList {
        DirPList::new()
    }

    fn descriptor_static(_: ::std::option::Option<DirPList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DirPListEntry>>(
                    "entry",
                    DirPList::get_entry_for_reflect,
                    DirPList::mut_entry_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DirPList>(
                    "DirPList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DirPList {
    fn clear(&mut self) {
        self.clear_entry();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirPList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirPList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct readdirpResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    reply: ::protobuf::SingularPtrField<DirPList>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for readdirpResponse {}

impl readdirpResponse {
    pub fn new() -> readdirpResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static readdirpResponse {
        static mut instance: ::protobuf::lazy::Lazy<readdirpResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const readdirpResponse,
        };
        unsafe {
            instance.get(readdirpResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.DirPList reply = 2;

    pub fn clear_reply(&mut self) {
        self.reply.clear();
    }

    pub fn has_reply(&self) -> bool {
        self.reply.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reply(&mut self, v: DirPList) {
        self.reply = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reply(&mut self) -> &mut DirPList {
        if self.reply.is_none() {
            self.reply.set_default();
        }
        self.reply.as_mut().unwrap()
    }

    // Take field
    pub fn take_reply(&mut self) -> DirPList {
        self.reply.take().unwrap_or_else(|| DirPList::new())
    }

    pub fn get_reply(&self) -> &DirPList {
        self.reply.as_ref().unwrap_or_else(|| DirPList::default_instance())
    }

    fn get_reply_for_reflect(&self) -> &::protobuf::SingularPtrField<DirPList> {
        &self.reply
    }

    fn mut_reply_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<DirPList> {
        &mut self.reply
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for readdirpResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reply {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reply)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reply.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reply.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for readdirpResponse {
    fn new() -> readdirpResponse {
        readdirpResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<readdirpResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    readdirpResponse::get_result_for_reflect,
                    readdirpResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DirPList>>(
                    "reply",
                    readdirpResponse::get_reply_for_reflect,
                    readdirpResponse::mut_reply_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    readdirpResponse::get_extra_data_for_reflect,
                    readdirpResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<readdirpResponse>(
                    "readdirpResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for readdirpResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_reply();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for readdirpResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for readdirpResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Set_lk_verResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    lk_ver: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Set_lk_verResponse {}

impl Set_lk_verResponse {
    pub fn new() -> Set_lk_verResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Set_lk_verResponse {
        static mut instance: ::protobuf::lazy::Lazy<Set_lk_verResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Set_lk_verResponse,
        };
        unsafe {
            instance.get(Set_lk_verResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional int32 lk_ver = 2;

    pub fn clear_lk_ver(&mut self) {
        self.lk_ver = ::std::option::Option::None;
    }

    pub fn has_lk_ver(&self) -> bool {
        self.lk_ver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lk_ver(&mut self, v: i32) {
        self.lk_ver = ::std::option::Option::Some(v);
    }

    pub fn get_lk_ver(&self) -> i32 {
        self.lk_ver.unwrap_or(0)
    }

    fn get_lk_ver_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.lk_ver
    }

    fn mut_lk_ver_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.lk_ver
    }
}

impl ::protobuf::Message for Set_lk_verResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lk_ver = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.lk_ver {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.lk_ver {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Set_lk_verResponse {
    fn new() -> Set_lk_verResponse {
        Set_lk_verResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<Set_lk_verResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    Set_lk_verResponse::get_result_for_reflect,
                    Set_lk_verResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "lk_ver",
                    Set_lk_verResponse::get_lk_ver_for_reflect,
                    Set_lk_verResponse::mut_lk_ver_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Set_lk_verResponse>(
                    "Set_lk_verResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Set_lk_verResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_lk_ver();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Set_lk_verResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Set_lk_verResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Set_lk_verRequest {
    // message fields
    uid: ::protobuf::SingularField<::std::string::String>,
    lk_ver: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Set_lk_verRequest {}

impl Set_lk_verRequest {
    pub fn new() -> Set_lk_verRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Set_lk_verRequest {
        static mut instance: ::protobuf::lazy::Lazy<Set_lk_verRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Set_lk_verRequest,
        };
        unsafe {
            instance.get(Set_lk_verRequest::new)
        }
    }

    // required string uid = 1;

    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid.set_default();
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_uid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.uid
    }

    fn mut_uid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.uid
    }

    // required int32 lk_ver = 2;

    pub fn clear_lk_ver(&mut self) {
        self.lk_ver = ::std::option::Option::None;
    }

    pub fn has_lk_ver(&self) -> bool {
        self.lk_ver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lk_ver(&mut self, v: i32) {
        self.lk_ver = ::std::option::Option::Some(v);
    }

    pub fn get_lk_ver(&self) -> i32 {
        self.lk_ver.unwrap_or(0)
    }

    fn get_lk_ver_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.lk_ver
    }

    fn mut_lk_ver_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.lk_ver
    }
}

impl ::protobuf::Message for Set_lk_verRequest {
    fn is_initialized(&self) -> bool {
        if self.uid.is_none() {
            return false;
        }
        if self.lk_ver.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lk_ver = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.lk_ver {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.uid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.lk_ver {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Set_lk_verRequest {
    fn new() -> Set_lk_verRequest {
        Set_lk_verRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<Set_lk_verRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uid",
                    Set_lk_verRequest::get_uid_for_reflect,
                    Set_lk_verRequest::mut_uid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "lk_ver",
                    Set_lk_verRequest::get_lk_ver_for_reflect,
                    Set_lk_verRequest::mut_lk_ver_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Set_lk_verRequest>(
                    "Set_lk_verRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Set_lk_verRequest {
    fn clear(&mut self) {
        self.clear_uid();
        self.clear_lk_ver();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Set_lk_verRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Set_lk_verRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventNotifyRequest {
    // message fields
    op: ::std::option::Option<i32>,
    dict: ::protobuf::SingularPtrField<Dict>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for EventNotifyRequest {}

impl EventNotifyRequest {
    pub fn new() -> EventNotifyRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static EventNotifyRequest {
        static mut instance: ::protobuf::lazy::Lazy<EventNotifyRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EventNotifyRequest,
        };
        unsafe {
            instance.get(EventNotifyRequest::new)
        }
    }

    // required int32 op = 1;

    pub fn clear_op(&mut self) {
        self.op = ::std::option::Option::None;
    }

    pub fn has_op(&self) -> bool {
        self.op.is_some()
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: i32) {
        self.op = ::std::option::Option::Some(v);
    }

    pub fn get_op(&self) -> i32 {
        self.op.unwrap_or(0)
    }

    fn get_op_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.op
    }

    fn mut_op_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.op
    }

    // required .rusix.Dict dict = 2;

    pub fn clear_dict(&mut self) {
        self.dict.clear();
    }

    pub fn has_dict(&self) -> bool {
        self.dict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dict(&mut self, v: Dict) {
        self.dict = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dict(&mut self) -> &mut Dict {
        if self.dict.is_none() {
            self.dict.set_default();
        }
        self.dict.as_mut().unwrap()
    }

    // Take field
    pub fn take_dict(&mut self) -> Dict {
        self.dict.take().unwrap_or_else(|| Dict::new())
    }

    pub fn get_dict(&self) -> &Dict {
        self.dict.as_ref().unwrap_or_else(|| Dict::default_instance())
    }

    fn get_dict_for_reflect(&self) -> &::protobuf::SingularPtrField<Dict> {
        &self.dict
    }

    fn mut_dict_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Dict> {
        &mut self.dict
    }
}

impl ::protobuf::Message for EventNotifyRequest {
    fn is_initialized(&self) -> bool {
        if self.op.is_none() {
            return false;
        }
        if self.dict.is_none() {
            return false;
        }
        for v in &self.dict {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.op = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dict)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.op {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.dict.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.op {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.dict.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for EventNotifyRequest {
    fn new() -> EventNotifyRequest {
        EventNotifyRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<EventNotifyRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "op",
                    EventNotifyRequest::get_op_for_reflect,
                    EventNotifyRequest::mut_op_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dict>>(
                    "dict",
                    EventNotifyRequest::get_dict_for_reflect,
                    EventNotifyRequest::mut_dict_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EventNotifyRequest>(
                    "EventNotifyRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for EventNotifyRequest {
    fn clear(&mut self) {
        self.clear_op();
        self.clear_dict();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventNotifyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventNotifyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventNotifyResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    dict: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for EventNotifyResponse {}

impl EventNotifyResponse {
    pub fn new() -> EventNotifyResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static EventNotifyResponse {
        static mut instance: ::protobuf::lazy::Lazy<EventNotifyResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EventNotifyResponse,
        };
        unsafe {
            instance.get(EventNotifyResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional bytes dict = 2;

    pub fn clear_dict(&mut self) {
        self.dict.clear();
    }

    pub fn has_dict(&self) -> bool {
        self.dict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dict(&mut self, v: ::std::vec::Vec<u8>) {
        self.dict = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dict(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.dict.is_none() {
            self.dict.set_default();
        }
        self.dict.as_mut().unwrap()
    }

    // Take field
    pub fn take_dict(&mut self) -> ::std::vec::Vec<u8> {
        self.dict.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_dict(&self) -> &[u8] {
        match self.dict.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_dict_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.dict
    }

    fn mut_dict_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.dict
    }
}

impl ::protobuf::Message for EventNotifyResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.dict)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dict.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dict.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for EventNotifyResponse {
    fn new() -> EventNotifyResponse {
        EventNotifyResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<EventNotifyResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    EventNotifyResponse::get_result_for_reflect,
                    EventNotifyResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "dict",
                    EventNotifyResponse::get_dict_for_reflect,
                    EventNotifyResponse::mut_dict_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EventNotifyResponse>(
                    "EventNotifyResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for EventNotifyResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_dict();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventNotifyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventNotifyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapNameUuidRequest {
    // message fields
    dict: ::protobuf::SingularPtrField<Dict>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetSnapNameUuidRequest {}

impl GetSnapNameUuidRequest {
    pub fn new() -> GetSnapNameUuidRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetSnapNameUuidRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetSnapNameUuidRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSnapNameUuidRequest,
        };
        unsafe {
            instance.get(GetSnapNameUuidRequest::new)
        }
    }

    // required .rusix.Dict dict = 1;

    pub fn clear_dict(&mut self) {
        self.dict.clear();
    }

    pub fn has_dict(&self) -> bool {
        self.dict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dict(&mut self, v: Dict) {
        self.dict = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dict(&mut self) -> &mut Dict {
        if self.dict.is_none() {
            self.dict.set_default();
        }
        self.dict.as_mut().unwrap()
    }

    // Take field
    pub fn take_dict(&mut self) -> Dict {
        self.dict.take().unwrap_or_else(|| Dict::new())
    }

    pub fn get_dict(&self) -> &Dict {
        self.dict.as_ref().unwrap_or_else(|| Dict::default_instance())
    }

    fn get_dict_for_reflect(&self) -> &::protobuf::SingularPtrField<Dict> {
        &self.dict
    }

    fn mut_dict_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Dict> {
        &mut self.dict
    }
}

impl ::protobuf::Message for GetSnapNameUuidRequest {
    fn is_initialized(&self) -> bool {
        if self.dict.is_none() {
            return false;
        }
        for v in &self.dict {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dict)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dict.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dict.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetSnapNameUuidRequest {
    fn new() -> GetSnapNameUuidRequest {
        GetSnapNameUuidRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetSnapNameUuidRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dict>>(
                    "dict",
                    GetSnapNameUuidRequest::get_dict_for_reflect,
                    GetSnapNameUuidRequest::mut_dict_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetSnapNameUuidRequest>(
                    "GetSnapNameUuidRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetSnapNameUuidRequest {
    fn clear(&mut self) {
        self.clear_dict();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapNameUuidRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapNameUuidRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapNameUuidResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    dict: ::protobuf::SingularPtrField<Dict>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetSnapNameUuidResponse {}

impl GetSnapNameUuidResponse {
    pub fn new() -> GetSnapNameUuidResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetSnapNameUuidResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetSnapNameUuidResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSnapNameUuidResponse,
        };
        unsafe {
            instance.get(GetSnapNameUuidResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.Dict dict = 2;

    pub fn clear_dict(&mut self) {
        self.dict.clear();
    }

    pub fn has_dict(&self) -> bool {
        self.dict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dict(&mut self, v: Dict) {
        self.dict = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dict(&mut self) -> &mut Dict {
        if self.dict.is_none() {
            self.dict.set_default();
        }
        self.dict.as_mut().unwrap()
    }

    // Take field
    pub fn take_dict(&mut self) -> Dict {
        self.dict.take().unwrap_or_else(|| Dict::new())
    }

    pub fn get_dict(&self) -> &Dict {
        self.dict.as_ref().unwrap_or_else(|| Dict::default_instance())
    }

    fn get_dict_for_reflect(&self) -> &::protobuf::SingularPtrField<Dict> {
        &self.dict
    }

    fn mut_dict_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Dict> {
        &mut self.dict
    }
}

impl ::protobuf::Message for GetSnapNameUuidResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dict {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dict)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dict.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dict.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetSnapNameUuidResponse {
    fn new() -> GetSnapNameUuidResponse {
        GetSnapNameUuidResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetSnapNameUuidResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    GetSnapNameUuidResponse::get_result_for_reflect,
                    GetSnapNameUuidResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dict>>(
                    "dict",
                    GetSnapNameUuidResponse::get_dict_for_reflect,
                    GetSnapNameUuidResponse::mut_dict_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetSnapNameUuidResponse>(
                    "GetSnapNameUuidResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetSnapNameUuidResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_dict();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapNameUuidResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapNameUuidResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct compoundRequest {
    // message fields
    compound_version: ::std::option::Option<i32>,
    requests: ::std::vec::Vec<Fop>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for compoundRequest {}

impl compoundRequest {
    pub fn new() -> compoundRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static compoundRequest {
        static mut instance: ::protobuf::lazy::Lazy<compoundRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const compoundRequest,
        };
        unsafe {
            instance.get(compoundRequest::new)
        }
    }

    // required int32 compound_version = 1;

    pub fn clear_compound_version(&mut self) {
        self.compound_version = ::std::option::Option::None;
    }

    pub fn has_compound_version(&self) -> bool {
        self.compound_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compound_version(&mut self, v: i32) {
        self.compound_version = ::std::option::Option::Some(v);
    }

    pub fn get_compound_version(&self) -> i32 {
        self.compound_version.unwrap_or(0)
    }

    fn get_compound_version_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.compound_version
    }

    fn mut_compound_version_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.compound_version
    }

    // repeated .rusix.Fop requests = 2;

    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::std::vec::Vec<Fop>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::std::vec::Vec<Fop> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::std::vec::Vec<Fop> {
        ::std::mem::replace(&mut self.requests, ::std::vec::Vec::new())
    }

    pub fn get_requests(&self) -> &[Fop] {
        &self.requests
    }

    fn get_requests_for_reflect(&self) -> &::std::vec::Vec<Fop> {
        &self.requests
    }

    fn mut_requests_for_reflect(&mut self) -> &mut ::std::vec::Vec<Fop> {
        &mut self.requests
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for compoundRequest {
    fn is_initialized(&self) -> bool {
        if self.compound_version.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.compound_version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_enum_into(wire_type, is, &mut self.requests)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.compound_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.requests {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.compound_version {
            os.write_int32(1, v)?;
        }
        for v in &self.requests {
            os.write_enum(2, v.value())?;
        };
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for compoundRequest {
    fn new() -> compoundRequest {
        compoundRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<compoundRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "compound_version",
                    compoundRequest::get_compound_version_for_reflect,
                    compoundRequest::mut_compound_version_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Fop>>(
                    "requests",
                    compoundRequest::get_requests_for_reflect,
                    compoundRequest::mut_requests_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    compoundRequest::get_extra_data_for_reflect,
                    compoundRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<compoundRequest>(
                    "compoundRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for compoundRequest {
    fn clear(&mut self) {
        self.clear_compound_version();
        self.clear_requests();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for compoundRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for compoundRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompoundResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CompoundResponse {}

impl CompoundResponse {
    pub fn new() -> CompoundResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CompoundResponse {
        static mut instance: ::protobuf::lazy::Lazy<CompoundResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompoundResponse,
        };
        unsafe {
            instance.get(CompoundResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional bytes extra_data = 2;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for CompoundResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CompoundResponse {
    fn new() -> CompoundResponse {
        CompoundResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CompoundResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    CompoundResponse::get_result_for_reflect,
                    CompoundResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    CompoundResponse::get_extra_data_for_reflect,
                    CompoundResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CompoundResponse>(
                    "CompoundResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CompoundResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompoundResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompoundResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocklistEntry {
    // message fields
    flock: ::protobuf::SingularPtrField<ProtoFlock>,
    client_uid: ::protobuf::SingularField<::std::string::String>,
    lk_flags: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for LocklistEntry {}

impl LocklistEntry {
    pub fn new() -> LocklistEntry {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static LocklistEntry {
        static mut instance: ::protobuf::lazy::Lazy<LocklistEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LocklistEntry,
        };
        unsafe {
            instance.get(LocklistEntry::new)
        }
    }

    // required .rusix.ProtoFlock flock = 1;

    pub fn clear_flock(&mut self) {
        self.flock.clear();
    }

    pub fn has_flock(&self) -> bool {
        self.flock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flock(&mut self, v: ProtoFlock) {
        self.flock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flock(&mut self) -> &mut ProtoFlock {
        if self.flock.is_none() {
            self.flock.set_default();
        }
        self.flock.as_mut().unwrap()
    }

    // Take field
    pub fn take_flock(&mut self) -> ProtoFlock {
        self.flock.take().unwrap_or_else(|| ProtoFlock::new())
    }

    pub fn get_flock(&self) -> &ProtoFlock {
        self.flock.as_ref().unwrap_or_else(|| ProtoFlock::default_instance())
    }

    fn get_flock_for_reflect(&self) -> &::protobuf::SingularPtrField<ProtoFlock> {
        &self.flock
    }

    fn mut_flock_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ProtoFlock> {
        &mut self.flock
    }

    // required string client_uid = 2;

    pub fn clear_client_uid(&mut self) {
        self.client_uid.clear();
    }

    pub fn has_client_uid(&self) -> bool {
        self.client_uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_uid(&mut self, v: ::std::string::String) {
        self.client_uid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_uid(&mut self) -> &mut ::std::string::String {
        if self.client_uid.is_none() {
            self.client_uid.set_default();
        }
        self.client_uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_uid(&mut self) -> ::std::string::String {
        self.client_uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_client_uid(&self) -> &str {
        match self.client_uid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_client_uid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.client_uid
    }

    fn mut_client_uid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.client_uid
    }

    // required uint32 lk_flags = 3;

    pub fn clear_lk_flags(&mut self) {
        self.lk_flags = ::std::option::Option::None;
    }

    pub fn has_lk_flags(&self) -> bool {
        self.lk_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lk_flags(&mut self, v: u32) {
        self.lk_flags = ::std::option::Option::Some(v);
    }

    pub fn get_lk_flags(&self) -> u32 {
        self.lk_flags.unwrap_or(0)
    }

    fn get_lk_flags_for_reflect(&self) -> &::std::option::Option<u32> {
        &self.lk_flags
    }

    fn mut_lk_flags_for_reflect(&mut self) -> &mut ::std::option::Option<u32> {
        &mut self.lk_flags
    }
}

impl ::protobuf::Message for LocklistEntry {
    fn is_initialized(&self) -> bool {
        if self.flock.is_none() {
            return false;
        }
        if self.client_uid.is_none() {
            return false;
        }
        if self.lk_flags.is_none() {
            return false;
        }
        for v in &self.flock {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flock)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.client_uid)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lk_flags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.flock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.client_uid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lk_flags {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.flock.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.client_uid.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.lk_flags {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for LocklistEntry {
    fn new() -> LocklistEntry {
        LocklistEntry::new()
    }

    fn descriptor_static(_: ::std::option::Option<LocklistEntry>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProtoFlock>>(
                    "flock",
                    LocklistEntry::get_flock_for_reflect,
                    LocklistEntry::mut_flock_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "client_uid",
                    LocklistEntry::get_client_uid_for_reflect,
                    LocklistEntry::mut_client_uid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "lk_flags",
                    LocklistEntry::get_lk_flags_for_reflect,
                    LocklistEntry::mut_lk_flags_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LocklistEntry>(
                    "LocklistEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for LocklistEntry {
    fn clear(&mut self) {
        self.clear_flock();
        self.clear_client_uid();
        self.clear_lk_flags();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocklistEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocklistEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LockList {
    // message fields
    entry: ::protobuf::RepeatedField<LocklistEntry>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for LockList {}

impl LockList {
    pub fn new() -> LockList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static LockList {
        static mut instance: ::protobuf::lazy::Lazy<LockList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LockList,
        };
        unsafe {
            instance.get(LockList::new)
        }
    }

    // repeated .rusix.LocklistEntry entry = 1;

    pub fn clear_entry(&mut self) {
        self.entry.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry(&mut self, v: ::protobuf::RepeatedField<LocklistEntry>) {
        self.entry = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entry(&mut self) -> &mut ::protobuf::RepeatedField<LocklistEntry> {
        &mut self.entry
    }

    // Take field
    pub fn take_entry(&mut self) -> ::protobuf::RepeatedField<LocklistEntry> {
        ::std::mem::replace(&mut self.entry, ::protobuf::RepeatedField::new())
    }

    pub fn get_entry(&self) -> &[LocklistEntry] {
        &self.entry
    }

    fn get_entry_for_reflect(&self) -> &::protobuf::RepeatedField<LocklistEntry> {
        &self.entry
    }

    fn mut_entry_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<LocklistEntry> {
        &mut self.entry
    }
}

impl ::protobuf::Message for LockList {
    fn is_initialized(&self) -> bool {
        for v in &self.entry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entry {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for LockList {
    fn new() -> LockList {
        LockList::new()
    }

    fn descriptor_static(_: ::std::option::Option<LockList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocklistEntry>>(
                    "entry",
                    LockList::get_entry_for_reflect,
                    LockList::mut_entry_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LockList>(
                    "LockList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for LockList {
    fn clear(&mut self) {
        self.clear_entry();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LockList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LockList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetactivelkResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    reply: ::protobuf::SingularPtrField<LockList>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetactivelkResponse {}

impl GetactivelkResponse {
    pub fn new() -> GetactivelkResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetactivelkResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetactivelkResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetactivelkResponse,
        };
        unsafe {
            instance.get(GetactivelkResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional .rusix.LockList reply = 2;

    pub fn clear_reply(&mut self) {
        self.reply.clear();
    }

    pub fn has_reply(&self) -> bool {
        self.reply.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reply(&mut self, v: LockList) {
        self.reply = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reply(&mut self) -> &mut LockList {
        if self.reply.is_none() {
            self.reply.set_default();
        }
        self.reply.as_mut().unwrap()
    }

    // Take field
    pub fn take_reply(&mut self) -> LockList {
        self.reply.take().unwrap_or_else(|| LockList::new())
    }

    pub fn get_reply(&self) -> &LockList {
        self.reply.as_ref().unwrap_or_else(|| LockList::default_instance())
    }

    fn get_reply_for_reflect(&self) -> &::protobuf::SingularPtrField<LockList> {
        &self.reply
    }

    fn mut_reply_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<LockList> {
        &mut self.reply
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for GetactivelkResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reply {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reply)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reply.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reply.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetactivelkResponse {
    fn new() -> GetactivelkResponse {
        GetactivelkResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetactivelkResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    GetactivelkResponse::get_result_for_reflect,
                    GetactivelkResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LockList>>(
                    "reply",
                    GetactivelkResponse::get_reply_for_reflect,
                    GetactivelkResponse::mut_reply_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    GetactivelkResponse::get_extra_data_for_reflect,
                    GetactivelkResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetactivelkResponse>(
                    "GetactivelkResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetactivelkResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_reply();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetactivelkResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetactivelkResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetactivelkRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GetactivelkRequest {}

impl GetactivelkRequest {
    pub fn new() -> GetactivelkRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GetactivelkRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetactivelkRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetactivelkRequest,
        };
        unsafe {
            instance.get(GetactivelkRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // optional bytes extra_data = 2;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for GetactivelkRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GetactivelkRequest {
    fn new() -> GetactivelkRequest {
        GetactivelkRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<GetactivelkRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    GetactivelkRequest::get_gfid_for_reflect,
                    GetactivelkRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    GetactivelkRequest::get_extra_data_for_reflect,
                    GetactivelkRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetactivelkRequest>(
                    "GetactivelkRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GetactivelkRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetactivelkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetactivelkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetactivelkResponse {
    // message fields
    result: ::protobuf::SingularPtrField<OpResult>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetactivelkResponse {}

impl SetactivelkResponse {
    pub fn new() -> SetactivelkResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetactivelkResponse {
        static mut instance: ::protobuf::lazy::Lazy<SetactivelkResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetactivelkResponse,
        };
        unsafe {
            instance.get(SetactivelkResponse::new)
        }
    }

    // required .rusix.OpResult result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OpResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut OpResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> OpResult {
        self.result.take().unwrap_or_else(|| OpResult::new())
    }

    pub fn get_result(&self) -> &OpResult {
        self.result.as_ref().unwrap_or_else(|| OpResult::default_instance())
    }

    fn get_result_for_reflect(&self) -> &::protobuf::SingularPtrField<OpResult> {
        &self.result
    }

    fn mut_result_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<OpResult> {
        &mut self.result
    }

    // optional bytes extra_data = 2;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for SetactivelkResponse {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetactivelkResponse {
    fn new() -> SetactivelkResponse {
        SetactivelkResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetactivelkResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpResult>>(
                    "result",
                    SetactivelkResponse::get_result_for_reflect,
                    SetactivelkResponse::mut_result_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    SetactivelkResponse::get_extra_data_for_reflect,
                    SetactivelkResponse::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetactivelkResponse>(
                    "SetactivelkResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetactivelkResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetactivelkResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetactivelkResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetactivelkRequest {
    // message fields
    gfid: ::protobuf::SingularField<::std::string::String>,
    request: ::protobuf::SingularPtrField<LockList>,
    extra_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SetactivelkRequest {}

impl SetactivelkRequest {
    pub fn new() -> SetactivelkRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SetactivelkRequest {
        static mut instance: ::protobuf::lazy::Lazy<SetactivelkRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetactivelkRequest,
        };
        unsafe {
            instance.get(SetactivelkRequest::new)
        }
    }

    // required string gfid = 1;

    pub fn clear_gfid(&mut self) {
        self.gfid.clear();
    }

    pub fn has_gfid(&self) -> bool {
        self.gfid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gfid(&mut self, v: ::std::string::String) {
        self.gfid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gfid(&mut self) -> &mut ::std::string::String {
        if self.gfid.is_none() {
            self.gfid.set_default();
        }
        self.gfid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gfid(&mut self) -> ::std::string::String {
        self.gfid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gfid(&self) -> &str {
        match self.gfid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gfid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gfid
    }

    fn mut_gfid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gfid
    }

    // required .rusix.LockList request = 2;

    pub fn clear_request(&mut self) {
        self.request.clear();
    }

    pub fn has_request(&self) -> bool {
        self.request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request(&mut self, v: LockList) {
        self.request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request(&mut self) -> &mut LockList {
        if self.request.is_none() {
            self.request.set_default();
        }
        self.request.as_mut().unwrap()
    }

    // Take field
    pub fn take_request(&mut self) -> LockList {
        self.request.take().unwrap_or_else(|| LockList::new())
    }

    pub fn get_request(&self) -> &LockList {
        self.request.as_ref().unwrap_or_else(|| LockList::default_instance())
    }

    fn get_request_for_reflect(&self) -> &::protobuf::SingularPtrField<LockList> {
        &self.request
    }

    fn mut_request_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<LockList> {
        &mut self.request
    }

    // optional bytes extra_data = 3;

    pub fn clear_extra_data(&mut self) {
        self.extra_data.clear();
    }

    pub fn has_extra_data(&self) -> bool {
        self.extra_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra_data.is_none() {
            self.extra_data.set_default();
        }
        self.extra_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_data(&mut self) -> ::std::vec::Vec<u8> {
        self.extra_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_extra_data(&self) -> &[u8] {
        match self.extra_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_extra_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.extra_data
    }

    fn mut_extra_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.extra_data
    }
}

impl ::protobuf::Message for SetactivelkRequest {
    fn is_initialized(&self) -> bool {
        if self.gfid.is_none() {
            return false;
        }
        if self.request.is_none() {
            return false;
        }
        for v in &self.request {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gfid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.request)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gfid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gfid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.request.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SetactivelkRequest {
    fn new() -> SetactivelkRequest {
        SetactivelkRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<SetactivelkRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gfid",
                    SetactivelkRequest::get_gfid_for_reflect,
                    SetactivelkRequest::mut_gfid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LockList>>(
                    "request",
                    SetactivelkRequest::get_request_for_reflect,
                    SetactivelkRequest::mut_request_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_data",
                    SetactivelkRequest::get_extra_data_for_reflect,
                    SetactivelkRequest::mut_extra_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetactivelkRequest>(
                    "SetactivelkRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SetactivelkRequest {
    fn clear(&mut self) {
        self.clear_gfid();
        self.clear_request();
        self.clear_extra_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetactivelkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetactivelkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Fop {
    IPC = 1,
    LOOKUP = 2,
    MKNOD = 3,
    CREATE = 4,
    OPEN = 5,
    STATFS = 6,
    OPENDIR = 7,
    READDIR = 8,
    READDIRP = 9,
    FSYNCDIR = 10,
    SYMLINK = 11,
    UNLINK = 12,
    LINK = 13,
    MKDIR = 14,
    RMDIR = 15,
    RENAME = 16,
    ENTRYLK = 17,
    FENTRYLK = 18,
    STAT = 19,
    FSTAT = 20,
    ACCESS = 21,
    READLINK = 22,
    GETXATTR = 23,
    FGETXATTR = 24,
    READV = 25,
    FLUSH = 26,
    FSYNC = 27,
    INODELK = 28,
    FINODELK = 29,
    LK = 30,
    LEASE = 31,
    FREMOVEXATTR = 32,
    REMOVEXATTR = 33,
    SETXATTR = 34,
    FSETXATTR = 35,
    TRUNCATE = 36,
    FTRUNCATE = 37,
    WRITEV = 38,
    XATTROP = 39,
    FXATTROP = 40,
    SETATTR = 41,
    FSETATTR = 42,
    FALLOCATE = 43,
    DISCARD = 44,
    ZEROFILL = 45,
}

impl ::protobuf::ProtobufEnum for Fop {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Fop> {
        match value {
            1 => ::std::option::Option::Some(Fop::IPC),
            2 => ::std::option::Option::Some(Fop::LOOKUP),
            3 => ::std::option::Option::Some(Fop::MKNOD),
            4 => ::std::option::Option::Some(Fop::CREATE),
            5 => ::std::option::Option::Some(Fop::OPEN),
            6 => ::std::option::Option::Some(Fop::STATFS),
            7 => ::std::option::Option::Some(Fop::OPENDIR),
            8 => ::std::option::Option::Some(Fop::READDIR),
            9 => ::std::option::Option::Some(Fop::READDIRP),
            10 => ::std::option::Option::Some(Fop::FSYNCDIR),
            11 => ::std::option::Option::Some(Fop::SYMLINK),
            12 => ::std::option::Option::Some(Fop::UNLINK),
            13 => ::std::option::Option::Some(Fop::LINK),
            14 => ::std::option::Option::Some(Fop::MKDIR),
            15 => ::std::option::Option::Some(Fop::RMDIR),
            16 => ::std::option::Option::Some(Fop::RENAME),
            17 => ::std::option::Option::Some(Fop::ENTRYLK),
            18 => ::std::option::Option::Some(Fop::FENTRYLK),
            19 => ::std::option::Option::Some(Fop::STAT),
            20 => ::std::option::Option::Some(Fop::FSTAT),
            21 => ::std::option::Option::Some(Fop::ACCESS),
            22 => ::std::option::Option::Some(Fop::READLINK),
            23 => ::std::option::Option::Some(Fop::GETXATTR),
            24 => ::std::option::Option::Some(Fop::FGETXATTR),
            25 => ::std::option::Option::Some(Fop::READV),
            26 => ::std::option::Option::Some(Fop::FLUSH),
            27 => ::std::option::Option::Some(Fop::FSYNC),
            28 => ::std::option::Option::Some(Fop::INODELK),
            29 => ::std::option::Option::Some(Fop::FINODELK),
            30 => ::std::option::Option::Some(Fop::LK),
            31 => ::std::option::Option::Some(Fop::LEASE),
            32 => ::std::option::Option::Some(Fop::FREMOVEXATTR),
            33 => ::std::option::Option::Some(Fop::REMOVEXATTR),
            34 => ::std::option::Option::Some(Fop::SETXATTR),
            35 => ::std::option::Option::Some(Fop::FSETXATTR),
            36 => ::std::option::Option::Some(Fop::TRUNCATE),
            37 => ::std::option::Option::Some(Fop::FTRUNCATE),
            38 => ::std::option::Option::Some(Fop::WRITEV),
            39 => ::std::option::Option::Some(Fop::XATTROP),
            40 => ::std::option::Option::Some(Fop::FXATTROP),
            41 => ::std::option::Option::Some(Fop::SETATTR),
            42 => ::std::option::Option::Some(Fop::FSETATTR),
            43 => ::std::option::Option::Some(Fop::FALLOCATE),
            44 => ::std::option::Option::Some(Fop::DISCARD),
            45 => ::std::option::Option::Some(Fop::ZEROFILL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Fop] = &[
            Fop::IPC,
            Fop::LOOKUP,
            Fop::MKNOD,
            Fop::CREATE,
            Fop::OPEN,
            Fop::STATFS,
            Fop::OPENDIR,
            Fop::READDIR,
            Fop::READDIRP,
            Fop::FSYNCDIR,
            Fop::SYMLINK,
            Fop::UNLINK,
            Fop::LINK,
            Fop::MKDIR,
            Fop::RMDIR,
            Fop::RENAME,
            Fop::ENTRYLK,
            Fop::FENTRYLK,
            Fop::STAT,
            Fop::FSTAT,
            Fop::ACCESS,
            Fop::READLINK,
            Fop::GETXATTR,
            Fop::FGETXATTR,
            Fop::READV,
            Fop::FLUSH,
            Fop::FSYNC,
            Fop::INODELK,
            Fop::FINODELK,
            Fop::LK,
            Fop::LEASE,
            Fop::FREMOVEXATTR,
            Fop::REMOVEXATTR,
            Fop::SETXATTR,
            Fop::FSETXATTR,
            Fop::TRUNCATE,
            Fop::FTRUNCATE,
            Fop::WRITEV,
            Fop::XATTROP,
            Fop::FXATTROP,
            Fop::SETATTR,
            Fop::FSETATTR,
            Fop::FALLOCATE,
            Fop::DISCARD,
            Fop::ZEROFILL,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<Fop>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Fop", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Fop {
}

impl ::protobuf::reflect::ProtobufValue for Fop {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Event {
    PARENT_UP = 1,
    POLLIN = 2,
    POLLOUT = 3,
    POLLERR = 4,
    CHILD_UP = 5,
    CHILD_DOWN = 6,
    CHILD_CONNECTING = 7,
    CLEANUP = 8,
    TRANSPORT_CONNECTED = 9,
    VOLFILE_MODIFIED = 10,
    GRAPH_NEW = 11,
    TRANSLATOR_INFO = 12,
    TRANSLATOR_OP = 13,
    AUTH_FAILED = 14,
    VOLUME_DEFRAG = 15,
    PARENT_DOWN = 16,
    VOLUME_BARRIER_OP = 17,
    UPCALL = 18,
    SCRUB_STATUS = 19,
    SOME_DESCENDENT_DOWN = 20,
    SCRUB_ONDEMAND = 21,
    SOME_DESCENDENT_UP = 22,
    CHILD_PING = 23,
    MAXVAL = 24,
}

impl ::protobuf::ProtobufEnum for Event {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Event> {
        match value {
            1 => ::std::option::Option::Some(Event::PARENT_UP),
            2 => ::std::option::Option::Some(Event::POLLIN),
            3 => ::std::option::Option::Some(Event::POLLOUT),
            4 => ::std::option::Option::Some(Event::POLLERR),
            5 => ::std::option::Option::Some(Event::CHILD_UP),
            6 => ::std::option::Option::Some(Event::CHILD_DOWN),
            7 => ::std::option::Option::Some(Event::CHILD_CONNECTING),
            8 => ::std::option::Option::Some(Event::CLEANUP),
            9 => ::std::option::Option::Some(Event::TRANSPORT_CONNECTED),
            10 => ::std::option::Option::Some(Event::VOLFILE_MODIFIED),
            11 => ::std::option::Option::Some(Event::GRAPH_NEW),
            12 => ::std::option::Option::Some(Event::TRANSLATOR_INFO),
            13 => ::std::option::Option::Some(Event::TRANSLATOR_OP),
            14 => ::std::option::Option::Some(Event::AUTH_FAILED),
            15 => ::std::option::Option::Some(Event::VOLUME_DEFRAG),
            16 => ::std::option::Option::Some(Event::PARENT_DOWN),
            17 => ::std::option::Option::Some(Event::VOLUME_BARRIER_OP),
            18 => ::std::option::Option::Some(Event::UPCALL),
            19 => ::std::option::Option::Some(Event::SCRUB_STATUS),
            20 => ::std::option::Option::Some(Event::SOME_DESCENDENT_DOWN),
            21 => ::std::option::Option::Some(Event::SCRUB_ONDEMAND),
            22 => ::std::option::Option::Some(Event::SOME_DESCENDENT_UP),
            23 => ::std::option::Option::Some(Event::CHILD_PING),
            24 => ::std::option::Option::Some(Event::MAXVAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Event] = &[
            Event::PARENT_UP,
            Event::POLLIN,
            Event::POLLOUT,
            Event::POLLERR,
            Event::CHILD_UP,
            Event::CHILD_DOWN,
            Event::CHILD_CONNECTING,
            Event::CLEANUP,
            Event::TRANSPORT_CONNECTED,
            Event::VOLFILE_MODIFIED,
            Event::GRAPH_NEW,
            Event::TRANSLATOR_INFO,
            Event::TRANSLATOR_OP,
            Event::AUTH_FAILED,
            Event::VOLUME_DEFRAG,
            Event::PARENT_DOWN,
            Event::VOLUME_BARRIER_OP,
            Event::UPCALL,
            Event::SCRUB_STATUS,
            Event::SOME_DESCENDENT_DOWN,
            Event::SCRUB_ONDEMAND,
            Event::SOME_DESCENDENT_UP,
            Event::CHILD_PING,
            Event::MAXVAL,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<Event>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Event", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Event {
}

impl ::protobuf::reflect::ProtobufValue for Event {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CompoundFop {
    CFOP_NON_PREDEFINED = 1,
    CFOP_XATTROP_WRITEV = 2,
    CFOP_XATTROP_UNLOCK = 3,
    CFOP_PUT = 4,
    CFOP_MAXVALUE = 5,
}

impl ::protobuf::ProtobufEnum for CompoundFop {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CompoundFop> {
        match value {
            1 => ::std::option::Option::Some(CompoundFop::CFOP_NON_PREDEFINED),
            2 => ::std::option::Option::Some(CompoundFop::CFOP_XATTROP_WRITEV),
            3 => ::std::option::Option::Some(CompoundFop::CFOP_XATTROP_UNLOCK),
            4 => ::std::option::Option::Some(CompoundFop::CFOP_PUT),
            5 => ::std::option::Option::Some(CompoundFop::CFOP_MAXVALUE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CompoundFop] = &[
            CompoundFop::CFOP_NON_PREDEFINED,
            CompoundFop::CFOP_XATTROP_WRITEV,
            CompoundFop::CFOP_XATTROP_UNLOCK,
            CompoundFop::CFOP_PUT,
            CompoundFop::CFOP_MAXVALUE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<CompoundFop>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CompoundFop", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CompoundFop {
}

impl ::protobuf::reflect::ProtobufValue for CompoundFop {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Mgmt {
    MGMT_NULL = 1,
    MGMT_MAXVALUE = 2,
}

impl ::protobuf::ProtobufEnum for Mgmt {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Mgmt> {
        match value {
            1 => ::std::option::Option::Some(Mgmt::MGMT_NULL),
            2 => ::std::option::Option::Some(Mgmt::MGMT_MAXVALUE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Mgmt] = &[
            Mgmt::MGMT_NULL,
            Mgmt::MGMT_MAXVALUE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<Mgmt>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Mgmt", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Mgmt {
}

impl ::protobuf::reflect::ProtobufValue for Mgmt {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OpType {
    OP_TYPE_NULL = 1,
    OP_TYPE_FOP = 2,
    OP_TYPE_MGMT = 3,
    OP_TYPE_MAX = 4,
}

impl ::protobuf::ProtobufEnum for OpType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OpType> {
        match value {
            1 => ::std::option::Option::Some(OpType::OP_TYPE_NULL),
            2 => ::std::option::Option::Some(OpType::OP_TYPE_FOP),
            3 => ::std::option::Option::Some(OpType::OP_TYPE_MGMT),
            4 => ::std::option::Option::Some(OpType::OP_TYPE_MAX),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OpType] = &[
            OpType::OP_TYPE_NULL,
            OpType::OP_TYPE_FOP,
            OpType::OP_TYPE_MGMT,
            OpType::OP_TYPE_MAX,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<OpType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("OpType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for OpType {
}

impl ::protobuf::reflect::ProtobufValue for OpType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LockCmds {
    LK_GETLK = 1,
    LK_SETLK = 2,
    LK_SETLKW = 3,
    LK_RESLK_LCK = 4,
    LK_RESLK_LCKW = 5,
    LK_RESLK_UNLCK = 6,
    LK_GETLK_FD = 7,
}

impl ::protobuf::ProtobufEnum for LockCmds {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LockCmds> {
        match value {
            1 => ::std::option::Option::Some(LockCmds::LK_GETLK),
            2 => ::std::option::Option::Some(LockCmds::LK_SETLK),
            3 => ::std::option::Option::Some(LockCmds::LK_SETLKW),
            4 => ::std::option::Option::Some(LockCmds::LK_RESLK_LCK),
            5 => ::std::option::Option::Some(LockCmds::LK_RESLK_LCKW),
            6 => ::std::option::Option::Some(LockCmds::LK_RESLK_UNLCK),
            7 => ::std::option::Option::Some(LockCmds::LK_GETLK_FD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LockCmds] = &[
            LockCmds::LK_GETLK,
            LockCmds::LK_SETLK,
            LockCmds::LK_SETLKW,
            LockCmds::LK_RESLK_LCK,
            LockCmds::LK_RESLK_LCKW,
            LockCmds::LK_RESLK_UNLCK,
            LockCmds::LK_GETLK_FD,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<LockCmds>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("LockCmds", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for LockCmds {
}

impl ::protobuf::reflect::ProtobufValue for LockCmds {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LockTypes {
    LK_F_RDLCK = 1,
    LK_F_WRLCK = 2,
    LK_F_UNLCK = 3,
    LK_EOL = 4,
}

impl ::protobuf::ProtobufEnum for LockTypes {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LockTypes> {
        match value {
            1 => ::std::option::Option::Some(LockTypes::LK_F_RDLCK),
            2 => ::std::option::Option::Some(LockTypes::LK_F_WRLCK),
            3 => ::std::option::Option::Some(LockTypes::LK_F_UNLCK),
            4 => ::std::option::Option::Some(LockTypes::LK_EOL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LockTypes] = &[
            LockTypes::LK_F_RDLCK,
            LockTypes::LK_F_WRLCK,
            LockTypes::LK_F_UNLCK,
            LockTypes::LK_EOL,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<LockTypes>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("LockTypes", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for LockTypes {
}

impl ::protobuf::reflect::ProtobufValue for LockTypes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LeaseTypes {
    NONE = 1,
    RD_LEASE = 2,
    RW_LEASE = 3,
    LEASE_MAX_TYPE = 4,
}

impl ::protobuf::ProtobufEnum for LeaseTypes {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LeaseTypes> {
        match value {
            1 => ::std::option::Option::Some(LeaseTypes::NONE),
            2 => ::std::option::Option::Some(LeaseTypes::RD_LEASE),
            3 => ::std::option::Option::Some(LeaseTypes::RW_LEASE),
            4 => ::std::option::Option::Some(LeaseTypes::LEASE_MAX_TYPE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LeaseTypes] = &[
            LeaseTypes::NONE,
            LeaseTypes::RD_LEASE,
            LeaseTypes::RW_LEASE,
            LeaseTypes::LEASE_MAX_TYPE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<LeaseTypes>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("LeaseTypes", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for LeaseTypes {
}

impl ::protobuf::reflect::ProtobufValue for LeaseTypes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LeaseCmds {
    GET_LEASE = 1,
    SET_LEASE = 2,
    UNLK_LEASE = 3,
}

impl ::protobuf::ProtobufEnum for LeaseCmds {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LeaseCmds> {
        match value {
            1 => ::std::option::Option::Some(LeaseCmds::GET_LEASE),
            2 => ::std::option::Option::Some(LeaseCmds::SET_LEASE),
            3 => ::std::option::Option::Some(LeaseCmds::UNLK_LEASE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LeaseCmds] = &[
            LeaseCmds::GET_LEASE,
            LeaseCmds::SET_LEASE,
            LeaseCmds::UNLK_LEASE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<LeaseCmds>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("LeaseCmds", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for LeaseCmds {
}

impl ::protobuf::reflect::ProtobufValue for LeaseCmds {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LockRecoveryCmds {
    F_RESLK_LCK = 1,
    F_RESLK_LCKW = 2,
    F_RESLK_UNLCK = 3,
    F_GETLK_FD = 4,
}

impl ::protobuf::ProtobufEnum for LockRecoveryCmds {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LockRecoveryCmds> {
        match value {
            1 => ::std::option::Option::Some(LockRecoveryCmds::F_RESLK_LCK),
            2 => ::std::option::Option::Some(LockRecoveryCmds::F_RESLK_LCKW),
            3 => ::std::option::Option::Some(LockRecoveryCmds::F_RESLK_UNLCK),
            4 => ::std::option::Option::Some(LockRecoveryCmds::F_GETLK_FD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LockRecoveryCmds] = &[
            LockRecoveryCmds::F_RESLK_LCK,
            LockRecoveryCmds::F_RESLK_LCKW,
            LockRecoveryCmds::F_RESLK_UNLCK,
            LockRecoveryCmds::F_GETLK_FD,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<LockRecoveryCmds>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("LockRecoveryCmds", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for LockRecoveryCmds {
}

impl ::protobuf::reflect::ProtobufValue for LockRecoveryCmds {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LockDomain {
    LOCK_POSIX = 1,
    LOCK_INTERNAL = 2,
}

impl ::protobuf::ProtobufEnum for LockDomain {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LockDomain> {
        match value {
            1 => ::std::option::Option::Some(LockDomain::LOCK_POSIX),
            2 => ::std::option::Option::Some(LockDomain::LOCK_INTERNAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LockDomain] = &[
            LockDomain::LOCK_POSIX,
            LockDomain::LOCK_INTERNAL,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<LockDomain>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("LockDomain", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for LockDomain {
}

impl ::protobuf::reflect::ProtobufValue for LockDomain {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EntryLockCmd {
    ENTRYLK_LOCK = 1,
    ENTRYLK_UNLOCK = 2,
    ENTRYLK_LOCK_NB = 3,
}

impl ::protobuf::ProtobufEnum for EntryLockCmd {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EntryLockCmd> {
        match value {
            1 => ::std::option::Option::Some(EntryLockCmd::ENTRYLK_LOCK),
            2 => ::std::option::Option::Some(EntryLockCmd::ENTRYLK_UNLOCK),
            3 => ::std::option::Option::Some(EntryLockCmd::ENTRYLK_LOCK_NB),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EntryLockCmd] = &[
            EntryLockCmd::ENTRYLK_LOCK,
            EntryLockCmd::ENTRYLK_UNLOCK,
            EntryLockCmd::ENTRYLK_LOCK_NB,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EntryLockCmd>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EntryLockCmd", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EntryLockCmd {
}

impl ::protobuf::reflect::ProtobufValue for EntryLockCmd {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EntryLockType {
    ENTRYLK_RDLCK = 1,
    ENTRYLK_WRLCK = 2,
}

impl ::protobuf::ProtobufEnum for EntryLockType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EntryLockType> {
        match value {
            1 => ::std::option::Option::Some(EntryLockType::ENTRYLK_RDLCK),
            2 => ::std::option::Option::Some(EntryLockType::ENTRYLK_WRLCK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EntryLockType] = &[
            EntryLockType::ENTRYLK_RDLCK,
            EntryLockType::ENTRYLK_WRLCK,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<EntryLockType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EntryLockType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EntryLockType {
}

impl ::protobuf::reflect::ProtobufValue for EntryLockType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum XattropFlags {
    XATTROP_ADD_ARRAY = 1,
    XATTROP_ADD_ARRAY64 = 2,
    XATTROP_OR_ARRAY = 3,
    XATTROP_AND_ARRAY = 4,
    XATTROP_GET_AND_SET = 5,
    XATTROP_ADD_ARRAY_WITH_DEFAULT = 6,
    XATTROP_ADD_ARRAY64_WITH_DEFAULT = 7,
}

impl ::protobuf::ProtobufEnum for XattropFlags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<XattropFlags> {
        match value {
            1 => ::std::option::Option::Some(XattropFlags::XATTROP_ADD_ARRAY),
            2 => ::std::option::Option::Some(XattropFlags::XATTROP_ADD_ARRAY64),
            3 => ::std::option::Option::Some(XattropFlags::XATTROP_OR_ARRAY),
            4 => ::std::option::Option::Some(XattropFlags::XATTROP_AND_ARRAY),
            5 => ::std::option::Option::Some(XattropFlags::XATTROP_GET_AND_SET),
            6 => ::std::option::Option::Some(XattropFlags::XATTROP_ADD_ARRAY_WITH_DEFAULT),
            7 => ::std::option::Option::Some(XattropFlags::XATTROP_ADD_ARRAY64_WITH_DEFAULT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [XattropFlags] = &[
            XattropFlags::XATTROP_ADD_ARRAY,
            XattropFlags::XATTROP_ADD_ARRAY64,
            XattropFlags::XATTROP_OR_ARRAY,
            XattropFlags::XATTROP_AND_ARRAY,
            XattropFlags::XATTROP_GET_AND_SET,
            XattropFlags::XATTROP_ADD_ARRAY_WITH_DEFAULT,
            XattropFlags::XATTROP_ADD_ARRAY64_WITH_DEFAULT,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<XattropFlags>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("XattropFlags", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for XattropFlags {
}

impl ::protobuf::reflect::ProtobufValue for XattropFlags {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SeekWhat {
    SEEK_DATA = 1,
    SEEK_HOLE = 2,
}

impl ::protobuf::ProtobufEnum for SeekWhat {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SeekWhat> {
        match value {
            1 => ::std::option::Option::Some(SeekWhat::SEEK_DATA),
            2 => ::std::option::Option::Some(SeekWhat::SEEK_HOLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SeekWhat] = &[
            SeekWhat::SEEK_DATA,
            SeekWhat::SEEK_HOLE,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<SeekWhat>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SeekWhat", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SeekWhat {
}

impl ::protobuf::reflect::ProtobufValue for SeekWhat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UpcallFlags {
    UPCALL_NULL = 1,
    UPCALL_CI_STAT = 3,
    UPCALL_CI_XATTR = 4,
    UPCALL_CI_RENAME = 5,
    UPCALL_CI_NLINK = 6,
    UPCALL_CI_FORGET = 7,
    UPCALL_LEASE_RECALL = 8,
    UPCALL_FLAGS_MAXVALU = 9,
}

impl ::protobuf::ProtobufEnum for UpcallFlags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UpcallFlags> {
        match value {
            1 => ::std::option::Option::Some(UpcallFlags::UPCALL_NULL),
            3 => ::std::option::Option::Some(UpcallFlags::UPCALL_CI_STAT),
            4 => ::std::option::Option::Some(UpcallFlags::UPCALL_CI_XATTR),
            5 => ::std::option::Option::Some(UpcallFlags::UPCALL_CI_RENAME),
            6 => ::std::option::Option::Some(UpcallFlags::UPCALL_CI_NLINK),
            7 => ::std::option::Option::Some(UpcallFlags::UPCALL_CI_FORGET),
            8 => ::std::option::Option::Some(UpcallFlags::UPCALL_LEASE_RECALL),
            9 => ::std::option::Option::Some(UpcallFlags::UPCALL_FLAGS_MAXVALU),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UpcallFlags] = &[
            UpcallFlags::UPCALL_NULL,
            UpcallFlags::UPCALL_CI_STAT,
            UpcallFlags::UPCALL_CI_XATTR,
            UpcallFlags::UPCALL_CI_RENAME,
            UpcallFlags::UPCALL_CI_NLINK,
            UpcallFlags::UPCALL_CI_FORGET,
            UpcallFlags::UPCALL_LEASE_RECALL,
            UpcallFlags::UPCALL_FLAGS_MAXVALU,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<UpcallFlags>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("UpcallFlags", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for UpcallFlags {
}

impl ::protobuf::reflect::ProtobufValue for UpcallFlags {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum dict_data_type_t {
    DATA_TYPE_UNKNOWN = 1,
    DATA_TYPE_INT = 2,
    DATA_TYPE_UINT = 3,
    DATA_TYPE_DOUBLE = 4,
    DATA_TYPE_STR = 5,
    DATA_TYPE_PTR = 6,
    DATA_TYPE_GFUUID = 7,
    DATA_TYPE_IATT = 8,
    DATA_TYPE_MAX = 9,
}

impl ::protobuf::ProtobufEnum for dict_data_type_t {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<dict_data_type_t> {
        match value {
            1 => ::std::option::Option::Some(dict_data_type_t::DATA_TYPE_UNKNOWN),
            2 => ::std::option::Option::Some(dict_data_type_t::DATA_TYPE_INT),
            3 => ::std::option::Option::Some(dict_data_type_t::DATA_TYPE_UINT),
            4 => ::std::option::Option::Some(dict_data_type_t::DATA_TYPE_DOUBLE),
            5 => ::std::option::Option::Some(dict_data_type_t::DATA_TYPE_STR),
            6 => ::std::option::Option::Some(dict_data_type_t::DATA_TYPE_PTR),
            7 => ::std::option::Option::Some(dict_data_type_t::DATA_TYPE_GFUUID),
            8 => ::std::option::Option::Some(dict_data_type_t::DATA_TYPE_IATT),
            9 => ::std::option::Option::Some(dict_data_type_t::DATA_TYPE_MAX),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [dict_data_type_t] = &[
            dict_data_type_t::DATA_TYPE_UNKNOWN,
            dict_data_type_t::DATA_TYPE_INT,
            dict_data_type_t::DATA_TYPE_UINT,
            dict_data_type_t::DATA_TYPE_DOUBLE,
            dict_data_type_t::DATA_TYPE_STR,
            dict_data_type_t::DATA_TYPE_PTR,
            dict_data_type_t::DATA_TYPE_GFUUID,
            dict_data_type_t::DATA_TYPE_IATT,
            dict_data_type_t::DATA_TYPE_MAX,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<dict_data_type_t>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("dict_data_type_t", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for dict_data_type_t {
}

impl ::protobuf::reflect::ProtobufValue for dict_data_type_t {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResultType {
    OK = 1,
    ERR = 2,
}

impl ::protobuf::ProtobufEnum for ResultType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResultType> {
        match value {
            1 => ::std::option::Option::Some(ResultType::OK),
            2 => ::std::option::Option::Some(ResultType::ERR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResultType] = &[
            ResultType::OK,
            ResultType::ERR,
        ];
        values
    }

    fn enum_descriptor_static(_: ::std::option::Option<ResultType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ResultType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ResultType {
}

impl ::protobuf::reflect::ProtobufValue for ResultType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x14protos/service.proto\x12\x05rusix\"t\n\x05Lease\x12\x1d\n\x03cmd\
    \x18\x01\x20\x02(\x0e2\x10.rusix.LeaseCmds\x12%\n\nlease_type\x18\x02\
    \x20\x02(\x0e2\x11.rusix.LeaseTypes\x12\x10\n\x08lease_id\x18\x03\x20\
    \x02(\t\x12\x13\n\x0blease_flags\x18\x04\x20\x02(\r\"\x19\n\tlkowner_t\
    \x12\x0c\n\x04data\x18\x02\x20\x02(\t\"%\n\x08KeyValue\x12\x0b\n\x03key\
    \x18\x01\x20\x02(\t\x12\x0c\n\x04data\x18\x02\x20\x02(\x0c\"%\n\x04Dict\
    \x12\x1d\n\x04data\x18\x01\x20\x03(\x0b2\x0f.rusix.KeyValue\"O\n\x08OpRe\
    sult\x12!\n\x06result\x18\x01\x20\x02(\x0e2\x11.rusix.ResultType\x12\r\n\
    \x05errno\x18\x02\x20\x01(\x05\x12\x11\n\terror_msg\x18\x03\x20\x01(\t\"\
    '\n\tOperation\x12\x0c\n\x04name\x18\x01\x20\x02(\t\x12\x0c\n\x04data\
    \x18\x02\x20\x01(\x0c\"\xb1\x01\n\x06Statfs\x12\r\n\x05bsize\x18\x01\x20\
    \x02(\x04\x12\x0e\n\x06frsize\x18\x02\x20\x02(\x04\x12\x0e\n\x06blocks\
    \x18\x03\x20\x02(\x04\x12\r\n\x05bfree\x18\x04\x20\x02(\x04\x12\x0e\n\
    \x06bavail\x18\x05\x20\x02(\x04\x12\r\n\x05files\x18\x06\x20\x02(\x04\
    \x12\r\n\x05ffree\x18\x07\x20\x02(\x04\x12\x0e\n\x06favail\x18\x08\x20\
    \x02(\x04\x12\x0c\n\x04fsid\x18\t\x20\x02(\x04\x12\x0c\n\x04flag\x18\n\
    \x20\x02(\x04\x12\x0f\n\x07namemax\x18\x0b\x20\x02(\x04\"e\n\nProtoFlock\
    \x12\x0c\n\x04type\x18\x01\x20\x02(\r\x12\x0e\n\x06whence\x18\x02\x20\
    \x02(\r\x12\r\n\x05start\x18\x03\x20\x02(\x04\x12\x0b\n\x03len\x18\x04\
    \x20\x02(\x04\x12\x0b\n\x03pid\x18\x05\x20\x02(\r\x12\x10\n\x08lk_owner\
    \x18\x06\x20\x02(\t\"T\n\nProtoLease\x12\x0b\n\x03cmd\x18\x01\x20\x02(\r\
    \x12\x12\n\nlease_type\x18\x02\x20\x02(\r\x12\x10\n\x08lease_id\x18\x03\
    \x20\x02(\t\x12\x13\n\x0blease_flags\x18\x04\x20\x02(\r\"\xbb\x02\n\x04I\
    att\x12\x0f\n\x07ia_gfid\x18\x01\x20\x02(\t\x12\x0e\n\x06ia_ino\x18\x02\
    \x20\x02(\x04\x12\x0e\n\x06ia_dev\x18\x03\x20\x02(\x04\x12\x0c\n\x04mode\
    \x18\x04\x20\x02(\r\x12\x10\n\x08ia_nlink\x18\x05\x20\x02(\r\x12\x0e\n\
    \x06ia_uid\x18\x06\x20\x02(\r\x12\x0e\n\x06ia_gid\x18\x07\x20\x02(\r\x12\
    \x0f\n\x07ia_rdev\x18\x08\x20\x02(\x04\x12\x0f\n\x07ia_size\x18\t\x20\
    \x02(\x04\x12\x12\n\nia_blksize\x18\n\x20\x02(\r\x12\x11\n\tia_blocks\
    \x18\x0b\x20\x02(\x04\x12\x10\n\x08ia_atime\x18\x0c\x20\x02(\r\x12\x15\n\
    \ria_atime_nsec\x18\r\x20\x02(\r\x12\x10\n\x08ia_mtime\x18\x0e\x20\x02(\
    \r\x12\x15\n\ria_mtime_nsec\x18\x0f\x20\x02(\r\x12\x10\n\x08ia_ctime\x18\
    \x10\x20\x02(\r\x12\x15\n\ria_ctime_nsec\x18\x11\x20\x02(\r\"\xe0\x01\n\
    \x1dcbk_cache_invalidationRequest\x12\x0c\n\x04gfid\x18\x01\x20\x02(\t\
    \x12\x12\n\nevent_type\x18\x02\x20\x02(\r\x12\r\n\x05flags\x18\x03\x20\
    \x02(\r\x12\x18\n\x10expire_time_attr\x18\x04\x20\x02(\r\x12\x19\n\x04st\
    at\x18\x05\x20\x02(\x0b2\x0b.rusix.Iatt\x12\x20\n\x0bparent_stat\x18\x06\
    \x20\x02(\x0b2\x0b.rusix.Iatt\x12#\n\x0eoldparent_stat\x18\x07\x20\x02(\
    \x0b2\x0b.rusix.Iatt\x12\x12\n\nextra_data\x18\x08\x20\x01(\x0c\"/\n\x0b\
    StatRequest\x12\x0c\n\x04gfid\x18\x01\x20\x02(\t\x12\x12\n\nextra_data\
    \x18\x02\x20\x01(\x0c\"^\n\x0cstatResponse\x12\x1f\n\x06result\x18\x01\
    \x20\x02(\x0b2\x0f.rusix.OpResult\x12\x19\n\x04stat\x18\x02\x20\x01(\x0b\
    2\x0b.rusix.Iatt\x12\x12\n\nextra_data\x18\x03\x20\x01(\x0c\"A\n\x0fread\
    linkRequest\x12\x0c\n\x04gfid\x18\x01\x20\x02(\t\x12\x0c\n\x04size\x18\
    \x02\x20\x02(\r\x12\x12\n\nextra_data\x18\x03\x20\x01(\x0c\"o\n\x10Readl\
    inkResponse\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\
    \x12\x18\n\x03buf\x18\x02\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x0c\n\x04path\
    \x18\x03\x20\x01(\t\x12\x12\n\nextra_data\x18\x04\x20\x01(\x0c\"l\n\x0cM\
    knodRequest\x12\x0f\n\x07pargfid\x18\x01\x20\x02(\x0c\x12\x0b\n\x03dev\
    \x18\x02\x20\x02(\x04\x12\x0c\n\x04mode\x18\x03\x20\x02(\r\x12\r\n\x05um\
    ask\x18\x04\x20\x02(\r\x12\r\n\x05bname\x18\x05\x20\x02(\t\x12\x12\n\nex\
    tra_data\x18\x06\x20\x01(\x0c\"\xa0\x01\n\rMknodResponse\x12\x1f\n\x06re\
    sult\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\x12\x19\n\x04stat\x18\x02\
    \x20\x01(\x0b2\x0b.rusix.Iatt\x12\x1e\n\tpreparent\x18\x03\x20\x01(\x0b2\
    \x0b.rusix.Iatt\x12\x1f\n\npostparent\x18\x04\x20\x01(\x0b2\x0b.rusix.Ia\
    tt\x12\x12\n\nextra_data\x18\x05\x20\x01(\x0c\"_\n\x0cMkdirRequest\x12\
    \x0f\n\x07pargfid\x18\x01\x20\x02(\x0c\x12\x0c\n\x04mode\x18\x02\x20\x02\
    (\r\x12\r\n\x05umask\x18\x03\x20\x02(\r\x12\r\n\x05bname\x18\x04\x20\x02\
    (\t\x12\x12\n\nextra_data\x18\x05\x20\x01(\x0c\"\xa0\x01\n\rMkdirRespons\
    e\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\x12\x19\n\
    \x04stat\x18\x02\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x1e\n\tpreparent\x18\
    \x03\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x1f\n\npostparent\x18\x04\x20\x01(\
    \x0b2\x0b.rusix.Iatt\x12\x12\n\nextra_data\x18\x05\x20\x01(\x0c\"S\n\rUn\
    linkRequest\x12\x0f\n\x07pargfid\x18\x01\x20\x02(\x0c\x12\r\n\x05bname\
    \x18\x02\x20\x02(\t\x12\x0e\n\x06xflags\x18\x03\x20\x02(\r\x12\x12\n\nex\
    tra_data\x18\x04\x20\x01(\x0c\"\x86\x01\n\x0eUnlinkResponse\x12\x1f\n\
    \x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\x12\x1e\n\tpreparent\
    \x18\x02\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x1f\n\npostparent\x18\x03\x20\
    \x01(\x0b2\x0b.rusix.Iatt\x12\x12\n\nextra_data\x18\x04\x20\x01(\x0c\"R\
    \n\x0cRmdirRequest\x12\x0f\n\x07pargfid\x18\x01\x20\x02(\x0c\x12\x0e\n\
    \x06xflags\x18\x02\x20\x02(\x05\x12\r\n\x05bname\x18\x03\x20\x02(\t\x12\
    \x12\n\nextra_data\x18\x04\x20\x01(\x0c\"\x85\x01\n\rrmdirResponse\x12\
    \x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\x12\x1e\n\tpre\
    parent\x18\x02\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x1f\n\npostparent\x18\
    \x03\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x12\n\nextra_data\x18\x04\x20\x01(\
    \x0c\"e\n\x0eSymlinkRequest\x12\x0f\n\x07pargfid\x18\x01\x20\x02(\x0c\
    \x12\r\n\x05bname\x18\x02\x20\x02(\t\x12\r\n\x05umask\x18\x03\x20\x02(\r\
    \x12\x10\n\x08linkname\x18\x04\x20\x02(\t\x12\x12\n\nextra_data\x18\x05\
    \x20\x01(\x0c\"\xa2\x01\n\x0fSymlinkResponse\x12\x1f\n\x06result\x18\x01\
    \x20\x02(\x0b2\x0f.rusix.OpResult\x12\x19\n\x04stat\x18\x02\x20\x01(\x0b\
    2\x0b.rusix.Iatt\x12\x1e\n\tpreparent\x18\x03\x20\x01(\x0b2\x0b.rusix.Ia\
    tt\x12\x1f\n\npostparent\x18\x04\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x12\n\
    \nextra_data\x18\x05\x20\x01(\x0c\"i\n\rRenameRequest\x12\x0f\n\x07oldgf\
    id\x18\x01\x20\x02(\t\x12\x0f\n\x07newgfid\x18\x02\x20\x02(\t\x12\x10\n\
    \x08oldbname\x18\x03\x20\x02(\t\x12\x10\n\x08newbname\x18\x04\x20\x02(\t\
    \x12\x12\n\nextra_data\x18\x05\x20\x01(\x0c\"\xee\x01\n\x0erenameRespons\
    e\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\x12\x19\n\
    \x04stat\x18\x02\x20\x01(\x0b2\x0b.rusix.Iatt\x12!\n\x0cpreoldparent\x18\
    \x03\x20\x01(\x0b2\x0b.rusix.Iatt\x12\"\n\rpostoldparent\x18\x04\x20\x01\
    (\x0b2\x0b.rusix.Iatt\x12!\n\x0cprenewparent\x18\x05\x20\x01(\x0b2\x0b.r\
    usix.Iatt\x12\"\n\rpostnewparent\x18\x06\x20\x01(\x0b2\x0b.rusix.Iatt\
    \x12\x12\n\nextra_data\x18\x07\x20\x01(\x0c\"U\n\x0blinkRequest\x12\x0f\
    \n\x07oldgfid\x18\x01\x20\x02(\t\x12\x0f\n\x07newgfid\x18\x02\x20\x02(\t\
    \x12\x10\n\x08newbname\x18\x03\x20\x02(\t\x12\x12\n\nextra_data\x18\x04\
    \x20\x01(\x0c\"\x9f\x01\n\x0clinkResponse\x12\x1f\n\x06result\x18\x01\
    \x20\x02(\x0b2\x0f.rusix.OpResult\x12\x19\n\x04stat\x18\x02\x20\x01(\x0b\
    2\x0b.rusix.Iatt\x12\x1e\n\tpreparent\x18\x03\x20\x01(\x0b2\x0b.rusix.Ia\
    tt\x12\x1f\n\npostparent\x18\x04\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x12\n\
    \nextra_data\x18\x05\x20\x01(\x0c\"C\n\x0ftruncateRequest\x12\x0c\n\x04g\
    fid\x18\x01\x20\x02(\t\x12\x0e\n\x06offset\x18\x02\x20\x02(\x04\x12\x12\
    \n\nextra_data\x18\x03\x20\x01(\x0c\"\x84\x01\n\x10truncateResponse\x12\
    \x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\x12\x1c\n\x07p\
    restat\x18\x02\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x1d\n\x08poststat\x18\
    \x03\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x12\n\nextra_data\x18\x04\x20\x01(\
    \x0c\">\n\x0bopenRequest\x12\x0c\n\x04gfid\x18\x01\x20\x02(\t\x12\r\n\
    \x05flags\x18\x02\x20\x02(\r\x12\x12\n\nextra_data\x18\x03\x20\x01(\x0c\
    \"O\n\x0copenResponse\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusi\
    x.OpResult\x12\n\n\x02fd\x18\x02\x20\x01(\x04\x12\x12\n\nextra_data\x18\
    \x03\x20\x01(\x0c\"g\n\x0breadRequest\x12\x0c\n\x04gfid\x18\x01\x20\x02(\
    \t\x12\n\n\x02fd\x18\x02\x20\x02(\x04\x12\x0e\n\x06offset\x18\x03\x20\
    \x02(\x04\x12\x0c\n\x04size\x18\x04\x20\x02(\r\x12\x0c\n\x04flag\x18\x05\
    \x20\x02(\r\x12\x12\n\nextra_data\x18\x06\x20\x01(\x0c\"l\n\x0creadRespo\
    nse\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\x12\x19\
    \n\x04stat\x18\x02\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x0c\n\x04size\x18\
    \x03\x20\x01(\r\x12\x12\n\nextra_data\x18\x04\x20\x01(\x0c\"`\n\rlookupR\
    equest\x12\x0c\n\x04gfid\x18\x01\x20\x02(\t\x12\x0f\n\x07pargfid\x18\x02\
    \x20\x02(\x0c\x12\r\n\x05flags\x18\x03\x20\x02(\r\x12\r\n\x05bname\x18\
    \x04\x20\x02(\t\x12\x12\n\nextra_data\x18\x05\x20\x01(\x0c\"\x81\x01\n\
    \x0elookupResponse\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.O\
    pResult\x12\x19\n\x04stat\x18\x02\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x1f\n\
    \npostparent\x18\x03\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x12\n\nextra_data\
    \x18\x04\x20\x01(\x0c\"h\n\x0cwriteRequest\x12\x0c\n\x04gfid\x18\x01\x20\
    \x02(\t\x12\n\n\x02fd\x18\x02\x20\x02(\x04\x12\x0e\n\x06offset\x18\x03\
    \x20\x02(\x04\x12\x0c\n\x04size\x18\x04\x20\x02(\r\x12\x0c\n\x04flag\x18\
    \x05\x20\x02(\r\x12\x12\n\nextra_data\x18\x06\x20\x01(\x0c\"\x81\x01\n\r\
    writeResponse\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResu\
    lt\x12\x1c\n\x07prestat\x18\x02\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x1d\n\
    \x08poststat\x18\x03\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x12\n\nextra_data\
    \x18\x04\x20\x01(\x0c\"1\n\rstatfsRequest\x12\x0c\n\x04gfid\x18\x01\x20\
    \x02(\t\x12\x12\n\nextra_data\x18\x02\x20\x01(\x0c\"d\n\x0estatfsRespons\
    e\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\x12\x1d\n\
    \x06statfs\x18\x02\x20\x01(\x0b2\r.rusix.Statfs\x12\x12\n\nextra_data\
    \x18\x03\x20\x01(\x0c\"v\n\tlkRequest\x12\x0c\n\x04gfid\x18\x01\x20\x02(\
    \t\x12\n\n\x02fd\x18\x02\x20\x02(\x03\x12\x0b\n\x03cmd\x18\x03\x20\x02(\
    \r\x12\x0c\n\x04type\x18\x04\x20\x02(\r\x12\x20\n\x05flock\x18\x05\x20\
    \x02(\x0b2\x11.rusix.ProtoFlock\x12\x12\n\nextra_data\x18\x06\x20\x01(\
    \x0c\"c\n\nlkResponse\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusi\
    x.OpResult\x12\x20\n\x05flock\x18\x02\x20\x01(\x0b2\x11.rusix.ProtoFlock\
    \x12\x12\n\nextra_data\x18\x03\x20\x01(\x0c\"R\n\x0cleaseRequest\x12\x0c\
    \n\x04gfid\x18\x01\x20\x02(\t\x12\x20\n\x05lease\x18\x02\x20\x02(\x0b2\
    \x11.rusix.ProtoLease\x12\x12\n\nextra_data\x18\x03\x20\x01(\x0c\"f\n\rl\
    easeResponse\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResul\
    t\x12\x20\n\x05lease\x18\x02\x20\x01(\x0b2\x11.rusix.ProtoLease\x12\x12\
    \n\nextra_data\x18\x03\x20\x01(\x0c\"X\n\x13recall_leaseRequest\x12\x0c\
    \n\x04gfid\x18\x01\x20\x02(\x0c\x12\x12\n\nlease_type\x18\x02\x20\x02(\r\
    \x12\x0b\n\x03tid\x18\x03\x20\x02(\x0c\x12\x12\n\nextra_data\x18\x04\x20\
    \x01(\x0c\"\x7f\n\x0einodelkRequest\x12\x0c\n\x04gfid\x18\x01\x20\x02(\t\
    \x12\x0b\n\x03cmd\x18\x02\x20\x02(\r\x12\x0c\n\x04type\x18\x03\x20\x02(\
    \r\x12\x20\n\x05flock\x18\x04\x20\x02(\x0b2\x11.rusix.ProtoFlock\x12\x0e\
    \n\x06volume\x18\x05\x20\x02(\t\x12\x12\n\nextra_data\x18\x06\x20\x01(\
    \x0c\"\x8c\x01\n\x0ffinodelkRequest\x12\x0c\n\x04gfid\x18\x01\x20\x02(\t\
    \x12\n\n\x02fd\x18\x02\x20\x02(\x04\x12\x0b\n\x03cmd\x18\x03\x20\x02(\r\
    \x12\x0c\n\x04type\x18\x04\x20\x02(\r\x12\x20\n\x05flock\x18\x05\x20\x02\
    (\x0b2\x11.rusix.ProtoFlock\x12\x0e\n\x06volume\x18\x06\x20\x02(\t\x12\
    \x12\n\nextra_data\x18\x07\x20\x01(\x0c\"<\n\x0cflushRequest\x12\x0c\n\
    \x04gfid\x18\x01\x20\x02(\t\x12\n\n\x02fd\x18\x02\x20\x02(\x04\x12\x12\n\
    \nextra_data\x18\x03\x20\x01(\x0c\"J\n\x0cfsyncRequest\x12\x0c\n\x04gfid\
    \x18\x01\x20\x02(\t\x12\n\n\x02fd\x18\x02\x20\x02(\x04\x12\x0c\n\x04data\
    \x18\x03\x20\x02(\r\x12\x12\n\nextra_data\x18\x04\x20\x01(\x0c\"\x81\x01\
    \n\rfsyncResponse\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.Op\
    Result\x12\x1c\n\x07prestat\x18\x02\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x1d\
    \n\x08poststat\x18\x03\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x12\n\nextra_dat\
    a\x18\x04\x20\x01(\x0c\"]\n\x0fsetxattrRequest\x12\x0c\n\x04gfid\x18\x01\
    \x20\x02(\t\x12\r\n\x05flags\x18\x02\x20\x02(\r\x12\x19\n\x04dict\x18\
    \x03\x20\x02(\x0b2\x0b.rusix.Dict\x12\x12\n\nextra_data\x18\x04\x20\x01(\
    \x0c\"j\n\x10fsetxattrRequest\x12\x0c\n\x04gfid\x18\x01\x20\x02(\t\x12\n\
    \n\x02fd\x18\x02\x20\x02(\x03\x12\r\n\x05flags\x18\x03\x20\x02(\r\x12\
    \x19\n\x04dict\x18\x04\x20\x02(\x0b2\x0b.rusix.Dict\x12\x12\n\nextra_dat\
    a\x18\x05\x20\x01(\x0c\"\\\n\x0exattropRequest\x12\x0c\n\x04gfid\x18\x01\
    \x20\x02(\t\x12\r\n\x05flags\x18\x02\x20\x02(\r\x12\x19\n\x04dict\x18\
    \x03\x20\x02(\x0b2\x0b.rusix.Dict\x12\x12\n\nextra_data\x18\x04\x20\x01(\
    \x0c\"a\n\x0fxattropResponse\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\
    \x0f.rusix.OpResult\x12\x19\n\x04dict\x18\x02\x20\x01(\x0b2\x0b.rusix.Di\
    ct\x12\x12\n\nextra_data\x18\x03\x20\x01(\x0c\"i\n\x0ffxattropRequest\
    \x12\x0c\n\x04gfid\x18\x01\x20\x02(\t\x12\n\n\x02fd\x18\x02\x20\x02(\x04\
    \x12\r\n\x05flags\x18\x03\x20\x02(\r\x12\x19\n\x04dict\x18\x04\x20\x02(\
    \x0b2\x0b.rusix.Dict\x12\x12\n\nextra_data\x18\x05\x20\x01(\x0c\"b\n\x10\
    fxattropResponse\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpR\
    esult\x12\x19\n\x04dict\x18\x02\x20\x01(\x0b2\x0b.rusix.Dict\x12\x12\n\n\
    extra_data\x18\x03\x20\x01(\x0c\"R\n\x0fgetxattrRequest\x12\x0c\n\x04gfi\
    d\x18\x01\x20\x02(\t\x12\x0f\n\x07namelen\x18\x02\x20\x02(\r\x12\x0c\n\
    \x04name\x18\x03\x20\x02(\t\x12\x12\n\nextra_data\x18\x04\x20\x01(\x0c\"\
    b\n\x10getxattrResponse\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.ru\
    six.OpResult\x12\x19\n\x04dict\x18\x02\x20\x01(\x0b2\x0b.rusix.Dict\x12\
    \x12\n\nextra_data\x18\x03\x20\x01(\x0c\"_\n\x10fgetxattrRequest\x12\x0c\
    \n\x04gfid\x18\x01\x20\x02(\t\x12\n\n\x02fd\x18\x02\x20\x02(\x04\x12\x0f\
    \n\x07namelen\x18\x03\x20\x02(\r\x12\x0c\n\x04name\x18\x04\x20\x02(\t\
    \x12\x12\n\nextra_data\x18\x05\x20\x01(\x0c\"c\n\x11fgetxattrResponse\
    \x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\x12\x19\n\
    \x04dict\x18\x02\x20\x01(\x0b2\x0b.rusix.Dict\x12\x12\n\nextra_data\x18\
    \x03\x20\x01(\x0c\"D\n\x12removexattrRequest\x12\x0c\n\x04gfid\x18\x01\
    \x20\x02(\t\x12\x0c\n\x04name\x18\x02\x20\x02(\t\x12\x12\n\nextra_data\
    \x18\x03\x20\x01(\x0c\"Q\n\x13fremovexattrRequest\x12\x0c\n\x04gfid\x18\
    \x01\x20\x02(\t\x12\n\n\x02fd\x18\x02\x20\x02(\x04\x12\x0c\n\x04name\x18\
    \x03\x20\x02(\t\x12\x12\n\nextra_data\x18\x04\x20\x01(\x0c\"2\n\x0eopend\
    irRequest\x12\x0c\n\x04gfid\x18\x01\x20\x02(\t\x12\x12\n\nextra_data\x18\
    \x02\x20\x01(\x0c\"R\n\x0fopendirResponse\x12\x1f\n\x06result\x18\x01\
    \x20\x02(\x0b2\x0f.rusix.OpResult\x12\n\n\x02fd\x18\x02\x20\x01(\x04\x12\
    \x12\n\nextra_data\x18\x03\x20\x01(\x0c\"?\n\x0ffsyncdirRequest\x12\x0c\
    \n\x04gfid\x18\x01\x20\x02(\t\x12\n\n\x02fd\x18\x02\x20\x02(\x04\x12\x12\
    \n\nextra_data\x18\x03\x20\x01(\x0c\"\\\n\x0eReaddirRequest\x12\x0c\n\
    \x04gfid\x18\x01\x20\x02(\t\x12\n\n\x02fd\x18\x02\x20\x02(\x04\x12\x0e\n\
    \x06offset\x18\x03\x20\x02(\x04\x12\x0c\n\x04size\x18\x04\x20\x02(\r\x12\
    \x12\n\nextra_data\x18\x05\x20\x01(\x0c\"d\n\x0fReaddirpRequest\x12\x0c\
    \n\x04gfid\x18\x01\x20\x02(\t\x12\n\n\x02fd\x18\x02\x20\x02(\x04\x12\x0e\
    \n\x06offset\x18\x03\x20\x02(\x04\x12\x0c\n\x04size\x18\x04\x20\x02(\r\
    \x12\x19\n\x04dict\x18\x05\x20\x02(\x0b2\x0b.rusix.Dict\"?\n\raccessRequ\
    est\x12\x0c\n\x04gfid\x18\x01\x20\x02(\t\x12\x0c\n\x04mask\x18\x02\x20\
    \x02(\r\x12\x12\n\nextra_data\x18\x03\x20\x01(\x0c\"o\n\rcreateRequest\
    \x12\x0f\n\x07pargfid\x18\x01\x20\x02(\x0c\x12\r\n\x05flags\x18\x02\x20\
    \x02(\r\x12\x0c\n\x04mode\x18\x03\x20\x02(\r\x12\r\n\x05umask\x18\x04\
    \x20\x02(\r\x12\r\n\x05bname\x18\x05\x20\x02(\t\x12\x12\n\nextra_data\
    \x18\x06\x20\x01(\x0c\"\xad\x01\n\x0eCreateResponse\x12\x1f\n\x06result\
    \x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\x12\x19\n\x04stat\x18\x02\x20\
    \x01(\x0b2\x0b.rusix.Iatt\x12\n\n\x02fd\x18\x03\x20\x01(\x04\x12\x1e\n\t\
    preparent\x18\x04\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x1f\n\npostparent\x18\
    \x05\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x12\n\nextra_data\x18\x06\x20\x01(\
    \x0c\"P\n\x10FtruncateRequest\x12\x0c\n\x04gfid\x18\x01\x20\x02(\t\x12\n\
    \n\x02fd\x18\x02\x20\x02(\x04\x12\x0e\n\x06offset\x18\x03\x20\x02(\x04\
    \x12\x12\n\nextra_data\x18\x04\x20\x01(\x0c\"\x85\x01\n\x11FtruncateResp\
    onse\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\x12\
    \x1c\n\x07prestat\x18\x02\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x1d\n\x08post\
    stat\x18\x03\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x12\n\nextra_data\x18\x04\
    \x20\x01(\x0c\"<\n\x0cFstatRequest\x12\x0c\n\x04gfid\x18\x01\x20\x02(\t\
    \x12\n\n\x02fd\x18\x02\x20\x02(\x04\x12\x12\n\nextra_data\x18\x03\x20\
    \x01(\x0c\"_\n\rfstatResponse\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\
    \x0f.rusix.OpResult\x12\x19\n\x04stat\x18\x02\x20\x01(\x0b2\x0b.rusix.Ia\
    tt\x12\x12\n\nextra_data\x18\x03\x20\x01(\x0c\"|\n\x0eentrylkRequest\x12\
    \x0c\n\x04gfid\x18\x01\x20\x02(\t\x12\x0b\n\x03cmd\x18\x02\x20\x02(\r\
    \x12\x0c\n\x04type\x18\x03\x20\x02(\r\x12\x0f\n\x07namelen\x18\x04\x20\
    \x02(\x04\x12\x0c\n\x04name\x18\x05\x20\x02(\t\x12\x0e\n\x06volume\x18\
    \x06\x20\x02(\t\x12\x12\n\nextra_data\x18\x07\x20\x01(\x0c\"\x89\x01\n\
    \x0ffentrylkRequest\x12\x0c\n\x04gfid\x18\x01\x20\x02(\t\x12\n\n\x02fd\
    \x18\x02\x20\x02(\x04\x12\x0b\n\x03cmd\x18\x03\x20\x02(\r\x12\x0c\n\x04t\
    ype\x18\x04\x20\x02(\r\x12\x0f\n\x07namelen\x18\x05\x20\x02(\x04\x12\x0c\
    \n\x04name\x18\x06\x20\x02(\t\x12\x0e\n\x06volume\x18\x07\x20\x02(\t\x12\
    \x12\n\nextra_data\x18\x08\x20\x01(\x0c\"]\n\x0esetattrRequest\x12\x0c\n\
    \x04gfid\x18\x01\x20\x02(\t\x12\x1a\n\x05stbuf\x18\x02\x20\x02(\x0b2\x0b\
    .rusix.Iatt\x12\r\n\x05valid\x18\x03\x20\x02(\x05\x12\x12\n\nextra_data\
    \x18\x04\x20\x01(\x0c\"\x83\x01\n\x0fsetattrResponse\x12\x1f\n\x06result\
    \x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\x12\x1c\n\x07statpre\x18\x02\
    \x20\x01(\x0b2\x0b.rusix.Iatt\x12\x1d\n\x08statpost\x18\x03\x20\x01(\x0b\
    2\x0b.rusix.Iatt\x12\x12\n\nextra_data\x18\x04\x20\x01(\x0c\"\\\n\x0ffse\
    tattrRequest\x12\n\n\x02fd\x18\x01\x20\x02(\x04\x12\x1a\n\x05stbuf\x18\
    \x02\x20\x02(\x0b2\x0b.rusix.Iatt\x12\r\n\x05valid\x18\x03\x20\x02(\x05\
    \x12\x12\n\nextra_data\x18\x04\x20\x01(\x0c\"\x84\x01\n\x10fsetattrRespo\
    nse\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\x12\x1c\
    \n\x07statpre\x18\x02\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x1d\n\x08statpost\
    \x18\x03\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x12\n\nextra_data\x18\x04\x20\
    \x01(\x0c\"m\n\x10fallocateRequest\x12\x0c\n\x04gfid\x18\x01\x20\x02(\t\
    \x12\n\n\x02fd\x18\x02\x20\x02(\x04\x12\r\n\x05flags\x18\x03\x20\x02(\r\
    \x12\x0e\n\x06offset\x18\x04\x20\x02(\x04\x12\x0c\n\x04size\x18\x05\x20\
    \x02(\x04\x12\x12\n\nextra_data\x18\x06\x20\x01(\x0c\"\x85\x01\n\x11fall\
    ocateResponse\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResu\
    lt\x12\x1c\n\x07statpre\x18\x02\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x1d\n\
    \x08statpost\x18\x03\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x12\n\nextra_data\
    \x18\x04\x20\x01(\x0c\"\\\n\x0ediscardRequest\x12\x0c\n\x04gfid\x18\x01\
    \x20\x02(\t\x12\n\n\x02fd\x18\x02\x20\x02(\x04\x12\x0e\n\x06offset\x18\
    \x03\x20\x02(\x04\x12\x0c\n\x04size\x18\x04\x20\x02(\x04\x12\x12\n\nextr\
    a_data\x18\x05\x20\x01(\x0c\"\x83\x01\n\x0fdiscardResponse\x12\x1f\n\x06\
    result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\x12\x1c\n\x07statpre\x18\
    \x02\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x1d\n\x08statpost\x18\x03\x20\x01(\
    \x0b2\x0b.rusix.Iatt\x12\x12\n\nextra_data\x18\x04\x20\x01(\x0c\"]\n\x0f\
    zerofillRequest\x12\x0c\n\x04gfid\x18\x01\x20\x02(\t\x12\n\n\x02fd\x18\
    \x02\x20\x02(\x04\x12\x0e\n\x06offset\x18\x03\x20\x02(\x04\x12\x0c\n\x04\
    size\x18\x04\x20\x02(\x04\x12\x12\n\nextra_data\x18\x05\x20\x01(\x0c\"\
    \x84\x01\n\x10zerofillResponse\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\
    \x0f.rusix.OpResult\x12\x1c\n\x07statpre\x18\x02\x20\x01(\x0b2\x0b.rusix\
    .Iatt\x12\x1d\n\x08statpost\x18\x03\x20\x01(\x0b2\x0b.rusix.Iatt\x12\x12\
    \n\nextra_data\x18\x04\x20\x01(\x0c\"O\n\x10rchecksumRequest\x12\n\n\x02\
    fd\x18\x01\x20\x02(\x04\x12\x0e\n\x06offset\x18\x02\x20\x02(\x04\x12\x0b\
    \n\x03len\x18\x03\x20\x02(\r\x12\x12\n\nextra_data\x18\x04\x20\x01(\x0c\
    \"x\n\x11rchecksumResponse\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f\
    .rusix.OpResult\x12\x15\n\rweak_checksum\x18\x02\x20\x01(\r\x12\x17\n\
    \x0fstrong_checksum\x18\x03\x20\x01(\x0c\x12\x12\n\nextra_data\x18\x04\
    \x20\x01(\x0c\",\n\nipcRequest\x12\n\n\x02op\x18\x01\x20\x02(\r\x12\x12\
    \n\nextra_data\x18\x02\x20\x01(\x0c\"B\n\x0bipcResponse\x12\x1f\n\x06res\
    ult\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\x12\x12\n\nextra_data\x18\
    \x02\x20\x01(\x0c\"Y\n\x0bseekRequest\x12\x0c\n\x04gfid\x18\x01\x20\x02(\
    \t\x12\n\n\x02fd\x18\x02\x20\x02(\x04\x12\x0e\n\x06offset\x18\x03\x20\
    \x02(\x04\x12\x0c\n\x04what\x18\x04\x20\x02(\x05\x12\x12\n\nextra_data\
    \x18\x05\x20\x01(\x0c\"S\n\x0cseekResponse\x12\x1f\n\x06result\x18\x01\
    \x20\x02(\x0b2\x0f.rusix.OpResult\x12\x0e\n\x06offset\x18\x02\x20\x01(\
    \x04\x12\x12\n\nextra_data\x18\x03\x20\x01(\x0c\"-\n\x10setvolumeRequest\
    \x12\x19\n\x04dict\x18\x01\x20\x02(\x0b2\x0b.rusix.Dict\"O\n\x11setvolum\
    eResponse\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\
    \x12\x19\n\x04dict\x18\x02\x20\x01(\x0b2\x0b.rusix.Dict\"@\n\x0egetspecR\
    equest\x12\r\n\x05flags\x18\x01\x20\x02(\r\x12\x0b\n\x03key\x18\x02\x20\
    \x02(\t\x12\x12\n\nextra_data\x18\x03\x20\x01(\x0c\"T\n\x0fgetspecRespon\
    se\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\x12\x0c\
    \n\x04spec\x18\x02\x20\x01(\t\x12\x12\n\nextra_data\x18\x03\x20\x01(\x0c\
    \"3\n\x16get_volume_infoRequest\x12\x19\n\x04dict\x18\x01\x20\x02(\x0b2\
    \x0b.rusix.Dict\"h\n\x17get_volume_infoResponse\x12\x1f\n\x06result\x18\
    \x01\x20\x02(\x0b2\x0f.rusix.OpResult\x12\x11\n\top_errstr\x18\x02\x20\
    \x01(\t\x12\x19\n\x04dict\x18\x03\x20\x01(\x0b2\x0b.rusix.Dict\"\"\n\x11\
    mgmt_hndskRequest\x12\r\n\x05hndsk\x18\x01\x20\x02(\x0c\"D\n\x12mgmt_hnd\
    skResponse\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\
    \x12\r\n\x05hndsk\x18\x02\x20\x01(\x0c\"\x19\n\nLogRequest\x12\x0b\n\x03\
    msg\x18\x01\x20\x02(\x0c\"?\n\rnotifyRequest\x12\r\n\x05flags\x18\x01\
    \x20\x02(\r\x12\x0b\n\x03buf\x18\x02\x20\x02(\t\x12\x12\n\nextra_data\
    \x18\x03\x20\x01(\x0c\"a\n\x0enotifyResponse\x12\x1f\n\x06result\x18\x01\
    \x20\x02(\x0b2\x0f.rusix.OpResult\x12\r\n\x05flags\x18\x02\x20\x01(\r\
    \x12\x0b\n\x03buf\x18\x03\x20\x01(\t\x12\x12\n\nextra_data\x18\x04\x20\
    \x01(\x0c\"A\n\x11ReleasedirRequest\x12\x0c\n\x04gfid\x18\x01\x20\x02(\t\
    \x12\n\n\x02fd\x18\x02\x20\x02(\x04\x12\x12\n\nextra_data\x18\x03\x20\
    \x01(\x0c\">\n\x0eReleaseRequest\x12\x0c\n\x04gfid\x18\x01\x20\x02(\t\
    \x12\n\n\x02fd\x18\x02\x20\x02(\x04\x12\x12\n\nextra_data\x18\x03\x20\
    \x01(\x0c\"Y\n\x0cDirListEntry\x12\r\n\x05d_ino\x18\x01\x20\x02(\x04\x12\
    \r\n\x05d_off\x18\x02\x20\x02(\x04\x12\r\n\x05d_len\x18\x03\x20\x02(\r\
    \x12\x0e\n\x06d_type\x18\x04\x20\x02(\r\x12\x0c\n\x04name\x18\x05\x20\
    \x02(\t\"-\n\x07DirList\x12\"\n\x05entry\x18\x01\x20\x03(\x0b2\x13.rusix\
    .DirListEntry\"e\n\x0fReaddirResponse\x12\x1f\n\x06result\x18\x01\x20\
    \x02(\x0b2\x0f.rusix.OpResult\x12\x1d\n\x05reply\x18\x02\x20\x01(\x0b2\
    \x0e.rusix.DirList\x12\x12\n\nextra_data\x18\x03\x20\x01(\x0c\"\x90\x01\
    \n\rDirPListEntry\x12\r\n\x05d_ino\x18\x01\x20\x02(\x04\x12\r\n\x05d_off\
    \x18\x02\x20\x02(\x04\x12\r\n\x05d_len\x18\x03\x20\x02(\r\x12\x0e\n\x06d\
    _type\x18\x04\x20\x02(\r\x12\x0c\n\x04name\x18\x05\x20\x02(\t\x12\x19\n\
    \x04stat\x18\x06\x20\x02(\x0b2\x0b.rusix.Iatt\x12\x19\n\x04dict\x18\x07\
    \x20\x02(\x0b2\x0b.rusix.Dict\"/\n\x08DirPList\x12#\n\x05entry\x18\x01\
    \x20\x03(\x0b2\x14.rusix.DirPListEntry\"g\n\x10readdirpResponse\x12\x1f\
    \n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\x12\x1e\n\x05reply\
    \x18\x02\x20\x01(\x0b2\x0f.rusix.DirPList\x12\x12\n\nextra_data\x18\x03\
    \x20\x01(\x0c\"E\n\x12Set_lk_verResponse\x12\x1f\n\x06result\x18\x01\x20\
    \x02(\x0b2\x0f.rusix.OpResult\x12\x0e\n\x06lk_ver\x18\x02\x20\x01(\x05\"\
    0\n\x11Set_lk_verRequest\x12\x0b\n\x03uid\x18\x01\x20\x02(\t\x12\x0e\n\
    \x06lk_ver\x18\x02\x20\x02(\x05\";\n\x12EventNotifyRequest\x12\n\n\x02op\
    \x18\x01\x20\x02(\x05\x12\x19\n\x04dict\x18\x02\x20\x02(\x0b2\x0b.rusix.\
    Dict\"D\n\x13EventNotifyResponse\x12\x1f\n\x06result\x18\x01\x20\x02(\
    \x0b2\x0f.rusix.OpResult\x12\x0c\n\x04dict\x18\x02\x20\x01(\x0c\"3\n\x16\
    GetSnapNameUuidRequest\x12\x19\n\x04dict\x18\x01\x20\x02(\x0b2\x0b.rusix\
    .Dict\"U\n\x17GetSnapNameUuidResponse\x12\x1f\n\x06result\x18\x01\x20\
    \x02(\x0b2\x0f.rusix.OpResult\x12\x19\n\x04dict\x18\x02\x20\x01(\x0b2\
    \x0b.rusix.Dict\"]\n\x0fcompoundRequest\x12\x18\n\x10compound_version\
    \x18\x01\x20\x02(\x05\x12\x1c\n\x08requests\x18\x02\x20\x03(\x0e2\n.rusi\
    x.Fop\x12\x12\n\nextra_data\x18\x03\x20\x01(\x0c\"G\n\x10CompoundRespons\
    e\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.OpResult\x12\x12\n\
    \nextra_data\x18\x02\x20\x01(\x0c\"W\n\rLocklistEntry\x12\x20\n\x05flock\
    \x18\x01\x20\x02(\x0b2\x11.rusix.ProtoFlock\x12\x12\n\nclient_uid\x18\
    \x02\x20\x02(\t\x12\x10\n\x08lk_flags\x18\x03\x20\x02(\r\"/\n\x08LockLis\
    t\x12#\n\x05entry\x18\x01\x20\x03(\x0b2\x14.rusix.LocklistEntry\"j\n\x13\
    GetactivelkResponse\x12\x1f\n\x06result\x18\x01\x20\x02(\x0b2\x0f.rusix.\
    OpResult\x12\x1e\n\x05reply\x18\x02\x20\x01(\x0b2\x0f.rusix.LockList\x12\
    \x12\n\nextra_data\x18\x03\x20\x01(\x0c\"6\n\x12GetactivelkRequest\x12\
    \x0c\n\x04gfid\x18\x01\x20\x02(\t\x12\x12\n\nextra_data\x18\x02\x20\x01(\
    \x0c\"J\n\x13SetactivelkResponse\x12\x1f\n\x06result\x18\x01\x20\x02(\
    \x0b2\x0f.rusix.OpResult\x12\x12\n\nextra_data\x18\x02\x20\x01(\x0c\"X\n\
    \x12SetactivelkRequest\x12\x0c\n\x04gfid\x18\x01\x20\x02(\t\x12\x20\n\
    \x07request\x18\x02\x20\x02(\x0b2\x0f.rusix.LockList\x12\x12\n\nextra_da\
    ta\x18\x03\x20\x01(\x0c*\xc1\x04\n\x03Fop\x12\x07\n\x03IPC\x10\x01\x12\n\
    \n\x06LOOKUP\x10\x02\x12\t\n\x05MKNOD\x10\x03\x12\n\n\x06CREATE\x10\x04\
    \x12\x08\n\x04OPEN\x10\x05\x12\n\n\x06STATFS\x10\x06\x12\x0b\n\x07OPENDI\
    R\x10\x07\x12\x0b\n\x07READDIR\x10\x08\x12\x0c\n\x08READDIRP\x10\t\x12\
    \x0c\n\x08FSYNCDIR\x10\n\x12\x0b\n\x07SYMLINK\x10\x0b\x12\n\n\x06UNLINK\
    \x10\x0c\x12\x08\n\x04LINK\x10\r\x12\t\n\x05MKDIR\x10\x0e\x12\t\n\x05RMD\
    IR\x10\x0f\x12\n\n\x06RENAME\x10\x10\x12\x0b\n\x07ENTRYLK\x10\x11\x12\
    \x0c\n\x08FENTRYLK\x10\x12\x12\x08\n\x04STAT\x10\x13\x12\t\n\x05FSTAT\
    \x10\x14\x12\n\n\x06ACCESS\x10\x15\x12\x0c\n\x08READLINK\x10\x16\x12\x0c\
    \n\x08GETXATTR\x10\x17\x12\r\n\tFGETXATTR\x10\x18\x12\t\n\x05READV\x10\
    \x19\x12\t\n\x05FLUSH\x10\x1a\x12\t\n\x05FSYNC\x10\x1b\x12\x0b\n\x07INOD\
    ELK\x10\x1c\x12\x0c\n\x08FINODELK\x10\x1d\x12\x06\n\x02LK\x10\x1e\x12\t\
    \n\x05LEASE\x10\x1f\x12\x10\n\x0cFREMOVEXATTR\x10\x20\x12\x0f\n\x0bREMOV\
    EXATTR\x10!\x12\x0c\n\x08SETXATTR\x10\"\x12\r\n\tFSETXATTR\x10#\x12\x0c\
    \n\x08TRUNCATE\x10$\x12\r\n\tFTRUNCATE\x10%\x12\n\n\x06WRITEV\x10&\x12\
    \x0b\n\x07XATTROP\x10'\x12\x0c\n\x08FXATTROP\x10(\x12\x0b\n\x07SETATTR\
    \x10)\x12\x0c\n\x08FSETATTR\x10*\x12\r\n\tFALLOCATE\x10+\x12\x0b\n\x07DI\
    SCARD\x10,\x12\x0c\n\x08ZEROFILL\x10-*\xaf\x03\n\x05Event\x12\r\n\tPAREN\
    T_UP\x10\x01\x12\n\n\x06POLLIN\x10\x02\x12\x0b\n\x07POLLOUT\x10\x03\x12\
    \x0b\n\x07POLLERR\x10\x04\x12\x0c\n\x08CHILD_UP\x10\x05\x12\x0e\n\nCHILD\
    _DOWN\x10\x06\x12\x14\n\x10CHILD_CONNECTING\x10\x07\x12\x0b\n\x07CLEANUP\
    \x10\x08\x12\x17\n\x13TRANSPORT_CONNECTED\x10\t\x12\x14\n\x10VOLFILE_MOD\
    IFIED\x10\n\x12\r\n\tGRAPH_NEW\x10\x0b\x12\x13\n\x0fTRANSLATOR_INFO\x10\
    \x0c\x12\x11\n\rTRANSLATOR_OP\x10\r\x12\x0f\n\x0bAUTH_FAILED\x10\x0e\x12\
    \x11\n\rVOLUME_DEFRAG\x10\x0f\x12\x0f\n\x0bPARENT_DOWN\x10\x10\x12\x15\n\
    \x11VOLUME_BARRIER_OP\x10\x11\x12\n\n\x06UPCALL\x10\x12\x12\x10\n\x0cSCR\
    UB_STATUS\x10\x13\x12\x18\n\x14SOME_DESCENDENT_DOWN\x10\x14\x12\x12\n\
    \x0eSCRUB_ONDEMAND\x10\x15\x12\x16\n\x12SOME_DESCENDENT_UP\x10\x16\x12\
    \x0e\n\nCHILD_PING\x10\x17\x12\n\n\x06MAXVAL\x10\x18*y\n\x0bCompoundFop\
    \x12\x17\n\x13CFOP_NON_PREDEFINED\x10\x01\x12\x17\n\x13CFOP_XATTROP_WRIT\
    EV\x10\x02\x12\x17\n\x13CFOP_XATTROP_UNLOCK\x10\x03\x12\x0c\n\x08CFOP_PU\
    T\x10\x04\x12\x11\n\rCFOP_MAXVALUE\x10\x05*(\n\x04Mgmt\x12\r\n\tMGMT_NUL\
    L\x10\x01\x12\x11\n\rMGMT_MAXVALUE\x10\x02*N\n\x06OpType\x12\x10\n\x0cOP\
    _TYPE_NULL\x10\x01\x12\x0f\n\x0bOP_TYPE_FOP\x10\x02\x12\x10\n\x0cOP_TYPE\
    _MGMT\x10\x03\x12\x0f\n\x0bOP_TYPE_MAX\x10\x04*\x7f\n\x08LockCmds\x12\
    \x0c\n\x08LK_GETLK\x10\x01\x12\x0c\n\x08LK_SETLK\x10\x02\x12\r\n\tLK_SET\
    LKW\x10\x03\x12\x10\n\x0cLK_RESLK_LCK\x10\x04\x12\x11\n\rLK_RESLK_LCKW\
    \x10\x05\x12\x12\n\x0eLK_RESLK_UNLCK\x10\x06\x12\x0f\n\x0bLK_GETLK_FD\
    \x10\x07*G\n\tLockTypes\x12\x0e\n\nLK_F_RDLCK\x10\x01\x12\x0e\n\nLK_F_WR\
    LCK\x10\x02\x12\x0e\n\nLK_F_UNLCK\x10\x03\x12\n\n\x06LK_EOL\x10\x04*F\n\
    \nLeaseTypes\x12\x08\n\x04NONE\x10\x01\x12\x0c\n\x08RD_LEASE\x10\x02\x12\
    \x0c\n\x08RW_LEASE\x10\x03\x12\x12\n\x0eLEASE_MAX_TYPE\x10\x04*9\n\tLeas\
    eCmds\x12\r\n\tGET_LEASE\x10\x01\x12\r\n\tSET_LEASE\x10\x02\x12\x0e\n\nU\
    NLK_LEASE\x10\x03*X\n\x10LockRecoveryCmds\x12\x0f\n\x0bF_RESLK_LCK\x10\
    \x01\x12\x10\n\x0cF_RESLK_LCKW\x10\x02\x12\x11\n\rF_RESLK_UNLCK\x10\x03\
    \x12\x0e\n\nF_GETLK_FD\x10\x04*/\n\nLockDomain\x12\x0e\n\nLOCK_POSIX\x10\
    \x01\x12\x11\n\rLOCK_INTERNAL\x10\x02*I\n\x0cEntryLockCmd\x12\x10\n\x0cE\
    NTRYLK_LOCK\x10\x01\x12\x12\n\x0eENTRYLK_UNLOCK\x10\x02\x12\x13\n\x0fENT\
    RYLK_LOCK_NB\x10\x03*5\n\rEntryLockType\x12\x11\n\rENTRYLK_RDLCK\x10\x01\
    \x12\x11\n\rENTRYLK_WRLCK\x10\x02*\xce\x01\n\x0cXattropFlags\x12\x15\n\
    \x11XATTROP_ADD_ARRAY\x10\x01\x12\x17\n\x13XATTROP_ADD_ARRAY64\x10\x02\
    \x12\x14\n\x10XATTROP_OR_ARRAY\x10\x03\x12\x15\n\x11XATTROP_AND_ARRAY\
    \x10\x04\x12\x17\n\x13XATTROP_GET_AND_SET\x10\x05\x12\"\n\x1eXATTROP_ADD\
    _ARRAY_WITH_DEFAULT\x10\x06\x12$\n\x20XATTROP_ADD_ARRAY64_WITH_DEFAULT\
    \x10\x07*(\n\x08SeekWhat\x12\r\n\tSEEK_DATA\x10\x01\x12\r\n\tSEEK_HOLE\
    \x10\x02*\xbb\x01\n\x0bUpcallFlags\x12\x0f\n\x0bUPCALL_NULL\x10\x01\x12\
    \x12\n\x0eUPCALL_CI_STAT\x10\x03\x12\x13\n\x0fUPCALL_CI_XATTR\x10\x04\
    \x12\x14\n\x10UPCALL_CI_RENAME\x10\x05\x12\x13\n\x0fUPCALL_CI_NLINK\x10\
    \x06\x12\x14\n\x10UPCALL_CI_FORGET\x10\x07\x12\x17\n\x13UPCALL_LEASE_REC\
    ALL\x10\x08\x12\x18\n\x14UPCALL_FLAGS_MAXVALU\x10\t*\xc9\x01\n\x10dict_d\
    ata_type_t\x12\x15\n\x11DATA_TYPE_UNKNOWN\x10\x01\x12\x11\n\rDATA_TYPE_I\
    NT\x10\x02\x12\x12\n\x0eDATA_TYPE_UINT\x10\x03\x12\x14\n\x10DATA_TYPE_DO\
    UBLE\x10\x04\x12\x11\n\rDATA_TYPE_STR\x10\x05\x12\x11\n\rDATA_TYPE_PTR\
    \x10\x06\x12\x14\n\x10DATA_TYPE_GFUUID\x10\x07\x12\x12\n\x0eDATA_TYPE_IA\
    TT\x10\x08\x12\x11\n\rDATA_TYPE_MAX\x10\t*\x1d\n\nResultType\x12\x06\n\
    \x02OK\x10\x01\x12\x07\n\x03ERR\x10\x02B\x02H\x01\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
